if ( TRACE ) { TRACE( JSON.parse( '["Anim#Awake","Anim#SetAnim","CameraAnchor#init","CameraAnchor#Start","CameraAnchor#UpdateAnchorAsync","CameraAnchor#UpdateAnchor","CameraAnchor#SetAnchor","CameraElement#WinPosition#get","CameraElement#WinPosition#set","CameraElement#init","CameraElement#OnTriggerEnter2D","CameraElement#DelayDestroy","CameraElement#OnWin","Singleton$1#Ins#get","Singleton$1#init","Cat#Anim#get","Cat#Start","Constant#init","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOPath$1","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","Hand#Start","Hand#SetClick","Hand#RunAnim","Hand#LoopClick","InputReceiver#Update","InputReceiver#HandleTarget","InputReceiver#ResetTutorial","InputReceiver#TriggerCTA","ItemLetter#Start","Level#Main#get","Level#MaxScore#get","Level#Hand#get","Level#init","Level#Start","Level#Update","Level#UpdateScale","Level#SetUp","Level#SetTutorial","Level#ECTutorial","Level#OnWin","Level#OnLose","Level#SetUpSoundCharacter","Liquid#OnEnable","Liquid#OnCollisionStay2D","Liquid#TransferToRock","Main#Anim#get","Main#Start","Main#SetAnimScare","Pin#Center#get","Pin#ActivePin","Pin#DelayDestroy","Rat#Start","SharpJson.JsonDecoder#DecodeText","SharpJson.JsonDecoder#ctor","SharpJson.JsonDecoder#Decode","SharpJson.JsonDecoder#ParseObject","SharpJson.JsonDecoder#ParseArray","SharpJson.JsonDecoder#ParseValue","SharpJson.JsonDecoder#TriggerError","SharpJson.JsonDecoder#EvalLexer","SharpJson.Lexer#NextToken","SharpJson.Lexer#hasError#get","SharpJson.Lexer#init","SharpJson.Lexer#ctor","SharpJson.Lexer#Reset","SharpJson.Lexer#ParseString","SharpJson.Lexer#GetNumberString","SharpJson.Lexer#ParseFloatNumber","SharpJson.Lexer#ParseDoubleNumber","SharpJson.Lexer#GetLastIndexOfNumber","SharpJson.Lexer#SkipWhiteSpaces","SharpJson.Lexer#LookAhead","SharpJson.Lexer#NextToken","Spine.Timeline#Search","Spine.Timeline#Search$1","Spine.Timeline#PropertyIds#get","Spine.Timeline#Frames#get","Spine.Timeline#FrameEntries#get","Spine.Timeline#FrameCount#get","Spine.Timeline#Duration#get","Spine.Timeline#ctor","Spine.Animation#Timelines#get","Spine.Animation#Timelines#set","Spine.Animation#Duration#get","Spine.Animation#Duration#set","Spine.Animation#Name#get","Spine.Animation#ctor","Spine.Animation#SetTimelines","Spine.Animation#HasTimeline","Spine.Animation#Apply","Spine.Animation#toString","Spine.AnimationState#init","Spine.AnimationState#ApplyRotateTimeline","Spine.AnimationState#TimeScale#get","Spine.AnimationState#TimeScale#set","Spine.AnimationState#Data#get","Spine.AnimationState#Data#set","Spine.AnimationState#Tracks#get","Spine.AnimationState#init","Spine.AnimationState#ctor","Spine.AnimationState#OnStart","Spine.AnimationState#OnInterrupt","Spine.AnimationState#OnEnd","Spine.AnimationState#OnDispose","Spine.AnimationState#OnComplete","Spine.AnimationState#OnEvent","Spine.AnimationState#AssignEventSubscribersFrom","Spine.AnimationState#AddEventSubscribersFrom","Spine.AnimationState#Update","Spine.AnimationState#UpdateMixingFrom","Spine.AnimationState#Apply","Spine.AnimationState#ApplyEventTimelinesOnly","Spine.AnimationState#ApplyMixingFrom","Spine.AnimationState#ApplyMixingFromEventTimelinesOnly","Spine.AnimationState#ApplyAttachmentTimeline","Spine.AnimationState#SetAttachment","Spine.AnimationState#QueueEvents","Spine.AnimationState#ClearTracks","Spine.AnimationState#ClearTrack","Spine.AnimationState#SetCurrent","Spine.AnimationState#SetAnimation$1","Spine.AnimationState#SetAnimation","Spine.AnimationState#AddAnimation$1","Spine.AnimationState#AddAnimation","Spine.AnimationState#SetEmptyAnimation","Spine.AnimationState#AddEmptyAnimation","Spine.AnimationState#SetEmptyAnimations","Spine.AnimationState#ExpandToIndex","Spine.AnimationState#NewTrackEntry","Spine.AnimationState#ClearNext","Spine.AnimationState#AnimationsChanged","Spine.AnimationState#ComputeHold","Spine.AnimationState#GetCurrent","Spine.AnimationState#ClearListenerNotifications","Spine.AnimationState#toString","Spine.AnimationStateData#SkeletonData#get","Spine.AnimationStateData#DefaultMix#get","Spine.AnimationStateData#DefaultMix#set","Spine.AnimationStateData#init","Spine.AnimationStateData#ctor","Spine.AnimationStateData#SetMix$1","Spine.AnimationStateData#SetMix","Spine.AnimationStateData#GetMix","Spine.AnimationStateData.AnimationPair#getDefaultValue","Spine.AnimationStateData.AnimationPair#$ctor1","Spine.AnimationStateData.AnimationPair#ctor","Spine.AnimationStateData.AnimationPair#toString","Spine.AnimationStateData.AnimationPair#getHashCode","Spine.AnimationStateData.AnimationPair#equals","Spine.AnimationStateData.AnimationPair#$clone","Spine.TextureRegion#OriginalWidth#get","Spine.TextureRegion#OriginalHeight#get","Spine.AtlasPage#init","Spine.AtlasPage#Clone","Spine.Attachment#$ctor1","Spine.Attachment#ctor","Spine.Attachment#toString","Spine.BoneData#Index#get","Spine.BoneData#Name#get","Spine.BoneData#Parent#get","Spine.BoneData#Length#get","Spine.BoneData#Length#set","Spine.BoneData#X#get","Spine.BoneData#X#set","Spine.BoneData#Y#get","Spine.BoneData#Y#set","Spine.BoneData#Rotation#get","Spine.BoneData#Rotation#set","Spine.BoneData#ScaleX#get","Spine.BoneData#ScaleX#set","Spine.BoneData#ScaleY#get","Spine.BoneData#ScaleY#set","Spine.BoneData#ShearX#get","Spine.BoneData#ShearX#set","Spine.BoneData#ShearY#get","Spine.BoneData#ShearY#set","Spine.BoneData#TransformMode#get","Spine.BoneData#TransformMode#set","Spine.BoneData#SkinRequired#get","Spine.BoneData#SkinRequired#set","Spine.BoneData#init","Spine.BoneData#ctor","Spine.BoneData#toString","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.ConstraintData#Name#get","Spine.ConstraintData#Order#get","Spine.ConstraintData#Order#set","Spine.ConstraintData#SkinRequired#get","Spine.ConstraintData#SkinRequired#set","Spine.ConstraintData#ctor","Spine.ConstraintData#toString","Spine.Event#Data#get","Spine.Event#Time#get","Spine.Event#Int#get","Spine.Event#Int#set","Spine.Event#Float#get","Spine.Event#Float#set","Spine.Event#String#get","Spine.Event#String#set","Spine.Event#Volume#get","Spine.Event#Volume#set","Spine.Event#Balance#get","Spine.Event#Balance#set","Spine.Event#ctor","Spine.Event#toString","Spine.EventData#Name#get","Spine.EventData#ctor","Spine.EventData#toString","Spine.EventQueue#init","Spine.EventQueue#ctor","Spine.EventQueue#Start","Spine.EventQueue#Interrupt","Spine.EventQueue#End","Spine.EventQueue#Dispose","Spine.EventQueue#Complete","Spine.EventQueue#Event","Spine.EventQueue#Drain","Spine.EventQueue#Clear","Spine.EventQueue.EventQueueEntry#getDefaultValue","Spine.EventQueue.EventQueueEntry#$ctor1","Spine.EventQueue.EventQueueEntry#ctor","Spine.EventQueue.EventQueueEntry#getHashCode","Spine.EventQueue.EventQueueEntry#equals","Spine.EventQueue.EventQueueEntry#$clone","Spine.ExposedList$1#init","Spine.ExposedList$1#CheckMatch","Spine.ExposedList$1#Capacity#get","Spine.ExposedList$1#Capacity#set","Spine.ExposedList$1#ctor","Spine.ExposedList$1#$ctor2","Spine.ExposedList$1#$ctor3","Spine.ExposedList$1#$ctor1","Spine.ExposedList$1#Add","Spine.ExposedList$1#GrowIfNeeded","Spine.ExposedList$1#Resize","Spine.ExposedList$1#EnsureCapacity","Spine.ExposedList$1#CheckRange","Spine.ExposedList$1#AddCollection","Spine.ExposedList$1#AddEnumerable","Spine.ExposedList$1#AddRange","Spine.ExposedList$1#AddRange$1","Spine.ExposedList$1#BinarySearch","Spine.ExposedList$1#BinarySearch$1","Spine.ExposedList$1#BinarySearch$2","Spine.ExposedList$1#Clear","Spine.ExposedList$1#Contains","Spine.ExposedList$1#ConvertAll","Spine.ExposedList$1#CopyTo","Spine.ExposedList$1#CopyTo$1","Spine.ExposedList$1#CopyTo$2","Spine.ExposedList$1#Exists","Spine.ExposedList$1#Find","Spine.ExposedList$1#FindAll","Spine.ExposedList$1#FindAllList","Spine.ExposedList$1#FindIndex$2","Spine.ExposedList$1#FindIndex$1","Spine.ExposedList$1#FindIndex","Spine.ExposedList$1#GetIndex","Spine.ExposedList$1#FindLast","Spine.ExposedList$1#FindLastIndex$2","Spine.ExposedList$1#FindLastIndex$1","Spine.ExposedList$1#FindLastIndex","Spine.ExposedList$1#GetLastIndex","Spine.ExposedList$1#ForEach","Spine.ExposedList$1#GetEnumerator","Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator","Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator","Spine.ExposedList$1#GetRange","Spine.ExposedList$1#IndexOf","Spine.ExposedList$1#IndexOf$1","Spine.ExposedList$1#IndexOf$2","Spine.ExposedList$1#Shift","Spine.ExposedList$1#CheckIndex","Spine.ExposedList$1#Insert","Spine.ExposedList$1#CheckCollection","Spine.ExposedList$1#InsertRange","Spine.ExposedList$1#InsertCollection","Spine.ExposedList$1#InsertEnumeration","Spine.ExposedList$1#LastIndexOf","Spine.ExposedList$1#LastIndexOf$1","Spine.ExposedList$1#LastIndexOf$2","Spine.ExposedList$1#Remove","Spine.ExposedList$1#RemoveAll","Spine.ExposedList$1#RemoveAt","Spine.ExposedList$1#Pop","Spine.ExposedList$1#RemoveRange","Spine.ExposedList$1#Reverse","Spine.ExposedList$1#Reverse$1","Spine.ExposedList$1#Sort","Spine.ExposedList$1#Sort$1","Spine.ExposedList$1#Sort$2","Spine.ExposedList$1#Sort$3","Spine.ExposedList$1#ToArray","Spine.ExposedList$1#TrimExcess","Spine.ExposedList$1#TrueForAll","Spine.ExposedList$1.Enumerator#getDefaultValue","Spine.ExposedList$1.Enumerator#Current#get","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get","Spine.ExposedList$1.Enumerator#init","Spine.ExposedList$1.Enumerator#$ctor1","Spine.ExposedList$1.Enumerator#ctor","Spine.ExposedList$1.Enumerator#Dispose","Spine.ExposedList$1.Enumerator#VerifyState","Spine.ExposedList$1.Enumerator#moveNext","Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset","Spine.ExposedList$1.Enumerator#getHashCode","Spine.ExposedList$1.Enumerator#equals","Spine.ExposedList$1.Enumerator#$clone","Spine.HashSetExtensions#AddAll","Spine.IInterpolation#init","Spine.IInterpolation#Apply","Spine.Json#Deserialize","Spine.MathUtils#init","Spine.MathUtils#Sin","Spine.MathUtils#Cos","Spine.MathUtils#SinDeg","Spine.MathUtils#CosDeg","Spine.MathUtils#Atan2","Spine.MathUtils#Clamp","Spine.MathUtils#RandomTriangle","Spine.MathUtils#RandomTriangle$1","Spine.Polygon#ctor","Spine.Pool$1#Count#get","Spine.Pool$1#ctor","Spine.Pool$1#Obtain","Spine.Pool$1#Free","Spine.Pool$1#Clear","Spine.Pool$1#Reset","Spine.Sequence#init","Spine.Sequence#Start#get","Spine.Sequence#Start#set","Spine.Sequence#Digits#get","Spine.Sequence#Digits#set","Spine.Sequence#SetupIndex#get","Spine.Sequence#SetupIndex#set","Spine.Sequence#Regions#get","Spine.Sequence#Id#get","Spine.Sequence#$ctor1","Spine.Sequence#ctor","Spine.Sequence#Apply","Spine.Sequence#GetPath","Spine.Skeleton#SortReset","Spine.Skeleton#Data#get","Spine.Skeleton#Bones#get","Spine.Skeleton#UpdateCacheList#get","Spine.Skeleton#Slots#get","Spine.Skeleton#DrawOrder#get","Spine.Skeleton#IkConstraints#get","Spine.Skeleton#PathConstraints#get","Spine.Skeleton#TransformConstraints#get","Spine.Skeleton#Skin#get","Spine.Skeleton#Skin#set","Spine.Skeleton#R#get","Spine.Skeleton#R#set","Spine.Skeleton#G#get","Spine.Skeleton#G#set","Spine.Skeleton#B#get","Spine.Skeleton#B#set","Spine.Skeleton#A#get","Spine.Skeleton#A#set","Spine.Skeleton#X#get","Spine.Skeleton#X#set","Spine.Skeleton#Y#get","Spine.Skeleton#Y#set","Spine.Skeleton#ScaleX#get","Spine.Skeleton#ScaleX#set","Spine.Skeleton#ScaleY#get","Spine.Skeleton#ScaleY#set","Spine.Skeleton#FlipX#get","Spine.Skeleton#FlipX#set","Spine.Skeleton#FlipY#get","Spine.Skeleton#FlipY#set","Spine.Skeleton#RootBone#get","Spine.Skeleton#init","Spine.Skeleton#$ctor1","Spine.Skeleton#ctor","Spine.Skeleton#UpdateCache","Spine.Skeleton#SortIkConstraint","Spine.Skeleton#SortTransformConstraint","Spine.Skeleton#SortPathConstraint","Spine.Skeleton#SortPathConstraintAttachment$1","Spine.Skeleton#SortPathConstraintAttachment","Spine.Skeleton#SortBone","Spine.Skeleton#UpdateWorldTransform","Spine.Skeleton#UpdateWorldTransform$1","Spine.Skeleton#SetToSetupPose","Spine.Skeleton#SetBonesToSetupPose","Spine.Skeleton#SetSlotsToSetupPose","Spine.Skeleton#FindBone","Spine.Skeleton#FindSlot","Spine.Skeleton#SetSkin$1","Spine.Skeleton#SetSkin","Spine.Skeleton#GetAttachment$1","Spine.Skeleton#GetAttachment","Spine.Skeleton#SetAttachment","Spine.Skeleton#FindIkConstraint","Spine.Skeleton#FindTransformConstraint","Spine.Skeleton#FindPathConstraint","Spine.Skeleton#GetBounds","Spine.SkeletonLoader#Scale#get","Spine.SkeletonLoader#Scale#set","Spine.SkeletonLoader#init","Spine.SkeletonLoader#ctor","Spine.SkeletonLoader#$ctor1","Spine.SkeletonBinary.SkeletonInput#init","Spine.SkeletonBinary.SkeletonInput#ctor","Spine.SkeletonBinary.SkeletonInput#Read","Spine.SkeletonBinary.SkeletonInput#ReadByte","Spine.SkeletonBinary.SkeletonInput#ReadSByte","Spine.SkeletonBinary.SkeletonInput#ReadBoolean","Spine.SkeletonBinary.SkeletonInput#ReadFloat","Spine.SkeletonBinary.SkeletonInput#ReadInt","Spine.SkeletonBinary.SkeletonInput#ReadInt$1","Spine.SkeletonBinary.SkeletonInput#ReadLong","Spine.SkeletonBinary.SkeletonInput#ReadString","Spine.SkeletonBinary.SkeletonInput#ReadStringRef","Spine.SkeletonBinary.SkeletonInput#ReadFully","Spine.SkeletonBinary.SkeletonInput#GetVersionString","Spine.SkeletonBinary.SkeletonInput#GetVersionStringOld3X","Spine.SkeletonBounds#MinX#get","Spine.SkeletonBounds#MinX#set","Spine.SkeletonBounds#MinY#get","Spine.SkeletonBounds#MinY#set","Spine.SkeletonBounds#MaxX#get","Spine.SkeletonBounds#MaxX#set","Spine.SkeletonBounds#MaxY#get","Spine.SkeletonBounds#MaxY#set","Spine.SkeletonBounds#Width#get","Spine.SkeletonBounds#Height#get","Spine.SkeletonBounds#init","Spine.SkeletonBounds#ctor","Spine.SkeletonBounds#Update","Spine.SkeletonBounds#AabbCompute","Spine.SkeletonBounds#AabbContainsPoint","Spine.SkeletonBounds#AabbIntersectsSegment","Spine.SkeletonBounds#AabbIntersectsSkeleton","Spine.SkeletonBounds#ContainsPoint$1","Spine.SkeletonBounds#ContainsPoint","Spine.SkeletonBounds#IntersectsSegment","Spine.SkeletonBounds#IntersectsSegment$1","Spine.SkeletonBounds#GetPolygon","Spine.SkeletonClipping#MakeClockwise","Spine.SkeletonClipping#ClippedVertices#get","Spine.SkeletonClipping#ClippedTriangles#get","Spine.SkeletonClipping#ClippedUVs#get","Spine.SkeletonClipping#IsClipping#get","Spine.SkeletonClipping#init","Spine.SkeletonClipping#ClipStart","Spine.SkeletonClipping#ClipEnd$1","Spine.SkeletonClipping#ClipEnd","Spine.SkeletonClipping#ClipTriangles","Spine.SkeletonClipping#Clip","Spine.SkeletonData#Name#get","Spine.SkeletonData#Name#set","Spine.SkeletonData#Bones#get","Spine.SkeletonData#Slots#get","Spine.SkeletonData#Skins#get","Spine.SkeletonData#Skins#set","Spine.SkeletonData#DefaultSkin#get","Spine.SkeletonData#DefaultSkin#set","Spine.SkeletonData#Events#get","Spine.SkeletonData#Events#set","Spine.SkeletonData#Animations#get","Spine.SkeletonData#Animations#set","Spine.SkeletonData#IkConstraints#get","Spine.SkeletonData#IkConstraints#set","Spine.SkeletonData#TransformConstraints#get","Spine.SkeletonData#TransformConstraints#set","Spine.SkeletonData#PathConstraints#get","Spine.SkeletonData#PathConstraints#set","Spine.SkeletonData#X#get","Spine.SkeletonData#X#set","Spine.SkeletonData#Y#get","Spine.SkeletonData#Y#set","Spine.SkeletonData#Width#get","Spine.SkeletonData#Width#set","Spine.SkeletonData#Height#get","Spine.SkeletonData#Height#set","Spine.SkeletonData#Version#get","Spine.SkeletonData#Version#set","Spine.SkeletonData#Hash#get","Spine.SkeletonData#Hash#set","Spine.SkeletonData#ImagesPath#get","Spine.SkeletonData#ImagesPath#set","Spine.SkeletonData#AudioPath#get","Spine.SkeletonData#AudioPath#set","Spine.SkeletonData#Fps#get","Spine.SkeletonData#Fps#set","Spine.SkeletonData#init","Spine.SkeletonData#FindBone","Spine.SkeletonData#FindSlot","Spine.SkeletonData#FindSkin","Spine.SkeletonData#FindEvent","Spine.SkeletonData#FindAnimation","Spine.SkeletonData#FindIkConstraint","Spine.SkeletonData#FindTransformConstraint","Spine.SkeletonData#FindPathConstraint","Spine.SkeletonData#toString","Spine.SkeletonLoader.LinkedMesh#ctor","Spine.Skin#Name#get","Spine.Skin#Attachments#get","Spine.Skin#Bones#get","Spine.Skin#Constraints#get","Spine.Skin#init","Spine.Skin#ctor","Spine.Skin#SetAttachment","Spine.Skin#AddSkin","Spine.Skin#CopySkin","Spine.Skin#GetAttachment","Spine.Skin#RemoveAttachment","Spine.Skin#GetAttachments","Spine.Skin#Clear","Spine.Skin#toString","Spine.Skin#AttachAll","Spine.Skin.SkinEntry#getDefaultValue","Spine.Skin.SkinEntry#SlotIndex#get","Spine.Skin.SkinEntry#Name#get","Spine.Skin.SkinEntry#Attachment#get","Spine.Skin.SkinEntry#$ctor1","Spine.Skin.SkinEntry#ctor","Spine.Skin.SkinEntry#getHashCode","Spine.Skin.SkinEntry#equals","Spine.Skin.SkinEntry#$clone","Spine.Skin.SkinKey#getDefaultValue","Spine.Skin.SkinKey#$ctor1","Spine.Skin.SkinKey#ctor","Spine.Skin.SkinKey#getHashCode","Spine.Skin.SkinKey#equals","Spine.Skin.SkinKey#$clone","Spine.Slot#Data#get","Spine.Slot#Bone#get","Spine.Slot#Skeleton#get","Spine.Slot#R#get","Spine.Slot#R#set","Spine.Slot#G#get","Spine.Slot#G#set","Spine.Slot#B#get","Spine.Slot#B#set","Spine.Slot#A#get","Spine.Slot#A#set","Spine.Slot#R2#get","Spine.Slot#R2#set","Spine.Slot#G2#get","Spine.Slot#G2#set","Spine.Slot#B2#get","Spine.Slot#B2#set","Spine.Slot#HasSecondColor#get","Spine.Slot#HasSecondColor#set","Spine.Slot#Attachment#get","Spine.Slot#Attachment#set","Spine.Slot#SequenceIndex#get","Spine.Slot#SequenceIndex#set","Spine.Slot#Deform#get","Spine.Slot#Deform#set","Spine.Slot#init","Spine.Slot#$ctor1","Spine.Slot#ctor","Spine.Slot#ClampColor","Spine.Slot#ClampSecondColor","Spine.Slot#SetToSetupPose","Spine.Slot#toString","Spine.SlotData#Index#get","Spine.SlotData#Name#get","Spine.SlotData#BoneData#get","Spine.SlotData#R#get","Spine.SlotData#R#set","Spine.SlotData#G#get","Spine.SlotData#G#set","Spine.SlotData#B#get","Spine.SlotData#B#set","Spine.SlotData#A#get","Spine.SlotData#A#set","Spine.SlotData#R2#get","Spine.SlotData#R2#set","Spine.SlotData#G2#get","Spine.SlotData#G2#set","Spine.SlotData#B2#get","Spine.SlotData#B2#set","Spine.SlotData#HasSecondColor#get","Spine.SlotData#HasSecondColor#set","Spine.SlotData#AttachmentName#get","Spine.SlotData#AttachmentName#set","Spine.SlotData#BlendMode#get","Spine.SlotData#BlendMode#set","Spine.SlotData#init","Spine.SlotData#ctor","Spine.SlotData#toString","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Triangulator#IsConcave","Spine.Triangulator#PositiveArea","Spine.Triangulator#Winding","Spine.Triangulator#init","Spine.Triangulator#Triangulate","Spine.Triangulator#Decompose","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline","Spine.Unity.AtlasAssetBase#TextureLoadingMode#get","Spine.Unity.AtlasAssetBase#TextureLoadingMode#set","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set","Spine.Unity.AtlasAssetBase#init","Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading","Spine.Unity.AtlasAssetBase#EndCustomTextureLoading","Spine.Unity.AtlasAssetBase#RequireTexturesLoaded","Spine.Unity.AtlasAssetBase#RequireTextureLoaded","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.FollowLocationRigidbody#Awake","Spine.Unity.FollowLocationRigidbody#FixedUpdate","Spine.Unity.FollowLocationRigidbody2D#Awake","Spine.Unity.FollowLocationRigidbody2D#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#init","Spine.Unity.FollowSkeletonUtilityRootRotation#Start","Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation","Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MathUtilities#InverseLerp","Spine.Unity.MathUtilities#InverseLerp$1","Spine.Unity.MathUtilities#InverseLerp$2","Spine.Unity.MathUtilities#InverseLerp$3","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.OnDemandTextureLoader#addTextureRequested","Spine.Unity.OnDemandTextureLoader#removeTextureRequested","Spine.Unity.OnDemandTextureLoader#addTextureLoaded","Spine.Unity.OnDemandTextureLoader#removeTextureLoaded","Spine.Unity.OnDemandTextureLoader#addTextureUnloaded","Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded","Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned","Spine.Unity.OnDemandTextureLoader#OnTextureRequested","Spine.Unity.OnDemandTextureLoader#OnTextureLoaded","Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set","Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex","Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#OnDestroy","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonSubmeshGraphic#OnDisable","Spine.Unity.SkeletonSubmeshGraphic#OnEnable","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineAnimation#init","Spine.Unity.WaitForSpineAnimation#ctor","Spine.Unity.WaitForSpineAnimation#NowWaitFor","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineAnimation#SafeSubscribe","Spine.Unity.WaitForSpineAnimation#HandleComplete","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineTrackEntryEnd#init","Spine.Unity.WaitForSpineTrackEntryEnd#ctor","Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd","Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe","Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset","UICLose#TriggerCTA","UICLose#OnShowed","UICWin#TriggerCTA","UICWin#OnShowed","ViewportHandler#Width#get","ViewportHandler#Height#get","ViewportHandler#BottomLeft#get","ViewportHandler#BottomCenter#get","ViewportHandler#BottomRight#get","ViewportHandler#MiddleLeft#get","ViewportHandler#MiddleCenter#get","ViewportHandler#MiddleRight#get","ViewportHandler#TopLeft#get","ViewportHandler#TopCenter#get","ViewportHandler#TopRight#get","ViewportHandler#init","ViewportHandler#Awake","ViewportHandler#ComputeResolution","ViewportHandler#Update","ViewportHandler#OnDrawGizmos","CameraFollower#inherits","CameraFollower#Awake","CameraFollower#OnLose","LevelManager#inherits","LevelManager#IsEndGame#get","LevelManager#IsEndCard#get","LevelManager#CurrentLevel#get","LevelManager#init","LevelManager#Start","LevelManager#CreateLevel","LevelManager#OnWin","LevelManager#DelayShowWin","LevelManager#OnLose","LevelManager#DelayReplay","LevelManager#DelayLose","SoundManager#inherits","SoundManager#InLava#get","SoundManager#InLava#set","SoundManager#init","SoundManager#PlaySound","SoundManager#GetAvailableAudioSource","SoundManager#StopAll","SoundManager#SoundInLava","Spine.CurveTimeline#init","Spine.CurveTimeline#ctor","Spine.CurveTimeline#SetLinear","Spine.CurveTimeline#SetStepped","Spine.CurveTimeline#GetCurveType","Spine.CurveTimeline#Shrink","Spine.CurveTimeline#SetBezier","Spine.CurveTimeline#GetBezierValue","Spine.AnimationStateData.AnimationPairComparer#init","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2","Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2","Spine.AtlasRegion#packedWidth#get","Spine.AtlasRegion#packedWidth#set","Spine.AtlasRegion#packedHeight#get","Spine.AtlasRegion#packedHeight#set","Spine.AtlasRegion#OriginalWidth#get","Spine.AtlasRegion#OriginalHeight#get","Spine.AtlasRegion#Clone","Spine.AtlasAttachmentLoader#ctor","Spine.AtlasAttachmentLoader#LoadSequence","Spine.AtlasAttachmentLoader#NewRegionAttachment","Spine.AtlasAttachmentLoader#NewMeshAttachment","Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment","Spine.AtlasAttachmentLoader#NewPathAttachment","Spine.AtlasAttachmentLoader#NewPointAttachment","Spine.AtlasAttachmentLoader#NewClippingAttachment","Spine.AtlasAttachmentLoader#FindRegion","Spine.AttachmentTimeline#SlotIndex#get","Spine.AttachmentTimeline#AttachmentNames#get","Spine.AttachmentTimeline#ctor","Spine.AttachmentTimeline#SetFrame","Spine.AttachmentTimeline#Apply","Spine.AttachmentTimeline#SetAttachment","Spine.Bone#Data#get","Spine.Bone#Skeleton#get","Spine.Bone#Parent#get","Spine.Bone#Children#get","Spine.Bone#Active#get","Spine.Bone#X#get","Spine.Bone#X#set","Spine.Bone#Y#get","Spine.Bone#Y#set","Spine.Bone#Rotation#get","Spine.Bone#Rotation#set","Spine.Bone#ScaleX#get","Spine.Bone#ScaleX#set","Spine.Bone#ScaleY#get","Spine.Bone#ScaleY#set","Spine.Bone#ShearX#get","Spine.Bone#ShearX#set","Spine.Bone#ShearY#get","Spine.Bone#ShearY#set","Spine.Bone#AppliedRotation#get","Spine.Bone#AppliedRotation#set","Spine.Bone#AX#get","Spine.Bone#AX#set","Spine.Bone#AY#get","Spine.Bone#AY#set","Spine.Bone#AScaleX#get","Spine.Bone#AScaleX#set","Spine.Bone#AScaleY#get","Spine.Bone#AScaleY#set","Spine.Bone#AShearX#get","Spine.Bone#AShearX#set","Spine.Bone#AShearY#get","Spine.Bone#AShearY#set","Spine.Bone#A#get","Spine.Bone#A#set","Spine.Bone#B#get","Spine.Bone#B#set","Spine.Bone#C#get","Spine.Bone#C#set","Spine.Bone#D#get","Spine.Bone#D#set","Spine.Bone#WorldX#get","Spine.Bone#WorldX#set","Spine.Bone#WorldY#get","Spine.Bone#WorldY#set","Spine.Bone#WorldRotationX#get","Spine.Bone#WorldRotationY#get","Spine.Bone#WorldScaleX#get","Spine.Bone#WorldScaleY#get","Spine.Bone#WorldToLocalRotationX#get","Spine.Bone#WorldToLocalRotationY#get","Spine.Bone#init","Spine.Bone#$ctor1","Spine.Bone#ctor","Spine.Bone#Update","Spine.Bone#UpdateWorldTransform","Spine.Bone#UpdateWorldTransform$1","Spine.Bone#SetToSetupPose","Spine.Bone#UpdateAppliedTransform","Spine.Bone#WorldToLocal","Spine.Bone#LocalToWorld","Spine.Bone#WorldToLocalRotation","Spine.Bone#LocalToWorldRotation","Spine.Bone#RotateWorld","Spine.Bone#toString","Spine.VertexAttachment#init","Spine.VertexAttachment#Id#get","Spine.VertexAttachment#Bones#get","Spine.VertexAttachment#Bones#set","Spine.VertexAttachment#Vertices#get","Spine.VertexAttachment#Vertices#set","Spine.VertexAttachment#WorldVerticesLength#get","Spine.VertexAttachment#WorldVerticesLength#set","Spine.VertexAttachment#TimelineAttachment#get","Spine.VertexAttachment#TimelineAttachment#set","Spine.VertexAttachment#$ctor1","Spine.VertexAttachment#ctor","Spine.VertexAttachment#ComputeWorldVertices$1","Spine.VertexAttachment#ComputeWorldVertices","Spine.DrawOrderTimeline#init","Spine.DrawOrderTimeline#DrawOrders#get","Spine.DrawOrderTimeline#ctor","Spine.DrawOrderTimeline#SetFrame","Spine.DrawOrderTimeline#Apply","Spine.EventTimeline#init","Spine.EventTimeline#Events#get","Spine.EventTimeline#ctor","Spine.EventTimeline#SetFrame","Spine.EventTimeline#Apply","Spine.IkConstraint#Apply$1","Spine.IkConstraint#Apply","Spine.IkConstraint#Bones#get","Spine.IkConstraint#Target#get","Spine.IkConstraint#Target#set","Spine.IkConstraint#Mix#get","Spine.IkConstraint#Mix#set","Spine.IkConstraint#Softness#get","Spine.IkConstraint#Softness#set","Spine.IkConstraint#BendDirection#get","Spine.IkConstraint#BendDirection#set","Spine.IkConstraint#Compress#get","Spine.IkConstraint#Compress#set","Spine.IkConstraint#Stretch#get","Spine.IkConstraint#Stretch#set","Spine.IkConstraint#Active#get","Spine.IkConstraint#Data#get","Spine.IkConstraint#init","Spine.IkConstraint#$ctor1","Spine.IkConstraint#ctor","Spine.IkConstraint#Update","Spine.IkConstraint#toString","Spine.IkConstraintData#Bones#get","Spine.IkConstraintData#Target#get","Spine.IkConstraintData#Target#set","Spine.IkConstraintData#Mix#get","Spine.IkConstraintData#Mix#set","Spine.IkConstraintData#Softness#get","Spine.IkConstraintData#Softness#set","Spine.IkConstraintData#BendDirection#get","Spine.IkConstraintData#BendDirection#set","Spine.IkConstraintData#Compress#get","Spine.IkConstraintData#Compress#set","Spine.IkConstraintData#Stretch#get","Spine.IkConstraintData#Stretch#set","Spine.IkConstraintData#Uniform#get","Spine.IkConstraintData#Uniform#set","Spine.IkConstraintData#init","Spine.IkConstraintData#ctor","Spine.PathConstraint#init","Spine.PathConstraint#ArraysFill","Spine.PathConstraint#AddBeforePosition","Spine.PathConstraint#AddAfterPosition","Spine.PathConstraint#AddCurvePosition","Spine.PathConstraint#Position#get","Spine.PathConstraint#Position#set","Spine.PathConstraint#Spacing#get","Spine.PathConstraint#Spacing#set","Spine.PathConstraint#MixRotate#get","Spine.PathConstraint#MixRotate#set","Spine.PathConstraint#MixX#get","Spine.PathConstraint#MixX#set","Spine.PathConstraint#MixY#get","Spine.PathConstraint#MixY#set","Spine.PathConstraint#Bones#get","Spine.PathConstraint#Target#get","Spine.PathConstraint#Target#set","Spine.PathConstraint#Active#get","Spine.PathConstraint#Data#get","Spine.PathConstraint#init","Spine.PathConstraint#$ctor1","Spine.PathConstraint#ctor","Spine.PathConstraint#Update","Spine.PathConstraint#ComputeWorldPositions","Spine.PathConstraint#toString","Spine.PathConstraintData#Bones#get","Spine.PathConstraintData#Target#get","Spine.PathConstraintData#Target#set","Spine.PathConstraintData#PositionMode#get","Spine.PathConstraintData#PositionMode#set","Spine.PathConstraintData#SpacingMode#get","Spine.PathConstraintData#SpacingMode#set","Spine.PathConstraintData#RotateMode#get","Spine.PathConstraintData#RotateMode#set","Spine.PathConstraintData#OffsetRotation#get","Spine.PathConstraintData#OffsetRotation#set","Spine.PathConstraintData#Position#get","Spine.PathConstraintData#Position#set","Spine.PathConstraintData#Spacing#get","Spine.PathConstraintData#Spacing#set","Spine.PathConstraintData#RotateMix#get","Spine.PathConstraintData#RotateMix#set","Spine.PathConstraintData#MixX#get","Spine.PathConstraintData#MixX#set","Spine.PathConstraintData#MixY#get","Spine.PathConstraintData#MixY#set","Spine.PathConstraintData#init","Spine.PathConstraintData#ctor","Spine.PointAttachment#X#get","Spine.PointAttachment#X#set","Spine.PointAttachment#Y#get","Spine.PointAttachment#Y#set","Spine.PointAttachment#Rotation#get","Spine.PointAttachment#Rotation#set","Spine.PointAttachment#$ctor1","Spine.PointAttachment#ctor","Spine.PointAttachment#ComputeWorldPosition","Spine.PointAttachment#ComputeWorldRotation","Spine.PointAttachment#Copy","Spine.Pow#ctor","Spine.Pow#Apply$1","Spine.RegionAttachment#init","Spine.RegionAttachment#X#get","Spine.RegionAttachment#X#set","Spine.RegionAttachment#Y#get","Spine.RegionAttachment#Y#set","Spine.RegionAttachment#Rotation#get","Spine.RegionAttachment#Rotation#set","Spine.RegionAttachment#ScaleX#get","Spine.RegionAttachment#ScaleX#set","Spine.RegionAttachment#ScaleY#get","Spine.RegionAttachment#ScaleY#set","Spine.RegionAttachment#Width#get","Spine.RegionAttachment#Width#set","Spine.RegionAttachment#Height#get","Spine.RegionAttachment#Height#set","Spine.RegionAttachment#R#get","Spine.RegionAttachment#R#set","Spine.RegionAttachment#G#get","Spine.RegionAttachment#G#set","Spine.RegionAttachment#B#get","Spine.RegionAttachment#B#set","Spine.RegionAttachment#A#get","Spine.RegionAttachment#A#set","Spine.RegionAttachment#Region#get","Spine.RegionAttachment#Region#set","Spine.RegionAttachment#Offset#get","Spine.RegionAttachment#UVs#get","Spine.RegionAttachment#Sequence#get","Spine.RegionAttachment#Sequence#set","Spine.RegionAttachment#init","Spine.RegionAttachment#$ctor1","Spine.RegionAttachment#ctor","Spine.RegionAttachment#UpdateRegion","Spine.RegionAttachment#ComputeWorldVertices","Spine.RegionAttachment#Copy","Spine.SequenceTimeline#init","Spine.SequenceTimeline#FrameEntries#get","Spine.SequenceTimeline#SlotIndex#get","Spine.SequenceTimeline#Attachment#get","Spine.SequenceTimeline#ctor","Spine.SequenceTimeline#SetFrame","Spine.SequenceTimeline#Apply","Spine.SkeletonBinary#init","Spine.SkeletonBinary#GetVersionString","Spine.SkeletonBinary#$ctor1","Spine.SkeletonBinary#ctor","Spine.SkeletonBinary#ReadSkeletonData","Spine.SkeletonBinary#ReadSkeletonData$1","Spine.SkeletonBinary#ReadSkin","Spine.SkeletonBinary#ReadAttachment","Spine.SkeletonBinary#ReadSequence","Spine.SkeletonBinary#ReadVertices","Spine.SkeletonBinary#ReadFloatArray","Spine.SkeletonBinary#ReadShortArray","Spine.SkeletonBinary#ReadAnimation","Spine.SkeletonBinary#ReadTimeline","Spine.SkeletonBinary#ReadTimeline$1","Spine.SkeletonBinary#SetBezier","Spine.SkeletonJson#ReadSequence","Spine.SkeletonJson#ReadTimeline","Spine.SkeletonJson#ReadTimeline$1","Spine.SkeletonJson#ReadCurve","Spine.SkeletonJson#SetBezier","Spine.SkeletonJson#GetFloatArray","Spine.SkeletonJson#GetIntArray","Spine.SkeletonJson#GetFloat","Spine.SkeletonJson#GetInt$1","Spine.SkeletonJson#GetInt","Spine.SkeletonJson#GetBoolean","Spine.SkeletonJson#GetString","Spine.SkeletonJson#ToColor","Spine.SkeletonJson#$ctor1","Spine.SkeletonJson#ctor","Spine.SkeletonJson#ReadSkeletonData","Spine.SkeletonJson#ReadSkeletonData$1","Spine.SkeletonJson#ReadAttachment","Spine.SkeletonJson#ReadVertices","Spine.SkeletonJson#FindSlotIndex","Spine.SkeletonJson#ReadAnimation","Spine.Skin.SkinKeyComparer#init","Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2","Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2","Spine.TrackEntry#inherits","Spine.TrackEntry#TrackIndex#get","Spine.TrackEntry#Animation#get","Spine.TrackEntry#Loop#get","Spine.TrackEntry#Loop#set","Spine.TrackEntry#Delay#get","Spine.TrackEntry#Delay#set","Spine.TrackEntry#TrackTime#get","Spine.TrackEntry#TrackTime#set","Spine.TrackEntry#TrackEnd#get","Spine.TrackEntry#TrackEnd#set","Spine.TrackEntry#TrackComplete#get","Spine.TrackEntry#AnimationStart#get","Spine.TrackEntry#AnimationStart#set","Spine.TrackEntry#AnimationEnd#get","Spine.TrackEntry#AnimationEnd#set","Spine.TrackEntry#AnimationLast#get","Spine.TrackEntry#AnimationLast#set","Spine.TrackEntry#AnimationTime#get","Spine.TrackEntry#TimeScale#get","Spine.TrackEntry#TimeScale#set","Spine.TrackEntry#Alpha#get","Spine.TrackEntry#Alpha#set","Spine.TrackEntry#InterruptAlpha#get","Spine.TrackEntry#EventThreshold#get","Spine.TrackEntry#EventThreshold#set","Spine.TrackEntry#AttachmentThreshold#get","Spine.TrackEntry#AttachmentThreshold#set","Spine.TrackEntry#DrawOrderThreshold#get","Spine.TrackEntry#DrawOrderThreshold#set","Spine.TrackEntry#Next#get","Spine.TrackEntry#Previous#get","Spine.TrackEntry#IsComplete#get","Spine.TrackEntry#MixTime#get","Spine.TrackEntry#MixTime#set","Spine.TrackEntry#MixDuration#get","Spine.TrackEntry#MixDuration#set","Spine.TrackEntry#MixBlend#get","Spine.TrackEntry#MixBlend#set","Spine.TrackEntry#MixingFrom#get","Spine.TrackEntry#MixingTo#get","Spine.TrackEntry#HoldPrevious#get","Spine.TrackEntry#HoldPrevious#set","Spine.TrackEntry#Reverse#get","Spine.TrackEntry#Reverse#set","Spine.TrackEntry#ShortestRotation#get","Spine.TrackEntry#ShortestRotation#set","Spine.TrackEntry#IsEmptyAnimation#get","Spine.TrackEntry#init","Spine.TrackEntry#OnStart","Spine.TrackEntry#OnInterrupt","Spine.TrackEntry#OnEnd","Spine.TrackEntry#OnDispose","Spine.TrackEntry#OnComplete","Spine.TrackEntry#OnEvent","Spine.TrackEntry#Reset","Spine.TrackEntry#ResetRotationDirections","Spine.TrackEntry#toString","Spine.TrackEntry#AllowImmediateQueue","Spine.TransformConstraint#Bones#get","Spine.TransformConstraint#Target#get","Spine.TransformConstraint#Target#set","Spine.TransformConstraint#MixRotate#get","Spine.TransformConstraint#MixRotate#set","Spine.TransformConstraint#MixX#get","Spine.TransformConstraint#MixX#set","Spine.TransformConstraint#MixY#get","Spine.TransformConstraint#MixY#set","Spine.TransformConstraint#MixScaleX#get","Spine.TransformConstraint#MixScaleX#set","Spine.TransformConstraint#MixScaleY#get","Spine.TransformConstraint#MixScaleY#set","Spine.TransformConstraint#MixShearY#get","Spine.TransformConstraint#MixShearY#set","Spine.TransformConstraint#Active#get","Spine.TransformConstraint#Data#get","Spine.TransformConstraint#$ctor1","Spine.TransformConstraint#ctor","Spine.TransformConstraint#Update","Spine.TransformConstraint#ApplyAbsoluteWorld","Spine.TransformConstraint#ApplyRelativeWorld","Spine.TransformConstraint#ApplyAbsoluteLocal","Spine.TransformConstraint#ApplyRelativeLocal","Spine.TransformConstraint#toString","Spine.TransformConstraintData#Bones#get","Spine.TransformConstraintData#Target#get","Spine.TransformConstraintData#Target#set","Spine.TransformConstraintData#MixRotate#get","Spine.TransformConstraintData#MixRotate#set","Spine.TransformConstraintData#MixX#get","Spine.TransformConstraintData#MixX#set","Spine.TransformConstraintData#MixY#get","Spine.TransformConstraintData#MixY#set","Spine.TransformConstraintData#MixScaleX#get","Spine.TransformConstraintData#MixScaleX#set","Spine.TransformConstraintData#MixScaleY#get","Spine.TransformConstraintData#MixScaleY#set","Spine.TransformConstraintData#MixShearY#get","Spine.TransformConstraintData#MixShearY#set","Spine.TransformConstraintData#OffsetRotation#get","Spine.TransformConstraintData#OffsetRotation#set","Spine.TransformConstraintData#OffsetX#get","Spine.TransformConstraintData#OffsetX#set","Spine.TransformConstraintData#OffsetY#get","Spine.TransformConstraintData#OffsetY#set","Spine.TransformConstraintData#OffsetScaleX#get","Spine.TransformConstraintData#OffsetScaleX#set","Spine.TransformConstraintData#OffsetScaleY#get","Spine.TransformConstraintData#OffsetScaleY#set","Spine.TransformConstraintData#OffsetShearY#get","Spine.TransformConstraintData#OffsetShearY#set","Spine.TransformConstraintData#Relative#get","Spine.TransformConstraintData#Relative#set","Spine.TransformConstraintData#Local#get","Spine.TransformConstraintData#Local#set","Spine.TransformConstraintData#init","Spine.TransformConstraintData#ctor","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SkeletonRootMotion#GetMixAlpha","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","Spine.Unity.WaitForSpineAnimationComplete#ctor","Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1","Spine.Unity.WaitForSpineAnimationEnd#ctor","Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1","UIManager#inherits","UIManager#TriggerCTA","UIManager#ShowGamePlay","UIManager#ShowLose","UIManager#ShowWin","UIManager#TakePhoto","Spine.CurveTimeline1#init","Spine.CurveTimeline1#FrameEntries#get","Spine.CurveTimeline1#ctor","Spine.CurveTimeline1#SetFrame","Spine.CurveTimeline1#GetCurveValue","Spine.Atlas#ReadEntry","Spine.Atlas#Regions#get","Spine.Atlas#Pages#get","Spine.Atlas#init","Spine.Atlas#ctor","Spine.Atlas#$ctor1","Spine.Atlas#GetEnumerator","Spine.Atlas#System$Collections$IEnumerable$GetEnumerator","Spine.Atlas#FlipV","Spine.Atlas#FindRegion","Spine.Atlas#Dispose","Spine.BoundingBoxAttachment#$ctor1","Spine.BoundingBoxAttachment#ctor","Spine.BoundingBoxAttachment#Copy","Spine.ClippingAttachment#EndSlot#get","Spine.ClippingAttachment#EndSlot#set","Spine.ClippingAttachment#$ctor1","Spine.ClippingAttachment#ctor","Spine.ClippingAttachment#Copy","Spine.CurveTimeline2#init","Spine.CurveTimeline2#FrameEntries#get","Spine.CurveTimeline2#ctor","Spine.CurveTimeline2#SetFrame","Spine.DeformTimeline#SlotIndex#get","Spine.DeformTimeline#Attachment#get","Spine.DeformTimeline#Vertices#get","Spine.DeformTimeline#ctor","Spine.DeformTimeline#SetFrame","Spine.DeformTimeline#setBezier","Spine.DeformTimeline#GetCurvePercent","Spine.DeformTimeline#Apply","Spine.IkConstraintTimeline#init","Spine.IkConstraintTimeline#FrameEntries#get","Spine.IkConstraintTimeline#IkConstraintIndex#get","Spine.IkConstraintTimeline#ctor","Spine.IkConstraintTimeline#SetFrame","Spine.IkConstraintTimeline#Apply","Spine.MeshAttachment#Region#get","Spine.MeshAttachment#Region#set","Spine.MeshAttachment#HullLength#get","Spine.MeshAttachment#HullLength#set","Spine.MeshAttachment#RegionUVs#get","Spine.MeshAttachment#RegionUVs#set","Spine.MeshAttachment#UVs#get","Spine.MeshAttachment#UVs#set","Spine.MeshAttachment#Triangles#get","Spine.MeshAttachment#Triangles#set","Spine.MeshAttachment#R#get","Spine.MeshAttachment#R#set","Spine.MeshAttachment#G#get","Spine.MeshAttachment#G#set","Spine.MeshAttachment#B#get","Spine.MeshAttachment#B#set","Spine.MeshAttachment#A#get","Spine.MeshAttachment#A#set","Spine.MeshAttachment#Path#get","Spine.MeshAttachment#Path#set","Spine.MeshAttachment#Sequence#get","Spine.MeshAttachment#Sequence#set","Spine.MeshAttachment#ParentMesh#get","Spine.MeshAttachment#ParentMesh#set","Spine.MeshAttachment#init","Spine.MeshAttachment#$ctor1","Spine.MeshAttachment#ctor","Spine.MeshAttachment#UpdateRegion","Spine.MeshAttachment#ComputeWorldVertices","Spine.MeshAttachment#NewLinkedMesh","Spine.MeshAttachment#Copy","Spine.PathAttachment#Lengths#get","Spine.PathAttachment#Lengths#set","Spine.PathAttachment#Closed#get","Spine.PathAttachment#Closed#set","Spine.PathAttachment#ConstantSpeed#get","Spine.PathAttachment#ConstantSpeed#set","Spine.PathAttachment#$ctor1","Spine.PathAttachment#ctor","Spine.PathAttachment#Copy","Spine.PathConstraintMixTimeline#init","Spine.PathConstraintMixTimeline#FrameEntries#get","Spine.PathConstraintMixTimeline#PathConstraintIndex#get","Spine.PathConstraintMixTimeline#ctor","Spine.PathConstraintMixTimeline#SetFrame","Spine.PathConstraintMixTimeline#Apply","Spine.PowOut#ctor","Spine.PowOut#Apply$1","Spine.RGB2Timeline#init","Spine.RGB2Timeline#FrameEntries#get","Spine.RGB2Timeline#SlotIndex#get","Spine.RGB2Timeline#ctor","Spine.RGB2Timeline#SetFrame","Spine.RGB2Timeline#Apply","Spine.RGBA2Timeline#init","Spine.RGBA2Timeline#FrameEntries#get","Spine.RGBA2Timeline#SlotIndex#get","Spine.RGBA2Timeline#ctor","Spine.RGBA2Timeline#SetFrame","Spine.RGBA2Timeline#Apply","Spine.RGBATimeline#init","Spine.RGBATimeline#FrameEntries#get","Spine.RGBATimeline#SlotIndex#get","Spine.RGBATimeline#ctor","Spine.RGBATimeline#SetFrame","Spine.RGBATimeline#Apply","Spine.RGBTimeline#init","Spine.RGBTimeline#FrameEntries#get","Spine.RGBTimeline#SlotIndex#get","Spine.RGBTimeline#ctor","Spine.RGBTimeline#SetFrame","Spine.RGBTimeline#Apply","Spine.TransformConstraintTimeline#init","Spine.TransformConstraintTimeline#FrameEntries#get","Spine.TransformConstraintTimeline#TransformConstraintIndex#get","Spine.TransformConstraintTimeline#ctor","Spine.TransformConstraintTimeline#SetFrame","Spine.TransformConstraintTimeline#Apply","Spine.TransformConstraintTimeline#GetCurveValue","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#HandleOnDemandLoading","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SetRectTransformSize$1","Spine.Unity.SkeletonGraphic#SetRectTransformSize","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#MeshScale#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#UpdateTiming#get","Spine.Unity.SkeletonGraphic#UpdateTiming#set","Spine.Unity.SkeletonGraphic#UnscaledTime#get","Spine.Unity.SkeletonGraphic#UnscaledTime#set","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#FixedUpdate","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#AfterAnimationApplied","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#HandleOnDemandLoading","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonGraphic#GetLayoutScale","Spine.Unity.SkeletonGraphic#GetCurrentRectSize","Spine.AlphaTimeline#SlotIndex#get","Spine.AlphaTimeline#ctor","Spine.AlphaTimeline#Apply","Spine.PathConstraintPositionTimeline#PathConstraintIndex#get","Spine.PathConstraintPositionTimeline#ctor","Spine.PathConstraintPositionTimeline#Apply","Spine.PathConstraintSpacingTimeline#PathConstraintIndex#get","Spine.PathConstraintSpacingTimeline#ctor","Spine.PathConstraintSpacingTimeline#Apply","Spine.RotateTimeline#BoneIndex#get","Spine.RotateTimeline#ctor","Spine.RotateTimeline#Apply","Spine.ScaleTimeline#BoneIndex#get","Spine.ScaleTimeline#ctor","Spine.ScaleTimeline#Apply","Spine.ScaleXTimeline#BoneIndex#get","Spine.ScaleXTimeline#ctor","Spine.ScaleXTimeline#Apply","Spine.ScaleYTimeline#BoneIndex#get","Spine.ScaleYTimeline#ctor","Spine.ScaleYTimeline#Apply","Spine.ShearTimeline#BoneIndex#get","Spine.ShearTimeline#ctor","Spine.ShearTimeline#Apply","Spine.ShearXTimeline#BoneIndex#get","Spine.ShearXTimeline#ctor","Spine.ShearXTimeline#Apply","Spine.ShearYTimeline#BoneIndex#get","Spine.ShearYTimeline#ctor","Spine.ShearYTimeline#Apply","Spine.TranslateTimeline#BoneIndex#get","Spine.TranslateTimeline#ctor","Spine.TranslateTimeline#Apply","Spine.TranslateTimeline#GetCurveValue","Spine.TranslateXTimeline#BoneIndex#get","Spine.TranslateXTimeline#ctor","Spine.TranslateXTimeline#Apply","Spine.TranslateYTimeline#BoneIndex#get","Spine.TranslateYTimeline#ctor","Spine.TranslateYTimeline#Apply","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#UpdateTiming#get","Spine.Unity.SkeletonAnimation#UpdateTiming#set","Spine.Unity.SkeletonAnimation#UnscaledTime#get","Spine.Unity.SkeletonAnimation#UnscaledTime#set","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addOnAnimationRebuild","Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#FixedUpdate","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#AfterAnimationApplied","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#UpdateTiming#get","Spine.Unity.SkeletonMecanim#UpdateTiming#set","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addOnAnimationRebuild","Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#Update$1","Spine.Unity.SkeletonMecanim#FixedUpdate","Spine.Unity.SkeletonMecanim#UpdateAnimation","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible"]' ) ); }
/**
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*Anim start.*/
    Bridge.define("Anim", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            tracks: null,
            anim: null
        },
        methods: {
            /*Anim.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Anim#Awake", this ); }

                this.anim = this.GetComponent(Spine.Unity.SkeletonAnimation);
            },
            /*Anim.Awake end.*/

            /*Anim.SetAnim start.*/
            SetAnim: function (name, loop) {
if ( TRACE ) { TRACE( "Anim#SetAnim", this ); }

                this.anim.AnimationState.ClearTracks();
                var index = this.tracks.indexOf(name);
                this.anim.AnimationState.SetAnimation$1(index, name, loop);
            },
            /*Anim.SetAnim end.*/


        }
    });
    /*Anim end.*/

    /*CameraAnchor start.*/
    Bridge.define("CameraAnchor", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anchorType: 0,
            anchorOffset: null,
            updateAnchorRoutine: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CameraAnchor#init", this ); }

                this.anchorOffset = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*CameraAnchor.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "CameraAnchor#Start", this ); }

                this.updateAnchorRoutine = this.UpdateAnchorAsync();
                this.StartCoroutine$1(this.updateAnchorRoutine);
            },
            /*CameraAnchor.Start end.*/

            /*CameraAnchor.UpdateAnchorAsync start.*/
            UpdateAnchorAsync: function () {
if ( TRACE ) { TRACE( "CameraAnchor#UpdateAnchorAsync", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    cameraWaitCycles,
                    num,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    cameraWaitCycles = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( UnityEngine.MonoBehaviour.op_Equality(ViewportHandler.Instance, null) ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    num = (cameraWaitCycles + 1) >>> 0;
                                        cameraWaitCycles = num;
                                        $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    if (cameraWaitCycles !== 0) {
                                            UnityEngine.MonoBehaviour.print(System.String.format("CameraAnchor found ViewportHandler instance after waiting {0} frame(s). You might want to check that ViewportHandler has an earlie execution order.", [Bridge.box(cameraWaitCycles, System.UInt32)]));
                                        }
                                        this.UpdateAnchor();
                                        this.updateAnchorRoutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CameraAnchor.UpdateAnchorAsync end.*/

            /*CameraAnchor.UpdateAnchor start.*/
            UpdateAnchor: function () {
if ( TRACE ) { TRACE( "CameraAnchor#UpdateAnchor", this ); }

                switch (this.anchorType) {
                    case CameraAnchor.AnchorType.BottomLeft: 
                        this.SetAnchor(ViewportHandler.Instance.BottomLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.BottomCenter: 
                        this.SetAnchor(ViewportHandler.Instance.BottomCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.BottomRight: 
                        this.SetAnchor(ViewportHandler.Instance.BottomRight.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleLeft: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleCenter: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.MiddleRight: 
                        this.SetAnchor(ViewportHandler.Instance.MiddleRight.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopLeft: 
                        this.SetAnchor(ViewportHandler.Instance.TopLeft.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopCenter: 
                        this.SetAnchor(ViewportHandler.Instance.TopCenter.$clone());
                        break;
                    case CameraAnchor.AnchorType.TopRight: 
                        this.SetAnchor(ViewportHandler.Instance.TopRight.$clone());
                        break;
                }
            },
            /*CameraAnchor.UpdateAnchor end.*/

            /*CameraAnchor.SetAnchor start.*/
            SetAnchor: function (anchor) {
if ( TRACE ) { TRACE( "CameraAnchor#SetAnchor", this ); }

                var newPos = anchor.$clone().add( this.anchorOffset );
                if (!this.transform.position.strictEquals( newPos.$clone() )) {
                    this.transform.position = newPos.$clone();
                }
            },
            /*CameraAnchor.SetAnchor end.*/


        }
    });
    /*CameraAnchor end.*/

    /*CameraAnchor+AnchorType start.*/
    Bridge.define("CameraAnchor.AnchorType", {
        $kind: 1006,
        statics: {
            fields: {
                BottomLeft: 0,
                BottomCenter: 1,
                BottomRight: 2,
                MiddleLeft: 3,
                MiddleCenter: 4,
                MiddleRight: 5,
                TopLeft: 6,
                TopCenter: 7,
                TopRight: 8
            }
        }
    });
    /*CameraAnchor+AnchorType end.*/

    /*CameraElement start.*/
    Bridge.define("CameraElement", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            renderer: null,
            vfxSteam: null,
            vfxBlink: null,
            winPosition: null,
            onWin: false
        },
        props: {
            WinPosition: {
                get: function () {
if ( TRACE ) { TRACE( "CameraElement#WinPosition#get", this ); }

                    return this.winPosition.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "CameraElement#WinPosition#set", this ); }

                    this.winPosition = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CameraElement#init", this ); }

                this.winPosition = new UnityEngine.Vector2();
                this.onWin = false;
            }
        },
        methods: {
            /*CameraElement.OnTriggerEnter2D start.*/
            OnTriggerEnter2D: function (other) {
if ( TRACE ) { TRACE( "CameraElement#OnTriggerEnter2D", this ); }

                if (other.gameObject.CompareTag("Ring") && !this.onWin) {
                    this.OnWin();
                    this.onWin = true;
                }
                if (other.gameObject.CompareTag("DeathZone") && !this.onWin) {
                    UnityEngine.Debug.Log$1("Lose");
                    Singleton$1(LevelManager).Ins.OnLose();
                    this.onWin = true;
                }
                if (other.gameObject.CompareTag("Lava") && this.renderer.enabled) {
                    this.renderer.enabled = false;
                    this.vfxBlink.gameObject.SetActive(false);
                    this.vfxSteam.Play();
                    Singleton$1(SoundManager).Ins.PlaySound("InLava", false);
                    this.StartCoroutine$1(this.DelayDestroy(false));
                }
            },
            /*CameraElement.OnTriggerEnter2D end.*/

            /*CameraElement.DelayDestroy start.*/
            DelayDestroy: function (win) {
if ( TRACE ) { TRACE( "CameraElement#DelayDestroy", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (win) {
                                            Singleton$1(LevelManager).Ins.OnWin();
                                        } else {
                                            Singleton$1(LevelManager).Ins.OnLose();
                                        }
                                        Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.SetActive(false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CameraElement.DelayDestroy end.*/

            /*CameraElement.OnWin start.*/
            OnWin: function () {
if ( TRACE ) { TRACE( "CameraElement#OnWin", this ); }

                var time = 1.0;
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DORotate(this.transform, new pc.Vec3( 0.0, 0.0, 360.0 ), time, DG.Tweening.RotateMode.WorldAxisAdd), DG.Tweening.Ease.Linear);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, UnityEngine.Vector3.FromVector2(this.winPosition.$clone()), time), DG.Tweening.Ease.Linear);
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, new pc.Vec3( 0.1, 0.1, 0.1 ), time), DG.Tweening.Ease.Linear);
                this.StartCoroutine$1(this.DelayDestroy(true));
            },
            /*CameraElement.OnWin end.*/


        }
    });
    /*CameraElement end.*/

    /*Singleton$1 start.*/
    Bridge.define("Singleton$1", function (T) { return {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                m_Ins: Bridge.getDefaultValue(T)
            },
            props: {
                Ins: {
                    get: function () {
if ( TRACE ) { TRACE( "Singleton$1#Ins#get", this ); }

                        if (Bridge.referenceEquals(Bridge.cast(Bridge.rValue(Singleton$1(T).m_Ins), UnityEngine.Object), null)) {
                            Singleton$1(T).m_Ins = Bridge.rValue(UnityEngine.Object.FindObjectOfType(T));
                            if (Bridge.referenceEquals(Bridge.cast(Bridge.rValue(Singleton$1(T).m_Ins), UnityEngine.Object), null)) {
                                var singletonObject = new UnityEngine.GameObject.ctor();
                                Singleton$1(T).m_Ins = Bridge.rValue(singletonObject.AddComponent(T));
                                singletonObject.name = (Bridge.getTypeName(T) || "") + " (Singleton)";
                            }
                        }
                        return Bridge.rValue(Singleton$1(T).m_Ins);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Singleton$1#init", this ); }

                    this.m_Ins = Bridge.getDefaultValue(T);
                }
            }
        }
    }; });
    /*Singleton$1 end.*/

    /*Cat start.*/
    Bridge.define("Cat", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null
        },
        props: {
            Anim: {
                get: function () {
if ( TRACE ) { TRACE( "Cat#Anim#get", this ); }

                    return this.anim;
                }
            }
        },
        methods: {
            /*Cat.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Cat#Start", this ); }

                this.anim.SetAnim("Idle", true);
            },
            /*Cat.Start end.*/


        }
    });
    /*Cat end.*/

    /*Constant start.*/
    Bridge.define("Constant", {
        statics: {
            fields: {
                tagCoin: null,
                tagBag: null,
                tagRing: null,
                tagLava: null,
                tagWater: null,
                tagRock: null,
                tagDeathZone: null,
                soundBg: null,
                soundClick: null,
                soundInLava: null,
                soundLose: null,
                soundTakePhoto: null,
                soundDragPin: null,
                soundGirlSay: null,
                soundNeedHelp: null,
                soundMainScared: null,
                soundRat: null,
                animTakePhoto: null,
                animScare: null,
                animLose: null,
                animMouseIdle: null,
                animCatIdle: null,
                animCatSad: null,
                animCatHappy: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Constant#init", this ); }

                    this.tagCoin = "Coin";
                    this.tagBag = "Bag";
                    this.tagRing = "Ring";
                    this.tagLava = "Lava";
                    this.tagWater = "Water";
                    this.tagRock = "Rock";
                    this.tagDeathZone = "DeathZone";
                    this.soundBg = "Background";
                    this.soundClick = "Click";
                    this.soundInLava = "InLava";
                    this.soundLose = "Lose";
                    this.soundTakePhoto = "TakePhoto";
                    this.soundDragPin = "DragPin";
                    this.soundGirlSay = "GirlSay";
                    this.soundNeedHelp = "NeedHelp";
                    this.soundMainScared = "MainScared";
                    this.soundRat = "Rat";
                    this.animTakePhoto = "TakePhoto";
                    this.animScare = "BonusAnim/Scared2";
                    this.animLose = "Lose";
                    this.animMouseIdle = "Idle";
                    this.animCatIdle = "Idle";
                    this.animCatSad = "Sad";
                    this.animCatHappy = "Happy";
                }
            }
        }
    });
    /*Constant end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0.0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0.0) {
                        endValue = 0.0;
                    } else if (endValue > 1.0) {
                        endValue = 1.0;
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var value = { };
                        target.GetFloat(floatName, value);
                        return value.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0.0, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0.0, endValue, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0.0, 0.0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = ((!System.Nullable.hasValue(up)) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up).$clone());
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0.0;
                    var offsetY = -1.0;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0.0, jumpPower, 0.0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0.0, 0.0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0.0, 0.0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
                        }
                        var position = target.position.$clone();
                        position.y += DG.Tweening.DOVirtual.EasedValue(0.0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(position);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);
                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);
                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition((UnityEngine.Component.op_Equality(trans.parent, null)) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);
                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition((UnityEngine.Component.op_Equality(trans.parent, null)) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);
                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0.0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0.0;
                    var offsetY = -1.0;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0.0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0.0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
                        }
                        var vector = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        vector.y += DG.Tweening.DOVirtual.EasedValue(0.0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(vector);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);
                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, path, duration), target);
                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1((UnityEngine.Component.op_Equality(trans.parent, null)) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);
                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1((UnityEngine.Component.op_Equality(trans.parent, null)) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);
                    t.plugOptions.isRigidbody2D = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0.0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = ((i === ((len - 1) | 0)) ? (duration - DG.Tweening.TweenExtensions.Duration(s, false)) : (duration * ((i === 0) ? c.time : (c.time - colors[((i - 1) | 0)].time))));
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color.$clone(), new pc.Color( endValue.$clone().r - $t.r, endValue.$clone().g - $t.g, endValue.$clone().b - $t.b, endValue.$clone().a - $t.a ));
                    var to = new pc.Color( 0.0, 0.0, 0.0, 0.0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var color = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + color.$clone().r, $t1.g + color.$clone().g, $t1.b + color.$clone().b, $t1.a + color.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1.0) {
                        endValue = 1.0;
                    } else if (endValue < 0.0) {
                        endValue = 0.0;
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0.0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = ((i === ((len - 1) | 0)) ? (duration - DG.Tweening.TweenExtensions.Duration(s, false)) : (duration * ((i === 0) ? c.time : (c.time - colors[((i - 1) | 0)].time))));
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0.0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0.0, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0.0, endValue, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0.0, 0.0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0.0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0.0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0.0;
                    var offsetY = -1.0;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0.0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0.0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
                        }
                        var anchoredPosition = target.anchoredPosition.$clone();
                        anchoredPosition.y += DG.Tweening.DOVirtual.EasedValue(0.0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = anchoredPosition.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var cInfo = ((!addThousandsSeparator) ? null : (culture || System.Globalization.CultureInfo.invariantCulture));
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return fromValue;
                    }, function (x) {
                        fromValue = x;
                        target.text = (addThousandsSeparator ? System.Int32.format(fromValue, "N0", cInfo) : Bridge.toString(fromValue));
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color.$clone(), new pc.Color( endValue.$clone().r - $t.r, endValue.$clone().g - $t.g, endValue.$clone().b - $t.b, endValue.$clone().a - $t.a ));
                    var to = new pc.Color( 0.0, 0.0, 0.0, 0.0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var color = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + color.$clone().r, $t1.g + color.$clone().g, $t1.b + color.$clone().b, $t1.a + color.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color.$clone(), new pc.Color( endValue.$clone().r - $t.r, endValue.$clone().g - $t.g, endValue.$clone().b - $t.b, endValue.$clone().a - $t.a ));
                    var to = new pc.Color( 0.0, 0.0, 0.0, 0.0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var color = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + color.$clone().r, $t1.g + color.$clone().g, $t1.b + color.$clone().b, $t1.a + color.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color.$clone(), new pc.Color( endValue.$clone().r - $t.r, endValue.$clone().g - $t.g, endValue.$clone().b - $t.b, endValue.$clone().a - $t.a ));
                    var to = new pc.Color( 0.0, 0.0, 0.0, 0.0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var color = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + color.$clone().r, $t1.g + color.$clone().g, $t1.b + color.$clone().b, $t1.a + color.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    var localPoint = { v : new UnityEngine.Vector2() };
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0.0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = ((i === ((len - 1) | 0)) ? (duration - DG.Tweening.TweenExtensions.Duration(s, false)) : (duration * ((i === 0) ? c.time : (c.time - colors[((i - 1) | 0)].time))));
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0.0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = ((i === ((len - 1) | 0)) ? (duration - DG.Tweening.TweenExtensions.Duration(s, false)) : (duration * ((i === 0) ? c.time : (c.time - colors[((i - 1) | 0)].time))));
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (!DG.Tweening.DOTweenModuleUtils._initialized) {
                        DG.Tweening.DOTweenModuleUtils._initialized = true;
                        DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (tweenRigidbody) {
                        var rBody = target.GetComponent(UnityEngine.Rigidbody);
                        if (UnityEngine.Component.op_Inequality(rBody, null)) {
                            rBodyFoundAndTweened = true;
                            t = (isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode));
                        }
                    }
                    if (!rBodyFoundAndTweened && tweenRigidbody) {
                        var rBody2D = target.GetComponent(UnityEngine.Rigidbody2D);
                        if (UnityEngine.Component.op_Inequality(rBody2D, null)) {
                            rBodyFoundAndTweened = true;
                            t = (isLocal ? DG.Tweening.DOTweenModulePhysics2D.DOLocalPath$1(rBody2D, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics2D.DOPath$1(rBody2D, path, duration, pathMode));
                        }
                    }
                    if (!rBodyFoundAndTweened) {
                        t = (isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode));
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*Hand start.*/
    Bridge.define("Hand", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null
        },
        methods: {
            /*Hand.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Hand#Start", this ); }

                this.StartCoroutine$1(this.LoopClick());
            },
            /*Hand.Start end.*/

            /*Hand.SetClick start.*/
            SetClick: function (position, parent) {
if ( TRACE ) { TRACE( "Hand#SetClick", this ); }

                this.transform.SetParent(parent);
                if (Singleton$1(LevelManager).Ins.IsEndCard) {
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, UnityEngine.Vector3.FromVector2(position.$clone()), 0.2), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                        this.StopAllCoroutines();
                        this.StartCoroutine$1(this.LoopClick());
                    }));
                } else {
                    this.transform.position = UnityEngine.Vector3.FromVector2(position.$clone());
                }
            },
            /*Hand.SetClick end.*/

            /*Hand.RunAnim start.*/
            RunAnim: function () {
if ( TRACE ) { TRACE( "Hand#RunAnim", this ); }

                Singleton$1(SoundManager).Ins.PlaySound("Click", false);
                this.anim.ResetTrigger$1("click");
                this.anim.SetTrigger$1("click");
            },
            /*Hand.RunAnim end.*/

            /*Hand.LoopClick start.*/
            LoopClick: function () {
if ( TRACE ) { TRACE( "Hand#LoopClick", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.RunAnim();
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.StartCoroutine$1(this.LoopClick());

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Hand.LoopClick end.*/


        }
    });
    /*Hand end.*/

    /*InputReceiver start.*/
    Bridge.define("InputReceiver", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*InputReceiver.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "InputReceiver#Update", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    Singleton$1(SoundManager).Ins.PlaySound("Click", false);
                    if (Singleton$1(LevelManager).Ins.IsEndCard) {
                        this.TriggerCTA();
                    } else {
                        this.HandleTarget();
                    }
                }
            },
            /*InputReceiver.Update end.*/

            /*InputReceiver.HandleTarget start.*/
            HandleTarget: function () {
if ( TRACE ) { TRACE( "InputReceiver#HandleTarget", this ); }

                var mousePos = UnityEngine.Input.mousePosition.$clone();
                mousePos = UnityEngine.Camera.main.ScreenToWorldPoint(new pc.Vec3( mousePos.x, mousePos.y, -10.0 ));
                var direction = mousePos.$clone().sub( UnityEngine.Camera.main.transform.position );
                var hits = UnityEngine.Physics2D.RaycastAll(UnityEngine.Physics2D.Raycast$2(UnityEngine.Vector2.FromVector3(mousePos), UnityEngine.Vector2.FromVector3(direction), Number.POSITIVE_INFINITY).point, pc.Vec2.ZERO.clone(), Number.POSITIVE_INFINITY);
                for (var i = 0; i < hits.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(hits[i].collider) || !UnityEngine.Object.op_Implicit(hits[i].collider.GetComponent(Pin))) {
                        continue;
                    }
                    var pin = hits[i].collider.gameObject.GetComponent(Pin);
                    if (UnityEngine.Object.op_Implicit(pin)) {
                        pin.ActivePin();
                        if (Singleton$1(LevelManager).Ins.CurrentLevel.Hand.gameObject.activeSelf) {
                            Singleton$1(LevelManager).Ins.CurrentLevel.Hand.gameObject.SetActive(false);
                            this.StopAllCoroutines();
                            this.StartCoroutine$1(this.ResetTutorial());
                        }
                    }
                }
            },
            /*InputReceiver.HandleTarget end.*/

            /*InputReceiver.ResetTutorial start.*/
            ResetTutorial: function () {
if ( TRACE ) { TRACE( "InputReceiver#ResetTutorial", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if (UnityEngine.Object.op_Implicit(Singleton$1(LevelManager).Ins.CurrentLevel.gameObject) && !Singleton$1(LevelManager).Ins.IsEndGame) {
                                            Singleton$1(LevelManager).Ins.CurrentLevel.SetTutorial();
                                        }

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*InputReceiver.ResetTutorial end.*/

            /*InputReceiver.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "InputReceiver#TriggerCTA", this ); }

                UnityEngine.Debug.Log$1("triggerCTA");
                Luna.Unity.Playable.InstallFullGame("https://play.google.com/store/apps/details?id=com.gamee.detective.mansion.pullpin.puzzle");
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*InputReceiver.TriggerCTA end.*/


        }
    });
    /*InputReceiver end.*/

    /*ItemLetter start.*/
    Bridge.define("ItemLetter", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            duration: 0,
            strength: 0,
            vibrato: 0
        },
        methods: {
            /*ItemLetter.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ItemLetter#Start", this ); }

                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.ShortcutExtensions.DOShakeScale(this.transform, this.duration, this.strength, this.vibrato, 0.0), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*ItemLetter.Start end.*/


        }
    });
    /*ItemLetter end.*/

    /*Level start.*/
    Bridge.define("Level", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            pins: null,
            pinsEndCard: null,
            hand: null,
            cameraElement: null,
            winPositionCamera: null,
            main: null,
            cat: null,
            frame: null,
            originalScale: null,
            originalAspect: 0,
            maxScore: 0
        },
        props: {
            Main: {
                get: function () {
if ( TRACE ) { TRACE( "Level#Main#get", this ); }

                    return this.main;
                }
            },
            MaxScore: {
                get: function () {
if ( TRACE ) { TRACE( "Level#MaxScore#get", this ); }

                    return this.maxScore;
                }
            },
            Hand: {
                get: function () {
if ( TRACE ) { TRACE( "Level#Hand#get", this ); }

                    return this.hand;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Level#init", this ); }

                this.originalScale = new UnityEngine.Vector3();
                this.pins = new (System.Collections.Generic.List$1(Pin)).ctor();
                this.pinsEndCard = new (System.Collections.Generic.List$1(Pin)).ctor();
            }
        },
        methods: {
            /*Level.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Level#Start", this ); }

                this.originalScale = this.frame.localScale.$clone();
                this.originalAspect = UnityEngine.Screen.width / UnityEngine.Screen.height;
                this.UpdateScale();
            },
            /*Level.Start end.*/

            /*Level.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Level#Update", this ); }

                if (Math.abs(this.originalAspect - UnityEngine.Screen.width / UnityEngine.Screen.height) > 0.01) {
                    this.UpdateScale();
                }
            },
            /*Level.Update end.*/

            /*Level.UpdateScale start.*/
            UpdateScale: function () {
if ( TRACE ) { TRACE( "Level#UpdateScale", this ); }

                var currentAspect = UnityEngine.Screen.width / UnityEngine.Screen.height;
                var scaleFactor = currentAspect / this.originalAspect;
                var newScale = this.originalScale.$clone().clone().scale( scaleFactor );
                if (newScale.x >= 0.3 && newScale.x <= 0.45) {
                    this.frame.localScale = newScale.$clone();
                } else if (newScale.x > 0.43) {
                    this.frame.localScale = new pc.Vec3( 0.43, 0.43, 0.43 );
                } else if (newScale.x < 0.35) {
                    this.frame.localScale = new pc.Vec3( 0.35, 0.35, 0.35 );
                }
                this.originalAspect = currentAspect;
            },
            /*Level.UpdateScale end.*/

            /*Level.SetUp start.*/
            SetUp: function () {
if ( TRACE ) { TRACE( "Level#SetUp", this ); }

                this.SetTutorial();
                this.StartCoroutine$1(this.SetUpSoundCharacter());
                this.cameraElement.WinPosition = UnityEngine.Vector2.FromVector3(this.winPositionCamera.position.$clone());
            },
            /*Level.SetUp end.*/

            /*Level.SetTutorial start.*/
            SetTutorial: function () {
if ( TRACE ) { TRACE( "Level#SetTutorial", this ); }

                var $t;
                if (Singleton$1(LevelManager).Ins.IsEndCard) {
                    this.StartCoroutine$1(this.ECTutorial());
                    return;
                }
                $t = Bridge.getEnumerator(this.pins);
                try {
                    while ($t.moveNext()) {
                        var pin = $t.Current;
                        if (Singleton$1(LevelManager).Ins.IsEndGame) {
                            break;
                        }
                        if (pin.gameObject.activeSelf) {
                            this.hand.gameObject.SetActive(true);
                            this.hand.SetClick(UnityEngine.Vector2.FromVector3(pin.Center.position.$clone()), pin.transform);
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Level.SetTutorial end.*/

            /*Level.ECTutorial start.*/
            ECTutorial: function () {
if ( TRACE ) { TRACE( "Level#ECTutorial", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    pin,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    i = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( i < this.pinsEndCard.Count ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    pin = this.pinsEndCard.getItem(i);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(2.5);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    this.hand.SetClick(UnityEngine.Vector2.FromVector3(pin.Center.position.$clone()), pin.transform);
                                        if (i === ((this.pinsEndCard.Count - 1) | 0)) {
                                            i = -1;
                                        }
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Level.ECTutorial end.*/

            /*Level.OnWin start.*/
            OnWin: function () {
if ( TRACE ) { TRACE( "Level#OnWin", this ); }

                Singleton$1(SoundManager).Ins.StopAll();
                this.main.Anim.SetAnim("TakePhoto", false);
                Singleton$1(SoundManager).Ins.PlaySound("TakePhoto", false);
                this.StartCoroutine$1(Singleton$1(UIManager).Ins.TakePhoto());
                this.cat.Anim.SetAnim("Happy", true);
            },
            /*Level.OnWin end.*/

            /*Level.OnLose start.*/
            OnLose: function () {
if ( TRACE ) { TRACE( "Level#OnLose", this ); }

                this.StopAllCoroutines();
                var rendererMain = this.main.Anim.GetComponent(UnityEngine.Renderer);
                var rendererCat = this.cat.Anim.GetComponent(UnityEngine.Renderer);
                if (UnityEngine.Object.op_Implicit(rendererMain) && UnityEngine.Object.op_Implicit(rendererCat)) {
                    rendererMain.sortingOrder = 6000;
                    rendererCat.sortingOrder = 6500;
                }
                this.main.Anim.SetAnim("Lose", true);
                this.cat.Anim.SetAnim("Sad", true);
            },
            /*Level.OnLose end.*/

            /*Level.SetUpSoundCharacter start.*/
            SetUpSoundCharacter: function () {
if ( TRACE ) { TRACE( "Level#SetUpSoundCharacter", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    i = 5;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( i < 7 ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 6;
                                    continue;
                                }
                                case 2: {
                                    if (Singleton$1(LevelManager).Ins.IsEndGame) {
                                            $step = 6;
                                            continue;
                                        }
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    Singleton$1(SoundManager).Ins.PlaySound("Rat", false);
                                        $enumerator.current = new UnityEngine.WaitForSeconds(i);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    if (i === 5 && !Singleton$1(LevelManager).Ins.IsEndGame) {
                                            Singleton$1(SoundManager).Ins.PlaySound("MainScared", false);
                                        } else if (!Singleton$1(LevelManager).Ins.IsEndGame) {
                                            Singleton$1(SoundManager).Ins.PlaySound("NeedHelp", false);
                                            i = 4;
                                        }
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 6: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Level.SetUpSoundCharacter end.*/


        }
    });
    /*Level end.*/

    /*Liquid start.*/
    Bridge.define("Liquid", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            liquid: null,
            rock: null,
            steamVFX: null,
            tag$1: null
        },
        methods: {
            /*Liquid.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Liquid#OnEnable", this ); }

                this.tag$1 = Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.tag;
                this.liquid.SetActive(true);
                this.rock.SetActive(false);
            },
            /*Liquid.OnEnable end.*/

            /*Liquid.OnCollisionStay2D start.*/
            OnCollisionStay2D: function (other) {
if ( TRACE ) { TRACE( "Liquid#OnCollisionStay2D", this ); }

                if (!Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.CompareTag("Rock") && ((other.gameObject.CompareTag("Lava") && Bridge.referenceEquals(this.tag$1, "Water")) || other.gameObject.CompareTag("Rock"))) {
                    var liquid = other.gameObject.GetComponent(Liquid);
                    liquid.TransferToRock();
                    this.TransferToRock();
                }
            },
            /*Liquid.OnCollisionStay2D end.*/

            /*Liquid.TransferToRock start.*/
            TransferToRock: function () {
if ( TRACE ) { TRACE( "Liquid#TransferToRock", this ); }

                Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.tag = "Rock";
                this.liquid.SetActive(false);
                this.rock.SetActive(true);
                Singleton$1(SoundManager).Ins.SoundInLava();
                if (UnityEngine.Object.op_Implicit(this.steamVFX)) {
                    this.steamVFX.Play();
                }
            },
            /*Liquid.TransferToRock end.*/


        }
    });
    /*Liquid end.*/

    /*Main start.*/
    Bridge.define("Main", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null
        },
        props: {
            Anim: {
                get: function () {
if ( TRACE ) { TRACE( "Main#Anim#get", this ); }

                    return this.anim;
                }
            }
        },
        methods: {
            /*Main.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Main#Start", this ); }

                this.anim.SetAnim("BonusAnim/Scared2", true);
            },
            /*Main.Start end.*/

            /*Main.SetAnimScare start.*/
            SetAnimScare: function () {
if ( TRACE ) { TRACE( "Main#SetAnimScare", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.5);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.anim.SetAnim("BonusAnim/Scared2", false);
                                        this.StartCoroutine$1(this.SetAnimScare());

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Main.SetAnimScare end.*/


        }
    });
    /*Main end.*/

    /*Pin start.*/
    Bridge.define("Pin", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            head: null,
            end: null,
            center: null
        },
        props: {
            Center: {
                get: function () {
if ( TRACE ) { TRACE( "Pin#Center#get", this ); }

                    return this.center;
                }
            }
        },
        methods: {
            /*Pin.ActivePin start.*/
            ActivePin: function () {
if ( TRACE ) { TRACE( "Pin#ActivePin", this ); }

                Singleton$1(SoundManager).Ins.PlaySound("DragPin", false);
                var direction = UnityEngine.Vector2.FromVector3(this.end.position.$clone().sub( this.head.position ));
                direction.normalize();
                DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, UnityEngine.Vector3.FromVector2(UnityEngine.Vector2.FromVector3(this.transform.position).add( direction.$clone().scale( 5.0 ) )), 0.5), DG.Tweening.Ease.Linear);
                this.StartCoroutine$1(this.DelayDestroy());
            },
            /*Pin.ActivePin end.*/

            /*Pin.DelayDestroy start.*/
            DelayDestroy: function () {
if ( TRACE ) { TRACE( "Pin#DelayDestroy", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(0.5);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.SetActive(false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*Pin.DelayDestroy end.*/


        }
    });
    /*Pin end.*/

    /*Rat start.*/
    Bridge.define("Rat", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            anim: null
        },
        methods: {
            /*Rat.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Rat#Start", this ); }

                this.anim.SetAnim("Idle", true);
            },
            /*Rat.Start end.*/


        }
    });
    /*Rat end.*/

    /*SharpJson.JsonDecoder start.*/
    Bridge.define("SharpJson.JsonDecoder", {
        statics: {
            methods: {
                /*SharpJson.JsonDecoder.DecodeText:static start.*/
                DecodeText: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#DecodeText", this ); }

                    var builder = new SharpJson.JsonDecoder();
                    return builder.Decode(text);
                },
                /*SharpJson.JsonDecoder.DecodeText:static end.*/


            }
        },
        fields: {
            lexer: null,
            errorMessage: null,
            parseNumbersAsFloat: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ctor", this ); }

                this.$initialize();
                this.errorMessage = null;
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.JsonDecoder.Decode start.*/
            Decode: function (text) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#Decode", this ); }

                this.errorMessage = null;
                this.lexer = new SharpJson.Lexer(text);
                this.lexer.parseNumbersAsFloat = this.parseNumbersAsFloat;
                return this.ParseValue();
            },
            /*SharpJson.JsonDecoder.Decode end.*/

            /*SharpJson.JsonDecoder.ParseObject start.*/
            ParseObject: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseObject", this ); }

                var table = new (System.Collections.Generic.Dictionary$2(System.String,System.Object)).ctor();
                this.lexer.NextToken();
                while (true) {
                    switch (this.lexer.LookAhead()) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            continue;
                        case SharpJson.Lexer.Token.CurlyClose: 
                            this.lexer.NextToken();
                            return table;
                    }
                    var name = this.EvalLexer(System.String, this.lexer.ParseString());
                    if (this.errorMessage != null) {
                        return null;
                    }
                    var token = this.lexer.NextToken();
                    if (token !== SharpJson.Lexer.Token.Colon) {
                        this.TriggerError("Invalid token; expected ':'");
                        return null;
                    }
                    var value = this.ParseValue();
                    if (this.errorMessage != null) {
                        return null;
                    }
                    table.setItem(name, value);
                }
            },
            /*SharpJson.JsonDecoder.ParseObject end.*/

            /*SharpJson.JsonDecoder.ParseArray start.*/
            ParseArray: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseArray", this ); }

                var array = new (System.Collections.Generic.List$1(System.Object)).ctor();
                this.lexer.NextToken();
                while (true) {
                    switch (this.lexer.LookAhead()) {
                        case SharpJson.Lexer.Token.None: 
                            this.TriggerError("Invalid token");
                            return null;
                        case SharpJson.Lexer.Token.Comma: 
                            this.lexer.NextToken();
                            continue;
                        case SharpJson.Lexer.Token.SquaredClose: 
                            this.lexer.NextToken();
                            return array;
                    }
                    var value = this.ParseValue();
                    if (this.errorMessage != null) {
                        return null;
                    }
                    array.add(value);
                }
            },
            /*SharpJson.JsonDecoder.ParseArray end.*/

            /*SharpJson.JsonDecoder.ParseValue start.*/
            ParseValue: function () {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#ParseValue", this ); }

                switch (this.lexer.LookAhead()) {
                    case SharpJson.Lexer.Token.String: 
                        return this.EvalLexer(System.String, this.lexer.ParseString());
                    case SharpJson.Lexer.Token.Number: 
                        if (this.parseNumbersAsFloat) {
                            return Bridge.box(this.EvalLexer(System.Single, this.lexer.ParseFloatNumber()), System.Single, System.Single.format, System.Single.getHashCode);
                        }
                        return Bridge.box(this.EvalLexer(System.Double, this.lexer.ParseDoubleNumber()), System.Double, System.Double.format, System.Double.getHashCode);
                    case SharpJson.Lexer.Token.CurlyOpen: 
                        return this.ParseObject();
                    case SharpJson.Lexer.Token.SquaredOpen: 
                        return this.ParseArray();
                    case SharpJson.Lexer.Token.True: 
                        this.lexer.NextToken();
                        return Bridge.box(true, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.False: 
                        this.lexer.NextToken();
                        return Bridge.box(false, System.Boolean, System.Boolean.toString);
                    case SharpJson.Lexer.Token.Null: 
                        this.lexer.NextToken();
                        return null;
                    default: 
                        this.TriggerError("Unable to parse value");
                        return null;
                }
            },
            /*SharpJson.JsonDecoder.ParseValue end.*/

            /*SharpJson.JsonDecoder.TriggerError start.*/
            TriggerError: function (message) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#TriggerError", this ); }

                this.errorMessage = System.String.format("Error: '{0}' at line {1}", message, Bridge.box(this.lexer.lineNumber, System.Int32));
            },
            /*SharpJson.JsonDecoder.TriggerError end.*/

            /*SharpJson.JsonDecoder.EvalLexer start.*/
            EvalLexer: function (T, value) {
if ( TRACE ) { TRACE( "SharpJson.JsonDecoder#EvalLexer", this ); }

                if (this.lexer.hasError) {
                    this.TriggerError("Lexical error ocurred");
                }
                return Bridge.rValue(value);
            },
            /*SharpJson.JsonDecoder.EvalLexer end.*/


        }
    });
    /*SharpJson.JsonDecoder end.*/

    /*SharpJson.Lexer start.*/
    Bridge.define("SharpJson.Lexer", {
        statics: {
            methods: {
                /*SharpJson.Lexer.NextToken:static start.*/
                NextToken: function (json, index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                    if (index.v === json.length) {
                        return SharpJson.Lexer.Token.None;
                    }
                    switch (json[Bridge.identity(index.v, ((index.v = (index.v + 1) | 0)))]) {
                        case 123: 
                            return SharpJson.Lexer.Token.CurlyOpen;
                        case 125: 
                            return SharpJson.Lexer.Token.CurlyClose;
                        case 91: 
                            return SharpJson.Lexer.Token.SquaredOpen;
                        case 93: 
                            return SharpJson.Lexer.Token.SquaredClose;
                        case 44: 
                            return SharpJson.Lexer.Token.Comma;
                        case 34: 
                            return SharpJson.Lexer.Token.String;
                        case 45: 
                        case 48: 
                        case 49: 
                        case 50: 
                        case 51: 
                        case 52: 
                        case 53: 
                        case 54: 
                        case 55: 
                        case 56: 
                        case 57: 
                            return SharpJson.Lexer.Token.Number;
                        case 58: 
                            return SharpJson.Lexer.Token.Colon;
                        default: 
                            {
                                index.v = (index.v - 1) | 0;
                                var remainingLength = (json.length - index.v) | 0;
                                if (remainingLength >= 5 && json[index.v] === 102 && json[((index.v + 1) | 0)] === 97 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 115 && json[((index.v + 4) | 0)] === 101) {
                                    index.v = (index.v + 5) | 0;
                                    return SharpJson.Lexer.Token.False;
                                }
                                if (remainingLength >= 4 && json[index.v] === 116 && json[((index.v + 1) | 0)] === 114 && json[((index.v + 2) | 0)] === 117 && json[((index.v + 3) | 0)] === 101) {
                                    index.v = (index.v + 4) | 0;
                                    return SharpJson.Lexer.Token.True;
                                }
                                if (remainingLength >= 4 && json[index.v] === 110 && json[((index.v + 1) | 0)] === 117 && json[((index.v + 2) | 0)] === 108 && json[((index.v + 3) | 0)] === 108) {
                                    index.v = (index.v + 4) | 0;
                                    return SharpJson.Lexer.Token.Null;
                                }
                                return SharpJson.Lexer.Token.None;
                            }
                    }
                },
                /*SharpJson.Lexer.NextToken:static end.*/


            }
        },
        fields: {
            json: null,
            index: 0,
            success: false,
            stringBuffer: null,
            lineNumber: 0,
            parseNumbersAsFloat: false
        },
        props: {
            hasError: {
                get: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#hasError#get", this ); }

                    return !this.success;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#init", this ); }

                this.index = 0;
                this.success = true;
                this.stringBuffer = System.Array.init(4096, 0, System.Char);
            },
            ctor: function (text) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ctor", this ); }

                this.$initialize();
                this.Reset();
                this.json = System.String.toCharArray(text, 0, text.length);
                this.parseNumbersAsFloat = false;
            }
        },
        methods: {
            /*SharpJson.Lexer.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#Reset", this ); }

                this.index = 0;
                this.lineNumber = 1;
                this.success = true;
            },
            /*SharpJson.Lexer.Reset end.*/

            /*SharpJson.Lexer.ParseString start.*/
            ParseString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseString", this ); }

                var idx = 0;
                var builder = null;
                this.SkipWhiteSpaces();
                var c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];
                var failed = false;
                var complete = false;
                while (!complete && !failed && this.index !== this.json.length) {
                    c = this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))];
                    if (c === 34) {
                        complete = true;
                        break;
                    }
                    if (c === 92) {
                        if (this.index === this.json.length) {
                            break;
                        }
                        switch (this.json[Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)))]) {
                            case 34: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 34;
                                break;
                            case 92: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 92;
                                break;
                            case 47: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 47;
                                break;
                            case 98: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 8;
                                break;
                            case 102: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 12;
                                break;
                            case 110: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 10;
                                break;
                            case 114: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 13;
                                break;
                            case 116: 
                                this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = 9;
                                break;
                            case 117: 
                                {
                                    var remainingLength = (this.json.length - this.index) | 0;
                                    if (remainingLength >= 4) {
                                        var hex = System.String.fromCharArray(this.json, this.index, 4);
                                        this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = (System.Convert.toNumberInBase(hex, 16, 9)) & 65535;
                                        this.index = (this.index + 4) | 0;
                                    } else {
                                        failed = true;
                                    }
                                    break;
                                }
                        }
                    } else {
                        this.stringBuffer[Bridge.identity(idx, ((idx = (idx + 1) | 0)))] = c;
                    }
                    if (idx >= this.stringBuffer.length) {
                        if (builder == null) {
                            builder = new System.Text.StringBuilder();
                        }
                        builder.append(this.stringBuffer.slice(0, idx).join());
                        idx = 0;
                    }
                }
                if (!complete) {
                    this.success = false;
                    return null;
                }
                if (builder != null) {
                    return builder.toString();
                }
                return System.String.fromCharArray(this.stringBuffer, 0, idx);
            },
            /*SharpJson.Lexer.ParseString end.*/

            /*SharpJson.Lexer.GetNumberString start.*/
            GetNumberString: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetNumberString", this ); }

                this.SkipWhiteSpaces();
                var lastIndex = this.GetLastIndexOfNumber(this.index);
                var charLength = (((lastIndex - this.index) | 0) + 1) | 0;
                var result = System.String.fromCharArray(this.json, this.index, charLength);
                this.index = (lastIndex + 1) | 0;
                return result;
            },
            /*SharpJson.Lexer.GetNumberString end.*/

            /*SharpJson.Lexer.ParseFloatNumber start.*/
            ParseFloatNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseFloatNumber", this ); }

                var str = this.GetNumberString();
                var number = { };
                if (!System.Single.tryParse4(str, 167, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0.0;
                }
                return number.v;
            },
            /*SharpJson.Lexer.ParseFloatNumber end.*/

            /*SharpJson.Lexer.ParseDoubleNumber start.*/
            ParseDoubleNumber: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#ParseDoubleNumber", this ); }

                var str = this.GetNumberString();
                var number = { };
                if (!System.Double.tryParse4(str, 511, System.Globalization.CultureInfo.invariantCulture, number)) {
                    return 0.0;
                }
                return number.v;
            },
            /*SharpJson.Lexer.ParseDoubleNumber end.*/

            /*SharpJson.Lexer.GetLastIndexOfNumber start.*/
            GetLastIndexOfNumber: function (index) {
if ( TRACE ) { TRACE( "SharpJson.Lexer#GetLastIndexOfNumber", this ); }

                var lastIndex;
                for (lastIndex = index; lastIndex < this.json.length; lastIndex = (lastIndex + 1) | 0) {
                    var ch = this.json[lastIndex];
                    if ((ch < 48 || ch > 57) && ch !== 43 && ch !== 45 && ch !== 46 && ch !== 101 && ch !== 69) {
                        break;
                    }
                }
                return ((lastIndex - 1) | 0);
            },
            /*SharpJson.Lexer.GetLastIndexOfNumber end.*/

            /*SharpJson.Lexer.SkipWhiteSpaces start.*/
            SkipWhiteSpaces: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#SkipWhiteSpaces", this ); }

                while (this.index < this.json.length) {
                    var ch = this.json[this.index];
                    if (ch === 10) {
                        this.lineNumber = (this.lineNumber + 1) | 0;
                    }
                    if (!System.Char.isWhiteSpace(String.fromCharCode(this.json[this.index]))) {
                        break;
                    }
                    this.index = (this.index + 1) | 0;
                }
            },
            /*SharpJson.Lexer.SkipWhiteSpaces end.*/

            /*SharpJson.Lexer.LookAhead start.*/
            LookAhead: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#LookAhead", this ); }

                this.SkipWhiteSpaces();
                var savedIndex = { v : this.index };
                return SharpJson.Lexer.NextToken(this.json, savedIndex);
            },
            /*SharpJson.Lexer.LookAhead end.*/

            /*SharpJson.Lexer.NextToken start.*/
            NextToken: function () {
if ( TRACE ) { TRACE( "SharpJson.Lexer#NextToken", this ); }

                this.SkipWhiteSpaces();
                return SharpJson.Lexer.NextToken(this.json, Bridge.ref(this, "index"));
            },
            /*SharpJson.Lexer.NextToken end.*/


        }
    });
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    Bridge.define("SharpJson.Lexer.Token", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Null: 1,
                True: 2,
                False: 3,
                Colon: 4,
                Comma: 5,
                String: 6,
                Number: 7,
                CurlyOpen: 8,
                CurlyClose: 9,
                SquaredOpen: 10,
                SquaredClose: 11
            }
        }
    });
    /*SharpJson.Lexer+Token end.*/

    /*Sound start.*/
    Bridge.define("Sound", {
        fields: {
            name: null,
            clip: null
        }
    });
    /*Sound end.*/

    /*Spine.ISlotTimeline start.*/
    Bridge.define("Spine.ISlotTimeline", {
        $kind: 3
    });
    /*Spine.ISlotTimeline end.*/

    /*Spine.Timeline start.*/
    Bridge.define("Spine.Timeline", {
        statics: {
            methods: {
                /*Spine.Timeline.Search:static start.*/
                Search: function (frames, time) {
if ( TRACE ) { TRACE( "Spine.Timeline#Search", this ); }

                    var j = frames.length;
                    for (var i = 1; i < j; i = (i + 1) | 0) {
                        if (frames[i] > time) {
                            return ((i - 1) | 0);
                        }
                    }
                    return ((j - 1) | 0);
                },
                /*Spine.Timeline.Search:static end.*/

                /*Spine.Timeline.Search$1:static start.*/
                Search$1: function (frames, time, step) {
if ( TRACE ) { TRACE( "Spine.Timeline#Search$1", this ); }

                    var j = frames.length;
                    for (var i = step; i < j; i = (i + step) | 0) {
                        if (frames[i] > time) {
                            return ((i - step) | 0);
                        }
                    }
                    return ((j - step) | 0);
                },
                /*Spine.Timeline.Search$1:static end.*/


            }
        },
        fields: {
            propertyIds: null,
            frames: null
        },
        props: {
            PropertyIds: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#PropertyIds#get", this ); }

                    return this.propertyIds;
                }
            },
            Frames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#Frames#get", this ); }

                    return this.frames;
                }
            },
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#FrameEntries#get", this ); }

                    return 1;
                }
            },
            FrameCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#FrameCount#get", this ); }

                    return ((Bridge.Int.div(this.frames.length, this.FrameEntries)) | 0);
                }
            },
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Timeline#Duration#get", this ); }

                    return this.frames[((this.frames.length - this.FrameEntries) | 0)];
                }
            }
        },
        ctors: {
            ctor: function (frameCount, propertyIds) {
if ( TRACE ) { TRACE( "Spine.Timeline#ctor", this ); }

                if (propertyIds === void 0) { propertyIds = []; }

                this.$initialize();
                if (propertyIds == null) {
                    throw new System.ArgumentNullException.$ctor3("propertyIds", "propertyIds cannot be null.");
                }
                this.propertyIds = propertyIds;
                this.frames = System.Array.init(Bridge.Int.mul(frameCount, this.FrameEntries), 0, System.Single);
            }
        }
    });
    /*Spine.Timeline end.*/

    /*Spine.Animation start.*/
    Bridge.define("Spine.Animation", {
        fields: {
            name: null,
            timelines: null,
            timelineIds: null,
            duration: 0
        },
        props: {
            Timelines: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#get", this ); }

                    return this.timelines;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Timelines#set", this ); }

                    this.SetTimelines(value);
                }
            },
            Duration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#get", this ); }

                    return this.duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Animation#Duration#set", this ); }

                    this.duration = value;
                }
            },
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Animation#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name, timelines, duration) {
if ( TRACE ) { TRACE( "Spine.Animation#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
                this.SetTimelines(timelines);
                this.duration = duration;
            }
        },
        methods: {
            /*Spine.Animation.SetTimelines start.*/
            SetTimelines: function (timelines) {
if ( TRACE ) { TRACE( "Spine.Animation#SetTimelines", this ); }

                if (timelines == null) {
                    throw new System.ArgumentNullException.$ctor3("timelines", "timelines cannot be null.");
                }
                this.timelines = timelines;
                var idCount = 0;
                var timelinesCount = timelines.Count;
                var timelinesItems = timelines.Items;
                for (var t2 = 0; t2 < timelinesCount; t2 = (t2 + 1) | 0) {
                    idCount = (idCount + timelinesItems[t2].PropertyIds.length) | 0;
                }
                var propertyIds = System.Array.init(idCount, null, System.String);
                var currentId = 0;
                for (var t = 0; t < timelinesCount; t = (t + 1) | 0) {
                    var ids = timelinesItems[t].PropertyIds;
                    var i = 0;
                    for (var idsLength = ids.length; i < idsLength; i = (i + 1) | 0) {
                        propertyIds[Bridge.identity(currentId, ((currentId = (currentId + 1) | 0)))] = ids[i];
                    }
                }
                this.timelineIds = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(propertyIds);
            },
            /*Spine.Animation.SetTimelines end.*/

            /*Spine.Animation.HasTimeline start.*/
            HasTimeline: function (propertyIds) {
if ( TRACE ) { TRACE( "Spine.Animation#HasTimeline", this ); }

                var $t;
                $t = Bridge.getEnumerator(propertyIds);
                try {
                    while ($t.moveNext()) {
                        var id = $t.Current;
                        if (this.timelineIds.contains(id)) {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            /*Spine.Animation.HasTimeline end.*/

            /*Spine.Animation.Apply start.*/
            Apply: function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.Animation#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                if (loop && this.duration !== 0.0) {
                    time %= this.duration;
                    if (lastTime > 0.0) {
                        lastTime %= this.duration;
                    }
                }
                var timelines = this.timelines.Items;
                var i = 0;
                for (var j = this.timelines.Count; i < j; i = (i + 1) | 0) {
                    timelines[i].Apply(skeleton, lastTime, time, events, alpha, blend, direction);
                }
            },
            /*Spine.Animation.Apply end.*/

            /*Spine.Animation.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Animation#toString", this ); }

                return this.name;
            },
            /*Spine.Animation.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Animation end.*/

    /*Spine.AnimationState start.*/
    Bridge.define("Spine.AnimationState", {
        statics: {
            fields: {
                Subsequent: 0,
                First: 0,
                HoldSubsequent: 0,
                HoldFirst: 0,
                HoldMix: 0,
                Setup: 0,
                Current: 0,
                EmptyAnimation: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                    this.Subsequent = 0;
                    this.First = 1;
                    this.HoldSubsequent = 2;
                    this.HoldFirst = 3;
                    this.HoldMix = 4;
                    this.Setup = 1;
                    this.Current = 2;
                    this.EmptyAnimation = new Spine.Animation("<empty>", new (Spine.ExposedList$1(Spine.Timeline)).ctor(), 0.0);
                }
            },
            methods: {
                /*Spine.AnimationState.ApplyRotateTimeline:static start.*/
                ApplyRotateTimeline: function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyRotateTimeline", this ); }

                    var $t;
                    if (firstFrame) {
                        timelinesRotation[i] = 0.0;
                    }
                    if (alpha === 1.0) {
                        timeline.Apply(skeleton, 0.0, time, null, 1.0, blend, Spine.MixDirection.In);
                        return;
                    }
                    var bone = ($t = skeleton.bones.Items)[timeline.BoneIndex];
                    if (!bone.active) {
                        return;
                    }
                    var frames = timeline.frames;
                    var r1;
                    var r2;
                    if (time < frames[0]) {
                        switch (blend) {
                            default: 
                                return;
                            case Spine.MixBlend.Setup: 
                                bone.rotation = bone.data.rotation;
                                return;
                            case Spine.MixBlend.First: 
                                break;
                        }
                        r1 = bone.rotation;
                        r2 = bone.data.rotation;
                    } else {
                        r1 = ((blend === Spine.MixBlend.Setup) ? bone.data.rotation : bone.rotation);
                        r2 = bone.data.rotation + timeline.GetCurveValue(time);
                    }
                    var diff = r2 - r1;
                    diff -= (Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - (diff / 360.0)))) | 0)), 360)) | 0;
                    var total;
                    if (diff === 0.0) {
                        total = timelinesRotation[i];
                    } else {
                        var lastTotal;
                        var lastDiff;
                        if (firstFrame) {
                            lastTotal = 0.0;
                            lastDiff = diff;
                        } else {
                            lastTotal = timelinesRotation[i];
                            lastDiff = timelinesRotation[((i + 1) | 0)];
                        }
                        var current = diff > 0.0;
                        var dir = lastTotal >= 0.0;
                        if (Bridge.Int.sign(lastDiff) !== Bridge.Int.sign(diff) && Math.abs(lastDiff) <= 90.0) {
                            if (Math.abs(lastTotal) > 180.0) {
                                lastTotal += (Bridge.Int.mul(360, Bridge.Int.sign(lastTotal))) | 0;
                            }
                            dir = current;
                        }
                        total = diff + lastTotal - lastTotal % 360.0;
                        if (dir !== current) {
                            total += (Bridge.Int.mul(360, Bridge.Int.sign(lastTotal))) | 0;
                        }
                        timelinesRotation[i] = total;
                    }
                    timelinesRotation[((i + 1) | 0)] = diff;
                    bone.rotation = r1 + total * alpha;
                },
                /*Spine.AnimationState.ApplyRotateTimeline:static end.*/


            }
        },
        fields: {
            data: null,
            tracks: null,
            events: null,
            queue: null,
            propertyIds: null,
            animationsChanged: false,
            timeScale: 0,
            unkeyedState: 0,
            trackEntryPool: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#get", this ); }

                    return this.data;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Data#set", this ); }

                    if (this.data == null) {
                        throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                    }
                    this.data = value;
                }
            },
            Tracks: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#Tracks#get", this ); }

                    return this.tracks;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#init", this ); }

                this.tracks = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.Event)).ctor();
                this.propertyIds = new (System.Collections.Generic.HashSet$1(System.String)).ctor();
                this.timeScale = 1.0;
                this.trackEntryPool = new (Spine.Pool$1(Spine.TrackEntry))();
            },
            ctor: function (data) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;
                this.queue = new Spine.EventQueue(this, Bridge.fn.bind(this, function () {
                    this.animationsChanged = true;
                }), this.trackEntryPool);
            }
        },
        methods: {
            /*Spine.AnimationState.OnStart start.*/
            OnStart: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(entry);
                }
            },
            /*Spine.AnimationState.OnStart end.*/

            /*Spine.AnimationState.OnInterrupt start.*/
            OnInterrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(entry);
                }
            },
            /*Spine.AnimationState.OnInterrupt end.*/

            /*Spine.AnimationState.OnEnd start.*/
            OnEnd: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(entry);
                }
            },
            /*Spine.AnimationState.OnEnd end.*/

            /*Spine.AnimationState.OnDispose start.*/
            OnDispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(entry);
                }
            },
            /*Spine.AnimationState.OnDispose end.*/

            /*Spine.AnimationState.OnComplete start.*/
            OnComplete: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(entry);
                }
            },
            /*Spine.AnimationState.OnComplete end.*/

            /*Spine.AnimationState.OnEvent start.*/
            OnEvent: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.AnimationState#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(entry, e);
                }
            },
            /*Spine.AnimationState.OnEvent end.*/

            /*Spine.AnimationState.AssignEventSubscribersFrom start.*/
            AssignEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AssignEventSubscribersFrom", this ); }

                this.Event = src.Event;
                this.Start = src.Start;
                this.Interrupt = src.Interrupt;
                this.End = src.End;
                this.Dispose = src.Dispose;
                this.Complete = src.Complete;
            },
            /*Spine.AnimationState.AssignEventSubscribersFrom end.*/

            /*Spine.AnimationState.AddEventSubscribersFrom start.*/
            AddEventSubscribersFrom: function (src) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEventSubscribersFrom", this ); }

                this.addEvent(src.Event);
                this.addStart(src.Start);
                this.addInterrupt(src.Interrupt);
                this.addEnd(src.End);
                this.addDispose(src.Dispose);
                this.addComplete(src.Complete);
            },
            /*Spine.AnimationState.AddEventSubscribersFrom end.*/

            /*Spine.AnimationState.Update start.*/
            Update: function (delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Update", this ); }

                delta *= this.timeScale;
                var tracksItems = this.tracks.Items;
                var i = 0;
                for (var j = this.tracks.Count; i < j; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null) {
                        continue;
                    }
                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;
                    var currentDelta = delta * current.timeScale;
                    if (current.delay > 0.0) {
                        current.delay -= currentDelta;
                        if (current.delay > 0.0) {
                            continue;
                        }
                        currentDelta = 0.0 - current.delay;
                        current.delay = 0.0;
                    }
                    var next = current.next;
                    if (next != null) {
                        var nextTime = current.trackLast - next.delay;
                        if (nextTime >= 0.0) {
                            next.delay = 0.0;
                            next.trackTime += ((current.timeScale === 0.0) ? 0.0 : ((nextTime / current.timeScale + delta) * next.timeScale));
                            current.trackTime += currentDelta;
                            this.SetCurrent(i, next, true);
                            while (next.mixingFrom != null) {
                                next.mixTime += delta;
                                next = next.mixingFrom;
                            }
                            continue;
                        }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                        tracksItems[i] = null;
                        this.queue.End(current);
                        this.ClearNext(current);
                        continue;
                    }
                    if (current.mixingFrom != null && this.UpdateMixingFrom(current, delta)) {
                        var from = current.mixingFrom;
                        current.mixingFrom = null;
                        if (from != null) {
                            from.mixingTo = null;
                        }
                        while (from != null) {
                            this.queue.End(from);
                            from = from.mixingFrom;
                        }
                    }
                    current.trackTime += currentDelta;
                }
                this.queue.Drain();
            },
            /*Spine.AnimationState.Update end.*/

            /*Spine.AnimationState.UpdateMixingFrom start.*/
            UpdateMixingFrom: function (to, delta) {
if ( TRACE ) { TRACE( "Spine.AnimationState#UpdateMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from == null) {
                    return true;
                }
                var finished = this.UpdateMixingFrom(from, delta);
                from.animationLast = from.nextAnimationLast;
                from.trackLast = from.nextTrackLast;
                if (to.mixTime > 0.0 && to.mixTime >= to.mixDuration) {
                    if (from.totalAlpha === 0.0 || to.mixDuration === 0.0) {
                        to.mixingFrom = from.mixingFrom;
                        if (from.mixingFrom != null) {
                            from.mixingFrom.mixingTo = to;
                        }
                        to.interruptAlpha = from.interruptAlpha;
                        this.queue.End(from);
                    }
                    return finished;
                }
                from.trackTime += delta * from.timeScale;
                to.mixTime += delta;
                return false;
            },
            /*Spine.AnimationState.UpdateMixingFrom end.*/

            /*Spine.AnimationState.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.AnimationState#Apply", this ); }

                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                if (this.animationsChanged) {
                    this.AnimationsChanged();
                }
                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                var i = 0;
                for (var k = this.tracks.Count; i < k; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0.0) {
                        continue;
                    }
                    applied = true;
                    var blend = ((i === 0) ? Spine.MixBlend.First : current.mixBlend);
                    var mix = current.alpha;
                    if (current.mixingFrom != null) {
                        mix *= this.ApplyMixingFrom(current, skeleton, blend);
                    } else if (current.trackTime >= current.trackEnd && current.next == null) {
                        mix = 0.0;
                    }
                    var animationLast = current.animationLast;
                    var animationTime = current.AnimationTime;
                    var applyTime = animationTime;
                    var applyEvents = events;
                    if (current.reverse) {
                        applyTime = current.animation.duration - applyTime;
                        applyEvents = null;
                    }
                    var timelineCount = current.animation.timelines.Count;
                    var timelines = current.animation.timelines.Items;
                    if ((i === 0 && mix === 1.0) || blend === Spine.MixBlend.Add) {
                        for (var ii2 = 0; ii2 < timelineCount; ii2 = (ii2 + 1) | 0) {
                            var timeline2 = timelines[ii2];
                            if (Bridge.is(timeline2, Spine.AttachmentTimeline)) {
                                this.ApplyAttachmentTimeline(Bridge.cast(timeline2, Spine.AttachmentTimeline), skeleton, applyTime, blend, true);
                            } else {
                                timeline2.Apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, Spine.MixDirection.In);
                            }
                        }
                    } else {
                        var timelineMode = current.timelineMode.Items;
                        var shortestRotation = current.shortestRotation;
                        var firstFrame = !shortestRotation && current.timelinesRotation.Count !== timelineCount << 1;
                        if (firstFrame) {
                            current.timelinesRotation.Resize(timelineCount << 1);
                        }
                        var timelinesRotation = current.timelinesRotation.Items;
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelines[ii];
                            var timelineBlend = ((timelineMode[ii] === 0) ? blend : Spine.MixBlend.Setup);
                            var rotateTimeline = Bridge.as(timeline, Spine.RotateTimeline);
                            if (!shortestRotation && rotateTimeline != null) {
                                Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, applyTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
                            } else if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                                this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, applyTime, blend, true);
                            } else {
                                timeline.Apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, Spine.MixDirection.In);
                            }
                        }
                    }
                    this.QueueEvents(current, animationTime);
                    events.Clear(false);
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }
                var setupState = (this.unkeyedState + 1) | 0;
                var slots = skeleton.slots.Items;
                var j = 0;
                for (var l = skeleton.slots.Count; j < l; j = (j + 1) | 0) {
                    var slot = slots[j];
                    if (slot.attachmentState === setupState) {
                        var attachmentName = slot.data.attachmentName;
                        slot.Attachment = ((attachmentName == null) ? null : skeleton.GetAttachment(slot.data.index, attachmentName));
                    }
                }
                this.unkeyedState = (this.unkeyedState + 2) | 0;
                this.queue.Drain();
                return applied;
            },
            /*Spine.AnimationState.Apply end.*/

            /*Spine.AnimationState.ApplyEventTimelinesOnly start.*/
            ApplyEventTimelinesOnly: function (skeleton, issueEvents) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyEventTimelinesOnly", this ); }

                if (issueEvents === void 0) { issueEvents = true; }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                var events = this.events;
                var applied = false;
                var tracksItems = this.tracks.Items;
                var i = 0;
                for (var j = this.tracks.Count; i < j; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current == null || current.delay > 0.0) {
                        continue;
                    }
                    applied = true;
                    if (current.mixingFrom != null) {
                        this.ApplyMixingFromEventTimelinesOnly(current, skeleton, issueEvents);
                    }
                    var animationLast = current.animationLast;
                    var animationTime = current.AnimationTime;
                    if (issueEvents) {
                        var timelineCount = current.animation.timelines.Count;
                        var timelines = current.animation.timelines.Items;
                        for (var ii = 0; ii < timelineCount; ii = (ii + 1) | 0) {
                            var timeline = timelines[ii];
                            if (Bridge.is(timeline, Spine.EventTimeline)) {
                                timeline.Apply(skeleton, animationLast, animationTime, events, 1.0, Spine.MixBlend.Setup, Spine.MixDirection.In);
                            }
                        }
                        this.QueueEvents(current, animationTime);
                        events.Clear(false);
                    }
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                }
                if (issueEvents) {
                    this.queue.Drain();
                }
                return applied;
            },
            /*Spine.AnimationState.ApplyEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyMixingFrom start.*/
            ApplyMixingFrom: function (to, skeleton, blend) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFrom", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFrom(from, skeleton, blend);
                }
                var mix;
                if (to.mixDuration === 0.0) {
                    mix = 1.0;
                    if (blend === Spine.MixBlend.First) {
                        blend = Spine.MixBlend.Setup;
                    }
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1.0) {
                        mix = 1.0;
                    }
                    if (blend !== Spine.MixBlend.First) {
                        blend = from.mixBlend;
                    }
                }
                var attachments = mix < from.attachmentThreshold;
                var drawOrder = mix < from.drawOrderThreshold;
                var timelineCount = from.animation.timelines.Count;
                var timelines = from.animation.timelines.Items;
                var alphaHold = from.alpha * to.interruptAlpha;
                var alphaMix = alphaHold * (1.0 - mix);
                var animationLast = from.animationLast;
                var animationTime = from.AnimationTime;
                var applyTime = animationTime;
                var events = null;
                if (from.reverse) {
                    applyTime = from.animation.duration - applyTime;
                } else if (mix < from.eventThreshold) {
                    events = this.events;
                }
                if (blend === Spine.MixBlend.Add) {
                    for (var j = 0; j < timelineCount; j = (j + 1) | 0) {
                        timelines[j].Apply(skeleton, animationLast, applyTime, events, alphaMix, blend, Spine.MixDirection.Out);
                    }
                } else {
                    var timelineMode = from.timelineMode.Items;
                    var timelineHoldMix = from.timelineHoldMix.Items;
                    var shortestRotation = from.shortestRotation;
                    var firstFrame = !shortestRotation && from.timelinesRotation.Count !== timelineCount << 1;
                    if (firstFrame) {
                        from.timelinesRotation.Resize(timelineCount << 1);
                    }
                    var timelinesRotation = from.timelinesRotation.Items;
                    from.totalAlpha = 0.0;
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        var timeline = timelines[i];
                        var direction = Spine.MixDirection.Out;
                        var timelineBlend = new Spine.MixBlend();
                        var alpha;
                        switch (timelineMode[i]) {
                            case 0: 
                                if (!drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline)) {
                                    continue;
                                }
                                timelineBlend = blend;
                                alpha = alphaMix;
                                break;
                            case 1: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaMix;
                                break;
                            case 2: 
                                timelineBlend = blend;
                                alpha = alphaHold;
                                break;
                            case 3: 
                                timelineBlend = Spine.MixBlend.Setup;
                                alpha = alphaHold;
                                break;
                            default: 
                                {
                                    timelineBlend = Spine.MixBlend.Setup;
                                    var holdMix = timelineHoldMix[i];
                                    alpha = alphaHold * Math.max(0.0, 1.0 - holdMix.mixTime / holdMix.mixDuration);
                                    break;
                                }
                        }
                        from.totalAlpha += alpha;
                        var rotateTimeline = Bridge.as(timeline, Spine.RotateTimeline);
                        if (!shortestRotation && rotateTimeline != null) {
                            Spine.AnimationState.ApplyRotateTimeline(rotateTimeline, skeleton, applyTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);
                            continue;
                        }
                        if (Bridge.is(timeline, Spine.AttachmentTimeline)) {
                            this.ApplyAttachmentTimeline(Bridge.cast(timeline, Spine.AttachmentTimeline), skeleton, applyTime, timelineBlend, attachments);
                            continue;
                        }
                        if (drawOrder && Bridge.is(timeline, Spine.DrawOrderTimeline) && timelineBlend === Spine.MixBlend.Setup) {
                            direction = Spine.MixDirection.In;
                        }
                        timeline.Apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);
                    }
                }
                if (to.mixDuration > 0.0) {
                    this.QueueEvents(from, animationTime);
                }
                this.events.Clear(false);
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;
                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFrom end.*/

            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly start.*/
            ApplyMixingFromEventTimelinesOnly: function (to, skeleton, issueEvents) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyMixingFromEventTimelinesOnly", this ); }

                var from = to.mixingFrom;
                if (from.mixingFrom != null) {
                    this.ApplyMixingFromEventTimelinesOnly(from, skeleton, issueEvents);
                }
                var mix;
                if (to.mixDuration === 0.0) {
                    mix = 1.0;
                } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1.0) {
                        mix = 1.0;
                    }
                }
                var eventBuffer = ((mix < from.eventThreshold) ? this.events : null);
                if (eventBuffer == null) {
                    return mix;
                }
                var animationLast = from.animationLast;
                var animationTime = from.AnimationTime;
                if (issueEvents) {
                    var timelineCount = from.animation.timelines.Count;
                    var timelines = from.animation.timelines.Items;
                    for (var i = 0; i < timelineCount; i = (i + 1) | 0) {
                        var timeline = timelines[i];
                        if (Bridge.is(timeline, Spine.EventTimeline)) {
                            timeline.Apply(skeleton, animationLast, animationTime, eventBuffer, 0.0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                        }
                    }
                    if (to.mixDuration > 0.0) {
                        this.QueueEvents(from, animationTime);
                    }
                    this.events.Clear(false);
                }
                from.nextAnimationLast = animationTime;
                from.nextTrackLast = from.trackTime;
                return mix;
            },
            /*Spine.AnimationState.ApplyMixingFromEventTimelinesOnly end.*/

            /*Spine.AnimationState.ApplyAttachmentTimeline start.*/
            ApplyAttachmentTimeline: function (timeline, skeleton, time, blend, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ApplyAttachmentTimeline", this ); }

                var $t, $t1;
                var slot = ($t = skeleton.slots.Items)[timeline.SlotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = timeline.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName, attachments);
                    }
                } else {
                    this.SetAttachment(skeleton, slot, ($t1 = timeline.AttachmentNames)[Spine.Timeline.Search(frames, time)], attachments);
                }
                if (slot.attachmentState <= this.unkeyedState) {
                    slot.attachmentState = (this.unkeyedState + 1) | 0;
                }
            },
            /*Spine.AnimationState.ApplyAttachmentTimeline end.*/

            /*Spine.AnimationState.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName, attachments) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAttachment", this ); }

                slot.Attachment = ((attachmentName == null) ? null : skeleton.GetAttachment(slot.data.index, attachmentName));
                if (attachments) {
                    slot.attachmentState = (this.unkeyedState + 2) | 0;
                }
            },
            /*Spine.AnimationState.SetAttachment end.*/

            /*Spine.AnimationState.QueueEvents start.*/
            QueueEvents: function (entry, animationTime) {
if ( TRACE ) { TRACE( "Spine.AnimationState#QueueEvents", this ); }

                var animationStart = entry.animationStart;
                var animationEnd = entry.animationEnd;
                var duration = animationEnd - animationStart;
                var trackLastWrapped = entry.trackLast % duration;
                var eventsItems = this.events.Items;
                var i = 0;
                var j;
                for (j = this.events.Count; i < j; i = (i + 1) | 0) {
                    var e2 = eventsItems[i];
                    if (e2.time < trackLastWrapped) {
                        break;
                    }
                    if (!(e2.time > animationEnd)) {
                        this.queue.Event(entry, e2);
                    }
                }
                var complete = false;
                if ((!entry.loop) ? (animationTime >= animationEnd && entry.animationLast < animationEnd) : (duration === 0.0 || trackLastWrapped > entry.trackTime % duration)) {
                    this.queue.Complete(entry);
                }
                for (; i < j; i = (i + 1) | 0) {
                    var e = eventsItems[i];
                    if (!(e.time < animationStart)) {
                        this.queue.Event(entry, eventsItems[i]);
                    }
                }
            },
            /*Spine.AnimationState.QueueEvents end.*/

            /*Spine.AnimationState.ClearTracks start.*/
            ClearTracks: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTracks", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                var i = 0;
                for (var j = this.tracks.Count; i < j; i = (i + 1) | 0) {
                    this.ClearTrack(i);
                }
                this.tracks.Clear();
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTracks end.*/

            /*Spine.AnimationState.ClearTrack start.*/
            ClearTrack: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearTrack", this ); }

                var $t, $t1;
                if (trackIndex >= this.tracks.Count) {
                    return;
                }
                var current = ($t = this.tracks.Items)[trackIndex];
                if (current == null) {
                    return;
                }
                this.queue.End(current);
                this.ClearNext(current);
                var entry = current;
                while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) {
                        break;
                    }
                    this.queue.End(from);
                    entry.mixingFrom = null;
                    entry.mixingTo = null;
                    entry = from;
                }
                ($t1 = this.tracks.Items)[current.trackIndex] = null;
                this.queue.Drain();
            },
            /*Spine.AnimationState.ClearTrack end.*/

            /*Spine.AnimationState.SetCurrent start.*/
            SetCurrent: function (index, current, interrupt) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetCurrent", this ); }

                var $t;
                var from = this.ExpandToIndex(index);
                ($t = this.tracks.Items)[index] = current;
                current.previous = null;
                if (from != null) {
                    if (interrupt) {
                        this.queue.Interrupt(from);
                    }
                    current.mixingFrom = from;
                    from.mixingTo = current;
                    current.mixTime = 0.0;
                    if (from.mixingFrom != null && from.mixDuration > 0.0) {
                        current.interruptAlpha *= Math.min(1.0, from.mixTime / from.mixDuration);
                    }
                    from.timelinesRotation.Clear();
                }
                this.queue.Start(current);
            },
            /*Spine.AnimationState.SetCurrent end.*/

            /*Spine.AnimationState.SetAnimation$1 start.*/
            SetAnimation$1: function (trackIndex, animationName, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.SetAnimation(trackIndex, animation, loop);
            },
            /*Spine.AnimationState.SetAnimation$1 end.*/

            /*Spine.AnimationState.SetAnimation start.*/
            SetAnimation: function (trackIndex, animation, loop) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetAnimation", this ); }

                var $t;
                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }
                var interrupt = true;
                var current = this.ExpandToIndex(trackIndex);
                if (current != null) {
                    if (current.nextTrackLast === -1.0) {
                        ($t = this.tracks.Items)[trackIndex] = current.mixingFrom;
                        this.queue.Interrupt(current);
                        this.queue.End(current);
                        this.ClearNext(current);
                        current = current.mixingFrom;
                        interrupt = false;
                    } else {
                        this.ClearNext(current);
                    }
                }
                var entry = this.NewTrackEntry(trackIndex, animation, loop, current);
                this.SetCurrent(trackIndex, entry, interrupt);
                this.queue.Drain();
                return entry;
            },
            /*Spine.AnimationState.SetAnimation end.*/

            /*Spine.AnimationState.AddAnimation$1 start.*/
            AddAnimation$1: function (trackIndex, animationName, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation$1", this ); }

                var animation = this.data.skeletonData.FindAnimation(animationName);
                if (animation == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (animationName || ""), "animationName");
                }
                return this.AddAnimation(trackIndex, animation, loop, delay);
            },
            /*Spine.AnimationState.AddAnimation$1 end.*/

            /*Spine.AnimationState.AddAnimation start.*/
            AddAnimation: function (trackIndex, animation, loop, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddAnimation", this ); }

                if (animation == null) {
                    throw new System.ArgumentNullException.$ctor3("animation", "animation cannot be null.");
                }
                var last = this.ExpandToIndex(trackIndex);
                if (last != null) {
                    while (last.next != null) {
                        last = last.next;
                    }
                }
                var entry = this.NewTrackEntry(trackIndex, animation, loop, last);
                if (last == null) {
                    this.SetCurrent(trackIndex, entry, true);
                    this.queue.Drain();
                } else {
                    last.next = entry;
                    entry.previous = last;
                    if (delay <= 0.0) {
                        delay += last.TrackComplete - entry.mixDuration;
                    }
                }
                entry.delay = delay;
                return entry;
            },
            /*Spine.AnimationState.AddAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimation start.*/
            SetEmptyAnimation: function (trackIndex, mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimation", this ); }

                var entry = this.SetAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false);
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.SetEmptyAnimation end.*/

            /*Spine.AnimationState.AddEmptyAnimation start.*/
            AddEmptyAnimation: function (trackIndex, mixDuration, delay) {
if ( TRACE ) { TRACE( "Spine.AnimationState#AddEmptyAnimation", this ); }

                var entry = this.AddAnimation(trackIndex, Spine.AnimationState.EmptyAnimation, false, delay);
                if (delay <= 0.0) {
                    entry.delay += entry.mixDuration - mixDuration;
                }
                entry.mixDuration = mixDuration;
                entry.trackEnd = mixDuration;
                return entry;
            },
            /*Spine.AnimationState.AddEmptyAnimation end.*/

            /*Spine.AnimationState.SetEmptyAnimations start.*/
            SetEmptyAnimations: function (mixDuration) {
if ( TRACE ) { TRACE( "Spine.AnimationState#SetEmptyAnimations", this ); }

                var oldDrainDisabled = this.queue.drainDisabled;
                this.queue.drainDisabled = true;
                var tracksItems = this.tracks.Items;
                var i = 0;
                for (var j = this.tracks.Count; i < j; i = (i + 1) | 0) {
                    var current = tracksItems[i];
                    if (current != null) {
                        this.SetEmptyAnimation(current.trackIndex, mixDuration);
                    }
                }
                this.queue.drainDisabled = oldDrainDisabled;
                this.queue.Drain();
            },
            /*Spine.AnimationState.SetEmptyAnimations end.*/

            /*Spine.AnimationState.ExpandToIndex start.*/
            ExpandToIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ExpandToIndex", this ); }

                var $t;
                if (index < this.tracks.Count) {
                    return ($t = this.tracks.Items)[index];
                }
                this.tracks.Resize(((index + 1) | 0));
                return null;
            },
            /*Spine.AnimationState.ExpandToIndex end.*/

            /*Spine.AnimationState.NewTrackEntry start.*/
            NewTrackEntry: function (trackIndex, animation, loop, last) {
if ( TRACE ) { TRACE( "Spine.AnimationState#NewTrackEntry", this ); }

                var entry = this.trackEntryPool.Obtain();
                entry.trackIndex = trackIndex;
                entry.animation = animation;
                entry.loop = loop;
                entry.holdPrevious = false;
                entry.eventThreshold = 0.0;
                entry.attachmentThreshold = 0.0;
                entry.drawOrderThreshold = 0.0;
                entry.animationStart = 0.0;
                entry.animationEnd = animation.Duration;
                entry.animationLast = -1.0;
                entry.nextAnimationLast = -1.0;
                entry.delay = 0.0;
                entry.trackTime = 0.0;
                entry.trackLast = -1.0;
                entry.nextTrackLast = -1.0;
                entry.trackEnd = 3.40282347E+38;
                entry.timeScale = 1.0;
                entry.alpha = 1.0;
                entry.interruptAlpha = 1.0;
                entry.mixTime = 0.0;
                entry.mixDuration = ((last == null) ? 0.0 : this.data.GetMix(last.animation, animation));
                entry.mixBlend = Spine.MixBlend.Replace;
                return entry;
            },
            /*Spine.AnimationState.NewTrackEntry end.*/

            /*Spine.AnimationState.ClearNext start.*/
            ClearNext: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearNext", this ); }

                for (var next = entry.next; next != null; next = next.next) {
                    this.queue.Dispose(next);
                }
                entry.next = null;
            },
            /*Spine.AnimationState.ClearNext end.*/

            /*Spine.AnimationState.AnimationsChanged start.*/
            AnimationsChanged: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#AnimationsChanged", this ); }

                this.animationsChanged = false;
                this.propertyIds.clear();
                var j = this.tracks.Count;
                var tracksItems = this.tracks.Items;
                for (var i = 0; i < j; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry == null) {
                        continue;
                    }
                    while (entry.mixingFrom != null) {
                        entry = entry.mixingFrom;
                    }
                    do {
                        if (entry.mixingTo == null || entry.mixBlend !== Spine.MixBlend.Add) {
                            this.ComputeHold(entry);
                        }
                        entry = entry.mixingTo;
                    } while (entry != null);
                }
            },
            /*Spine.AnimationState.AnimationsChanged end.*/

            /*Spine.AnimationState.ComputeHold start.*/
            ComputeHold: function (entry) {
if ( TRACE ) { TRACE( "Spine.AnimationState#ComputeHold", this ); }

                var to = entry.mixingTo;
                var timelines = entry.animation.timelines.Items;
                var timelinesCount = entry.animation.timelines.Count;
                var timelineMode = entry.timelineMode.Resize(timelinesCount).Items;
                entry.timelineHoldMix.Clear();
                var timelineHoldMix = entry.timelineHoldMix.Resize(timelinesCount).Items;
                var propertyIds = this.propertyIds;
                if (to != null && to.holdPrevious) {
                    for (var j = 0; j < timelinesCount; j = (j + 1) | 0) {
                        timelineMode[j] = (Spine.HashSetExtensions.AddAll(System.String, propertyIds, timelines[j].PropertyIds) ? 3 : 2);
                    }
                    return;
                }
                for (var i = 0; i < timelinesCount; i = (i + 1) | 0) {
                    var timeline = timelines[i];
                    var ids = timeline.PropertyIds;
                    if (!Spine.HashSetExtensions.AddAll(System.String, propertyIds, ids)) {
                        timelineMode[i] = 0;
                        continue;
                    }
                    if (to == null || Bridge.is(timeline, Spine.AttachmentTimeline) || Bridge.is(timeline, Spine.DrawOrderTimeline) || Bridge.is(timeline, Spine.EventTimeline) || !to.animation.HasTimeline(ids)) {
                        timelineMode[i] = 1;
                        continue;
                    }
                    var next = to.mixingTo;
                    while (true) {
                        if (next != null) {
                            if (next.animation.HasTimeline(ids)) {
                                next = next.mixingTo;
                                continue;
                            }
                            if (next.mixDuration > 0.0) {
                                timelineMode[i] = 4;
                                timelineHoldMix[i] = next;
                                break;
                            }
                        }
                        timelineMode[i] = 3;
                        break;
                    }
                }
            },
            /*Spine.AnimationState.ComputeHold end.*/

            /*Spine.AnimationState.GetCurrent start.*/
            GetCurrent: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.AnimationState#GetCurrent", this ); }

                var $t;
                if (trackIndex >= this.tracks.Count) {
                    return null;
                }
                return ($t = this.tracks.Items)[trackIndex];
            },
            /*Spine.AnimationState.GetCurrent end.*/

            /*Spine.AnimationState.ClearListenerNotifications start.*/
            ClearListenerNotifications: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#ClearListenerNotifications", this ); }

                this.queue.Clear();
            },
            /*Spine.AnimationState.ClearListenerNotifications end.*/

            /*Spine.AnimationState.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationState#toString", this ); }

                var buffer = new System.Text.StringBuilder();
                var tracksItems = this.tracks.Items;
                var i = 0;
                for (var j = this.tracks.Count; i < j; i = (i + 1) | 0) {
                    var entry = tracksItems[i];
                    if (entry != null) {
                        if (buffer.getLength() > 0) {
                            buffer.append(", ");
                        }
                        buffer.append(entry.toString());
                    }
                }
                if (buffer.getLength() === 0) {
                    return "<none>";
                }
                return buffer.toString();
            },
            /*Spine.AnimationState.toString end.*/


        },
        overloads: {
            "SetAnimation(int, string, bool)": "SetAnimation$1",
            "AddAnimation(int, string, bool, float)": "AddAnimation$1",
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationState end.*/

    /*Spine.AnimationStateData start.*/
    Bridge.define("Spine.AnimationStateData", {
        fields: {
            skeletonData: null,
            animationToMixTime: null,
            defaultMix: 0
        },
        props: {
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SkeletonData#get", this ); }

                    return this.skeletonData;
                }
            },
            DefaultMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#get", this ); }

                    return this.defaultMix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#DefaultMix#set", this ); }

                    this.defaultMix = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#init", this ); }

                this.animationToMixTime = new (System.Collections.Generic.Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single)).$ctor3(Spine.AnimationStateData.AnimationPairComparer.Instance);
            },
            ctor: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#ctor", this ); }

                this.$initialize();
                if (skeletonData == null) {
                    throw new System.ArgumentException.$ctor3("skeletonData cannot be null.", "skeletonData");
                }
                this.skeletonData = skeletonData;
            }
        },
        methods: {
            /*Spine.AnimationStateData.SetMix$1 start.*/
            SetMix$1: function (fromName, toName, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix$1", this ); }

                var from = this.skeletonData.FindAnimation(fromName);
                if (from == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (fromName || ""), "fromName");
                }
                var to = this.skeletonData.FindAnimation(toName);
                if (to == null) {
                    throw new System.ArgumentException.$ctor3("Animation not found: " + (toName || ""), "toName");
                }
                this.SetMix(from, to, duration);
            },
            /*Spine.AnimationStateData.SetMix$1 end.*/

            /*Spine.AnimationStateData.SetMix start.*/
            SetMix: function (from, to, duration) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#SetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                this.animationToMixTime.remove(key);
                this.animationToMixTime.add(key, duration);
            },
            /*Spine.AnimationStateData.SetMix end.*/

            /*Spine.AnimationStateData.GetMix start.*/
            GetMix: function (from, to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData#GetMix", this ); }

                if (from == null) {
                    throw new System.ArgumentNullException.$ctor3("from", "from cannot be null.");
                }
                if (to == null) {
                    throw new System.ArgumentNullException.$ctor3("to", "to cannot be null.");
                }
                var key = new Spine.AnimationStateData.AnimationPair.$ctor1(from, to);
                var duration = { };
                if (this.animationToMixTime.tryGetValue(key, duration)) {
                    return duration.v;
                }
                return this.defaultMix;
            },
            /*Spine.AnimationStateData.GetMix end.*/


        },
        overloads: {
            "SetMix(string, string, float)": "SetMix$1"
        }
    });
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPair", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getDefaultValue", this ); }
 return new Spine.AnimationStateData.AnimationPair(); }
            }
        },
        fields: {
            a1: null,
            a2: null
        },
        ctors: {
            $ctor1: function (a1, a2) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$ctor1", this ); }

                this.$initialize();
                this.a1 = a1;
                this.a2 = a2;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.AnimationStateData+AnimationPair.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#toString", this ); }

                return (this.a1.name || "") + "->" + (this.a2.name || "");
            },
            /*Spine.AnimationStateData+AnimationPair.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#getHashCode", this ); }

                var h = Bridge.addHash([5472793474, this.a1, this.a2]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#equals", this ); }

                if (!Bridge.is(o, Spine.AnimationStateData.AnimationPair)) {
                    return false;
                }
                return Bridge.equals(this.a1, o.a1) && Bridge.equals(this.a2, o.a2);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPair#$clone", this ); }

                var s = to || new Spine.AnimationStateData.AnimationPair();
                s.a1 = this.a1;
                s.a2 = this.a2;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.TextureRegion start.*/
    Bridge.define("Spine.TextureRegion", {
        fields: {
            width: 0,
            height: 0,
            u: 0,
            v: 0,
            u2: 0,
            v2: 0
        },
        props: {
            OriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TextureRegion#OriginalWidth#get", this ); }

                    return this.width;
                }
            },
            OriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TextureRegion#OriginalHeight#get", this ); }

                    return this.height;
                }
            }
        }
    });
    /*Spine.TextureRegion end.*/

    /*Spine.AttachmentLoader start.*/
    Bridge.define("Spine.AttachmentLoader", {
        $kind: 3
    });
    /*Spine.AttachmentLoader end.*/

    /*Spine.AtlasPage start.*/
    Bridge.define("Spine.AtlasPage", {
        fields: {
            name: null,
            width: 0,
            height: 0,
            format: 0,
            minFilter: 0,
            magFilter: 0,
            uWrap: 0,
            vWrap: 0,
            pma: false,
            rendererObject: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#init", this ); }

                this.format = Spine.Format.RGBA8888;
                this.minFilter = Spine.TextureFilter.Nearest;
                this.magFilter = Spine.TextureFilter.Nearest;
                this.uWrap = Spine.TextureWrap.ClampToEdge;
                this.vWrap = Spine.TextureWrap.ClampToEdge;
            }
        },
        methods: {
            /*Spine.AtlasPage.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasPage#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasPage);
            },
            /*Spine.AtlasPage.Clone end.*/


        }
    });
    /*Spine.AtlasPage end.*/

    /*Spine.Attachment start.*/
    Bridge.define("Spine.Attachment", {
        fields: {
            Name: null
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.Attachment#$ctor1", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.Name = name;
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.Attachment#ctor", this ); }

                this.$initialize();
                this.Name = other.Name;
            }
        },
        methods: {
            /*Spine.Attachment.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Attachment#toString", this ); }

                return this.Name;
            },
            /*Spine.Attachment.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Attachment end.*/

    /*Spine.AttachmentType start.*/
    Bridge.define("Spine.AttachmentType", {
        $kind: 6,
        statics: {
            fields: {
                Region: 0,
                Boundingbox: 1,
                Mesh: 2,
                Linkedmesh: 3,
                Path: 4,
                Point: 5,
                Clipping: 6,
                Sequence: 7
            }
        }
    });
    /*Spine.AttachmentType end.*/

    /*Spine.BlendMode start.*/
    Bridge.define("Spine.BlendMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Additive: 1,
                Multiply: 2,
                Screen: 3
            }
        }
    });
    /*Spine.BlendMode end.*/

    /*Spine.IUpdatable start.*/
    Bridge.define("Spine.IUpdatable", {
        $kind: 3
    });
    /*Spine.IUpdatable end.*/

    /*Spine.BoneData start.*/
    Bridge.define("Spine.BoneData", {
        fields: {
            index: 0,
            name: null,
            parent: null,
            length: 0,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            transformMode: 0,
            skinRequired: false
        },
        props: {
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Index#get", this ); }

                    return this.index;
                }
            },
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Name#get", this ); }

                    return this.name;
                }
            },
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Parent#get", this ); }

                    return this.parent;
                }
            },
            Length: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#get", this ); }

                    return this.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Length#set", this ); }

                    this.length = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            TransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#get", this ); }

                    return this.transformMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#TransformMode#set", this ); }

                    this.transformMode = value;
                }
            },
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.BoneData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#init", this ); }

                this.scaleX = 1.0;
                this.scaleY = 1.0;
                this.transformMode = Spine.TransformMode.Normal;
            },
            ctor: function (index, name, parent) {
if ( TRACE ) { TRACE( "Spine.BoneData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.parent = parent;
            }
        },
        methods: {
            /*Spine.BoneData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.BoneData#toString", this ); }

                return this.name;
            },
            /*Spine.BoneData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.BoneData end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }
                    if (boneData.Parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }
                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.Parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.Parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    }
                    var pa = parentMatrix.a;
                    var pb = parentMatrix.b;
                    var pc = parentMatrix.c;
                    var pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.X + pb * boneData.Y + parentMatrix.x;
                    result.y = pc * boneData.X + pd * boneData.Y + parentMatrix.y;
                    switch (boneData.TransformMode) {
                        case Spine.TransformMode.Normal: 
                            {
                                var rotationY = boneData.Rotation + 90.0 + boneData.ShearY;
                                var la = Spine.MathUtils.CosDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.ScaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.ScaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case Spine.TransformMode.OnlyTranslation: 
                            {
                                var rotationY2 = boneData.Rotation + 90.0 + boneData.ShearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY2) * boneData.ScaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.Rotation + boneData.ShearX) * boneData.ScaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY2) * boneData.ScaleY;
                                break;
                            }
                        case Spine.TransformMode.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc;
                                var prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * (57.2957764);
                                } else {
                                    pa = 0.0;
                                    pc = 0.0;
                                    prx = 90.0 - Spine.MathUtils.Atan2(pd, pb) * (57.2957764);
                                }
                                var rx = boneData.Rotation + boneData.ShearX - prx;
                                var ry = boneData.Rotation + boneData.ShearY - prx + 90.0;
                                var la2 = Spine.MathUtils.CosDeg(rx) * boneData.ScaleX;
                                var lb2 = Spine.MathUtils.CosDeg(ry) * boneData.ScaleY;
                                var lc2 = Spine.MathUtils.SinDeg(rx) * boneData.ScaleX;
                                var ld2 = Spine.MathUtils.SinDeg(ry) * boneData.ScaleY;
                                result.a = pa * la2 - pb * lc2;
                                result.b = pa * lb2 - pb * ld2;
                                result.c = pc * la2 + pd * lc2;
                                result.d = pc * lb2 + pd * ld2;
                                break;
                            }
                        case Spine.TransformMode.NoScale: 
                        case Spine.TransformMode.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.Rotation);
                                var sin = Spine.MathUtils.SinDeg(boneData.Rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s2 = Math.sqrt(za * za + zc * zc);
                                if (s2 > 1E-05) {
                                    s2 = 1.0 / s2;
                                }
                                za *= s2;
                                zc *= s2;
                                s2 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s2;
                                var zd = Spine.MathUtils.Sin(r) * s2;
                                var la3 = Spine.MathUtils.CosDeg(boneData.ShearX) * boneData.ScaleX;
                                var lb3 = Spine.MathUtils.CosDeg(90.0 + boneData.ShearY) * boneData.ScaleY;
                                var lc3 = Spine.MathUtils.SinDeg(boneData.ShearX) * boneData.ScaleX;
                                var ld3 = Spine.MathUtils.SinDeg(90.0 + boneData.ShearY) * boneData.ScaleY;
                                if (boneData.TransformMode !== Spine.TransformMode.NoScaleOrReflection && pa * pd - pb * pc < 0.0) {
                                    zb = 0.0 - zb;
                                    zd = 0.0 - zd;
                                }
                                result.a = za * la3 + zb * lc3;
                                result.b = za * lb3 + zb * ld3;
                                result.c = zc * la3 + zd * lc3;
                                result.d = zc * lb3 + zd * ld3;
                                break;
                            }
                    }
                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.Rotation + 90.0 + boneData.ShearY;
                var rotationX = boneData.Rotation + boneData.ShearX;
                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.ScaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.ScaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.ScaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.ScaleY;
                this.x = boneData.X;
                this.y = boneData.Y;
            },
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.Rotation + 90.0 + bone.ShearY;
                var rotationX = bone.Rotation + bone.ShearX;
                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.ScaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.ScaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.ScaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.ScaleY;
                this.x = bone.X;
                this.y = bone.Y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                result.a = this.a * local.a + this.b * local.c;
                result.b = this.a * local.b + this.b * local.d;
                result.c = this.c * local.a + this.d * local.c;
                result.d = this.c * local.b + this.d * local.d;
                result.x = this.a * local.x + this.b * local.y + this.x;
                result.y = this.c * local.x + this.d * local.y + this.y;
                return result.$clone();
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.ConstraintData start.*/
    Bridge.define("Spine.ConstraintData", {
        fields: {
            name: null,
            order: 0,
            skinRequired: false
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Name#get", this ); }

                    return this.name;
                }
            },
            Order: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#get", this ); }

                    return this.order;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#Order#set", this ); }

                    this.order = value;
                }
            },
            SkinRequired: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#get", this ); }

                    return this.skinRequired;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#SkinRequired#set", this ); }

                    this.skinRequired = value;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.ConstraintData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.ConstraintData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.ConstraintData#toString", this ); }

                return this.name;
            },
            /*Spine.ConstraintData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.ConstraintData end.*/

    /*Spine.Event start.*/
    Bridge.define("Spine.Event", {
        fields: {
            data: null,
            time: 0,
            intValue: 0,
            floatValue: 0,
            stringValue: null,
            volume: 0,
            balance: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Data#get", this ); }

                    return this.data;
                }
            },
            Time: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Time#get", this ); }

                    return this.time;
                }
            },
            Int: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Int#get", this ); }

                    return this.intValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Int#set", this ); }

                    this.intValue = value;
                }
            },
            Float: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Float#get", this ); }

                    return this.floatValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Float#set", this ); }

                    this.floatValue = value;
                }
            },
            String: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#String#get", this ); }

                    return this.stringValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#String#set", this ); }

                    this.stringValue = value;
                }
            },
            Volume: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Volume#get", this ); }

                    return this.volume;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Volume#set", this ); }

                    this.volume = value;
                }
            },
            Balance: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Event#Balance#get", this ); }

                    return this.balance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Event#Balance#set", this ); }

                    this.balance = value;
                }
            }
        },
        ctors: {
            ctor: function (time, data) {
if ( TRACE ) { TRACE( "Spine.Event#ctor", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.time = time;
                this.data = data;
            }
        },
        methods: {
            /*Spine.Event.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Event#toString", this ); }

                return this.data.Name;
            },
            /*Spine.Event.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    Bridge.define("Spine.EventData", {
        fields: {
            name: null,
            Int: 0,
            Float: 0,
            String: null,
            AudioPath: null,
            Volume: 0,
            Balance: 0
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventData#Name#get", this ); }

                    return this.name;
                }
            }
        },
        ctors: {
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.EventData#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.EventData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.EventData#toString", this ); }

                return this.Name;
            },
            /*Spine.EventData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.EventData end.*/

    /*Spine.EventQueue start.*/
    Bridge.define("Spine.EventQueue", {
        fields: {
            eventQueueEntries: null,
            drainDisabled: false,
            state: null,
            trackEntryPool: null
        },
        events: {
            AnimationsChanged: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#init", this ); }

                this.eventQueueEntries = new (System.Collections.Generic.List$1(Spine.EventQueue.EventQueueEntry)).ctor();
            },
            ctor: function (state, HandleAnimationsChanged, trackEntryPool) {
if ( TRACE ) { TRACE( "Spine.EventQueue#ctor", this ); }

                this.$initialize();
                this.state = state;
                this.addAnimationsChanged(HandleAnimationsChanged);
                this.trackEntryPool = trackEntryPool;
            }
        },
        methods: {
            /*Spine.EventQueue.Start start.*/
            Start: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Start", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Start, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.Start end.*/

            /*Spine.EventQueue.Interrupt start.*/
            Interrupt: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Interrupt", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Interrupt, entry));
            },
            /*Spine.EventQueue.Interrupt end.*/

            /*Spine.EventQueue.End start.*/
            End: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#End", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.End, entry));
                if (!Bridge.staticEquals(this.AnimationsChanged, null)) {
                    this.AnimationsChanged();
                }
            },
            /*Spine.EventQueue.End end.*/

            /*Spine.EventQueue.Dispose start.*/
            Dispose: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Dispose", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Dispose, entry));
            },
            /*Spine.EventQueue.Dispose end.*/

            /*Spine.EventQueue.Complete start.*/
            Complete: function (entry) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Complete", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Complete, entry));
            },
            /*Spine.EventQueue.Complete end.*/

            /*Spine.EventQueue.Event start.*/
            Event: function (entry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue#Event", this ); }

                this.eventQueueEntries.add(new Spine.EventQueue.EventQueueEntry.$ctor1(Spine.EventQueue.EventType.Event, entry, e));
            },
            /*Spine.EventQueue.Event end.*/

            /*Spine.EventQueue.Drain start.*/
            Drain: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Drain", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    eventQueueEntries, 
                    state, 
                    i, 
                    queueEntry, 
                    trackEntry, 
                    $t, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,10,11], $step);
                            switch ($step) {
                                case 0: {
                                    if (this.drainDisabled) {
                                        return;
                                    }
                                    this.drainDisabled = true;
                                    eventQueueEntries = this.eventQueueEntries;
                                    state = this.state;
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < eventQueueEntries.Count ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 11;
                                    continue;
                                }
                                case 2: {
                                    queueEntry = eventQueueEntries.getItem(i).$clone();
                                    trackEntry = queueEntry.entry;
                                    $t = queueEntry.type;
                                    if ($t === Spine.EventQueue.EventType.Start) {
                                        $step = 3;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Interrupt) {
                                        $step = 4;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.End) {
                                        $step = 5;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Dispose) {
                                        $step = 6;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Complete) {
                                        $step = 7;
                                        continue;
                                    }
                                    else if ($t === Spine.EventQueue.EventType.Event) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 9;
                                    continue;
                                }
                                case 3: {
                                    trackEntry.OnStart();
                                    state.OnStart(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 4: {
                                    trackEntry.OnInterrupt();
                                    state.OnInterrupt(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 5: {
                                    trackEntry.OnEnd();
                                    state.OnEnd(trackEntry);
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    trackEntry.OnDispose();
                                    state.OnDispose(trackEntry);
                                    this.trackEntryPool.Free(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    trackEntry.OnComplete();
                                    state.OnComplete(trackEntry);
                                    $step = 9;
                                    continue;
                                }
                                case 8: {
                                    trackEntry.OnEvent(queueEntry.e);
                                    state.OnEvent(trackEntry, queueEntry.e);
                                    $step = 9;
                                    continue;
                                }

                                case 10: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 11: {
                                    eventQueueEntries.clear();
                                    this.drainDisabled = false;
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.EventQueue.Drain end.*/

            /*Spine.EventQueue.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue#Clear", this ); }

                this.eventQueueEntries.clear();
            },
            /*Spine.EventQueue.Clear end.*/


        }
    });
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    Bridge.define("Spine.EventQueue.EventQueueEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getDefaultValue", this ); }
 return new Spine.EventQueue.EventQueueEntry(); }
            }
        },
        fields: {
            type: 0,
            entry: null,
            e: null
        },
        ctors: {
            $ctor1: function (eventType, trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$ctor1", this ); }

                if (e === void 0) { e = null; }

                this.$initialize();
                this.type = eventType;
                this.entry = trackEntry;
                this.e = e;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#getHashCode", this ); }

                var h = Bridge.addHash([5412331426, this.type, this.entry, this.e]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#equals", this ); }

                if (!Bridge.is(o, Spine.EventQueue.EventQueueEntry)) {
                    return false;
                }
                return Bridge.equals(this.type, o.type) && Bridge.equals(this.entry, o.entry) && Bridge.equals(this.e, o.e);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.EventQueue.EventQueueEntry#$clone", this ); }

                var s = to || new Spine.EventQueue.EventQueueEntry();
                s.type = this.type;
                s.entry = this.entry;
                s.e = this.e;
                return s;
            }
        }
    });
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    Bridge.define("Spine.EventQueue.EventType", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 0,
                Interrupt: 1,
                End: 2,
                Dispose: 3,
                Complete: 4,
                Event: 5
            }
        }
    });
    /*Spine.EventQueue+EventType end.*/

    /*Spine.ExposedList$1 start.*/
    Bridge.define("Spine.ExposedList$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T),System.Collections.IEnumerable],
        statics: {
            fields: {
                DefaultCapacity: 0,
                EmptyArray: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#init", this ); }

                    this.DefaultCapacity = 4;
                    this.EmptyArray = System.Array.init(0, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            },
            methods: {
                /*Spine.ExposedList$1.CheckMatch:static start.*/
                CheckMatch: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckMatch", this ); }

                    if (Bridge.staticEquals(match, null)) {
                        throw new System.ArgumentNullException.$ctor1("match");
                    }
                },
                /*Spine.ExposedList$1.CheckMatch:static end.*/


            }
        },
        fields: {
            Items: null,
            Count: 0,
            version: 0
        },
        props: {
            Capacity: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#get", this ); }

                    return this.Items.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Capacity#set", this ); }

                    if ((value >>> 0) < (this.Count >>> 0)) {
                        throw new System.ArgumentOutOfRangeException.ctor();
                    }
                    System.Array.resize(Bridge.ref(this, "Items"), value, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }
            }
        },
        alias: ["System$Collections$Generic$IEnumerable$1$GetEnumerator", "System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ctor", this ); }

                this.$initialize();
                this.Items = Spine.ExposedList$1(T).EmptyArray;
            },
            $ctor2: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor2", this ); }

                this.$initialize();
                this.CheckCollection(collection);
                var c;
                if (!(((c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T)))) != null)) {
                    this.Items = Spine.ExposedList$1(T).EmptyArray;
                    this.AddEnumerable(collection);
                } else {
                    this.Items = System.Array.init(System.Array.getCount(c, T), function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.AddCollection(c);
                }
            },
            $ctor3: function (capacity) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor3", this ); }

                this.$initialize();
                if (capacity < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("capacity");
                }
                this.Items = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            $ctor1: function (data, size) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#$ctor1", this ); }

                this.$initialize();
                this.Items = data;
                this.Count = size;
            }
        },
        methods: {
            /*Spine.ExposedList$1.Add start.*/
            Add: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Add", this ); }

                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Items[Bridge.identity(this.Count, ((this.Count = (this.Count + 1) | 0)))] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Add end.*/

            /*Spine.ExposedList$1.GrowIfNeeded start.*/
            GrowIfNeeded: function (addedCount) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GrowIfNeeded", this ); }

                var minimumSize = (this.Count + addedCount) | 0;
                if (minimumSize > this.Items.length) {
                    this.Capacity = Math.max(Math.max(Bridge.Int.mul(this.Capacity, 2), 4), minimumSize);
                }
            },
            /*Spine.ExposedList$1.GrowIfNeeded end.*/

            /*Spine.ExposedList$1.Resize start.*/
            Resize: function (newSize) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Resize", this ); }

                var itemsLength = this.Items.length;
                var oldItems = this.Items;
                if (newSize > itemsLength) {
                    System.Array.resize(Bridge.ref(this, "Items"), newSize, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                } else if (newSize < itemsLength) {
                    for (var i = newSize; i < itemsLength; i = (i + 1) | 0) {
                        oldItems[i] = Bridge.getDefaultValue(T);
                    }
                }
                this.Count = newSize;
                return this;
            },
            /*Spine.ExposedList$1.Resize end.*/

            /*Spine.ExposedList$1.EnsureCapacity start.*/
            EnsureCapacity: function (min) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#EnsureCapacity", this ); }

                if (this.Items.length < min) {
                    var newCapacity = ((this.Items.length === 0) ? 4 : (Bridge.Int.mul(this.Items.length, 2)));
                    if (newCapacity < min) {
                        newCapacity = min;
                    }
                    this.Capacity = newCapacity;
                }
            },
            /*Spine.ExposedList$1.EnsureCapacity end.*/

            /*Spine.ExposedList$1.CheckRange start.*/
            CheckRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckRange", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if ((((((index + count) | 0))) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentException.$ctor1("index and count exceed length of list");
                }
            },
            /*Spine.ExposedList$1.CheckRange end.*/

            /*Spine.ExposedList$1.AddCollection start.*/
            AddCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                if (collectionCount !== 0) {
                    this.GrowIfNeeded(collectionCount);
                    System.Array.copyTo(collection, this.Items, this.Count, T);
                    this.Count = (this.Count + collectionCount) | 0;
                }
            },
            /*Spine.ExposedList$1.AddCollection end.*/

            /*Spine.ExposedList$1.AddEnumerable start.*/
            AddEnumerable: function (enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddEnumerable", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Add(Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.AddEnumerable end.*/

            /*Spine.ExposedList$1.AddRange start.*/
            AddRange: function (list) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange", this ); }

                this.CheckCollection(list);
                var collectionCount = list.Count;
                if (collectionCount !== 0) {
                    this.GrowIfNeeded(collectionCount);
                    list.CopyTo$1(this.Items, this.Count);
                    this.Count = (this.Count + collectionCount) | 0;
                    this.version = (this.version + 1) | 0;
                }
            },
            /*Spine.ExposedList$1.AddRange end.*/

            /*Spine.ExposedList$1.AddRange$1 start.*/
            AddRange$1: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#AddRange$1", this ); }

                this.CheckCollection(collection);
                var c;
                if (((c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T)))) != null) {
                    this.AddCollection(c);
                } else {
                    this.AddEnumerable(collection);
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.AddRange$1 end.*/

            /*Spine.ExposedList$1.BinarySearch start.*/
            BinarySearch: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item));
            },
            /*Spine.ExposedList$1.BinarySearch end.*/

            /*Spine.ExposedList$1.BinarySearch$1 start.*/
            BinarySearch$1: function (item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$1", this ); }

                return System.Array.binarySearch(this.Items, 0, this.Count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$1 end.*/

            /*Spine.ExposedList$1.BinarySearch$2 start.*/
            BinarySearch$2: function (index, count, item, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#BinarySearch$2", this ); }

                this.CheckRange(index, count);
                return System.Array.binarySearch(this.Items, index, count, Bridge.rValue(item), comparer);
            },
            /*Spine.ExposedList$1.BinarySearch$2 end.*/

            /*Spine.ExposedList$1.Clear start.*/
            Clear: function (clearArray) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Clear", this ); }

                if (clearArray === void 0) { clearArray = true; }
                if (clearArray) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, 0, this.Items.length);
                }
                this.Count = 0;
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Clear end.*/

            /*Spine.ExposedList$1.Contains start.*/
            Contains: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Contains", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count) !== -1;
            },
            /*Spine.ExposedList$1.Contains end.*/

            /*Spine.ExposedList$1.ConvertAll start.*/
            ConvertAll: function (TOutput, converter) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ConvertAll", this ); }

                if (Bridge.staticEquals(converter, null)) {
                    throw new System.ArgumentNullException.$ctor1("converter");
                }
                var u = new (Spine.ExposedList$1(TOutput)).$ctor3(this.Count);
                u.Count = this.Count;
                var items = this.Items;
                var uItems = u.Items;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    uItems[i] = Bridge.rValue(converter(Bridge.rValue(items[i])));
                }
                return u;
            },
            /*Spine.ExposedList$1.ConvertAll end.*/

            /*Spine.ExposedList$1.CopyTo start.*/
            CopyTo: function (array) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo", this ); }

                System.Array.copy(this.Items, 0, array, 0, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo end.*/

            /*Spine.ExposedList$1.CopyTo$1 start.*/
            CopyTo$1: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$1", this ); }

                System.Array.copy(this.Items, 0, array, arrayIndex, this.Count);
            },
            /*Spine.ExposedList$1.CopyTo$1 end.*/

            /*Spine.ExposedList$1.CopyTo$2 start.*/
            CopyTo$2: function (index, array, arrayIndex, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CopyTo$2", this ); }

                this.CheckRange(index, count);
                System.Array.copy(this.Items, index, array, arrayIndex, count);
            },
            /*Spine.ExposedList$1.CopyTo$2 end.*/

            /*Spine.ExposedList$1.Exists start.*/
            Exists: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Exists", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match) !== -1;
            },
            /*Spine.ExposedList$1.Exists end.*/

            /*Spine.ExposedList$1.Find start.*/
            Find: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Find", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetIndex(0, this.Count, match);
                return (i !== -1) ? Bridge.rValue(this.Items[i]) : Bridge.getDefaultValue(T);
            },
            /*Spine.ExposedList$1.Find end.*/

            /*Spine.ExposedList$1.FindAll start.*/
            FindAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.FindAllList(match);
            },
            /*Spine.ExposedList$1.FindAll end.*/

            /*Spine.ExposedList$1.FindAllList start.*/
            FindAllList: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindAllList", this ); }

                var results = new (Spine.ExposedList$1(T)).ctor();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        results.Add(Bridge.rValue(this.Items[i]));
                    }
                }
                return results;
            },
            /*Spine.ExposedList$1.FindAllList end.*/

            /*Spine.ExposedList$1.FindIndex$2 start.*/
            FindIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindIndex$2 end.*/

            /*Spine.ExposedList$1.FindIndex$1 start.*/
            FindIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetIndex(startIndex, ((this.Count - startIndex) | 0), match);
            },
            /*Spine.ExposedList$1.FindIndex$1 end.*/

            /*Spine.ExposedList$1.FindIndex start.*/
            FindIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckRange(startIndex, count);
                return this.GetIndex(startIndex, count, match);
            },
            /*Spine.ExposedList$1.FindIndex end.*/

            /*Spine.ExposedList$1.GetIndex start.*/
            GetIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetIndex", this ); }

                var end = (startIndex + count) | 0;
                for (var i = startIndex; i < end; i = (i + 1) | 0) {
                    if (match(Bridge.rValue(this.Items[i]))) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.ExposedList$1.GetIndex end.*/

            /*Spine.ExposedList$1.FindLast start.*/
            FindLast: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLast", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = this.GetLastIndex(0, this.Count, match);
                return (i === -1) ? Bridge.getDefaultValue(T) : Bridge.rValue(this.Items[i]);
            },
            /*Spine.ExposedList$1.FindLast end.*/

            /*Spine.ExposedList$1.FindLastIndex$2 start.*/
            FindLastIndex$2: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$2", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                return this.GetLastIndex(0, this.Count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex$2 end.*/

            /*Spine.ExposedList$1.FindLastIndex$1 start.*/
            FindLastIndex$1: function (startIndex, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex$1", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                this.CheckIndex(startIndex);
                return this.GetLastIndex(0, ((startIndex + 1) | 0), match);
            },
            /*Spine.ExposedList$1.FindLastIndex$1 end.*/

            /*Spine.ExposedList$1.FindLastIndex start.*/
            FindLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#FindLastIndex", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var start = (((startIndex - count) | 0) + 1) | 0;
                this.CheckRange(start, count);
                return this.GetLastIndex(start, count, match);
            },
            /*Spine.ExposedList$1.FindLastIndex end.*/

            /*Spine.ExposedList$1.GetLastIndex start.*/
            GetLastIndex: function (startIndex, count, match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetLastIndex", this ); }

                var i = (startIndex + count) | 0;
                while (i !== startIndex) {
                    if (match(Bridge.rValue(this.Items[((i = (i - 1) | 0))]))) {
                        return i;
                    }
                }
                return -1;
            },
            /*Spine.ExposedList$1.GetLastIndex end.*/

            /*Spine.ExposedList$1.ForEach start.*/
            ForEach: function (action) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ForEach", this ); }

                if (Bridge.staticEquals(action, null)) {
                    throw new System.ArgumentNullException.$ctor1("action");
                }
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    action(Bridge.rValue(this.Items[i]));
                }
            },
            /*Spine.ExposedList$1.ForEach end.*/

            /*Spine.ExposedList$1.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetEnumerator", this ); }

                return new (Spine.ExposedList$1.Enumerator(T)).$ctor1(this);
            },
            /*Spine.ExposedList$1.GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator start.*/
            System$Collections$Generic$IEnumerable$1$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$Generic$IEnumerable$1$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$Generic$IEnumerable$1$GetEnumerator end.*/

            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator().$clone();
            },
            /*Spine.ExposedList$1.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.ExposedList$1.GetRange start.*/
            GetRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#GetRange", this ); }

                this.CheckRange(index, count);
                var tmpArray = System.Array.init(count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, index, tmpArray, 0, count);
                return new (Spine.ExposedList$1(T)).$ctor1(tmpArray, count);
            },
            /*Spine.ExposedList$1.GetRange end.*/

            /*Spine.ExposedList$1.IndexOf start.*/
            IndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf", this ); }

                return System.Array.indexOfT(this.Items, Bridge.rValue(item), 0, this.Count);
            },
            /*Spine.ExposedList$1.IndexOf end.*/

            /*Spine.ExposedList$1.IndexOf$1 start.*/
            IndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, ((this.Count - index) | 0));
            },
            /*Spine.ExposedList$1.IndexOf$1 end.*/

            /*Spine.ExposedList$1.IndexOf$2 start.*/
            IndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#IndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("count");
                }
                if ((((((index + count) | 0))) >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index and count exceed length of list");
                }
                return System.Array.indexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.IndexOf$2 end.*/

            /*Spine.ExposedList$1.Shift start.*/
            Shift: function (start, delta) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Shift", this ); }

                if (delta < 0) {
                    start = (start - delta) | 0;
                }
                if (start < this.Count) {
                    System.Array.copy(this.Items, start, this.Items, ((start + delta) | 0), ((this.Count - start) | 0));
                }
                this.Count = (this.Count + delta) | 0;
                if (delta < 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, ((-delta) | 0));
                }
            },
            /*Spine.ExposedList$1.Shift end.*/

            /*Spine.ExposedList$1.CheckIndex start.*/
            CheckIndex: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckIndex", this ); }

                if (index < 0 || (index >>> 0) > (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
            },
            /*Spine.ExposedList$1.CheckIndex end.*/

            /*Spine.ExposedList$1.Insert start.*/
            Insert: function (index, item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Insert", this ); }

                this.CheckIndex(index);
                if (this.Count === this.Items.length) {
                    this.GrowIfNeeded(1);
                }
                this.Shift(index, 1);
                this.Items[index] = Bridge.rValue(item);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Insert end.*/

            /*Spine.ExposedList$1.CheckCollection start.*/
            CheckCollection: function (collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#CheckCollection", this ); }

                if (collection == null) {
                    throw new System.ArgumentNullException.$ctor1("collection");
                }
            },
            /*Spine.ExposedList$1.CheckCollection end.*/

            /*Spine.ExposedList$1.InsertRange start.*/
            InsertRange: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertRange", this ); }

                this.CheckCollection(collection);
                this.CheckIndex(index);
                if (Bridge.referenceEquals(collection, this)) {
                    var buffer = System.Array.init(this.Count, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.CopyTo$1(buffer, 0);
                    this.GrowIfNeeded(this.Count);
                    this.Shift(index, buffer.length);
                    System.Array.copy(buffer, 0, this.Items, index, buffer.length);
                } else {
                    var c;
                    if (((c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T)))) != null) {
                        this.InsertCollection(index, c);
                    } else {
                        this.InsertEnumeration(index, collection);
                    }
                }
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.InsertRange end.*/

            /*Spine.ExposedList$1.InsertCollection start.*/
            InsertCollection: function (index, collection) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertCollection", this ); }

                var collectionCount = System.Array.getCount(collection, T);
                this.GrowIfNeeded(collectionCount);
                this.Shift(index, collectionCount);
                System.Array.copyTo(collection, this.Items, index, T);
            },
            /*Spine.ExposedList$1.InsertCollection end.*/

            /*Spine.ExposedList$1.InsertEnumeration start.*/
            InsertEnumeration: function (index, enumerable) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#InsertEnumeration", this ); }

                var $t;
                $t = Bridge.getEnumerator(enumerable, T);
                try {
                    while ($t.moveNext()) {
                        var t = Bridge.rValue($t.Current);
                        this.Insert(Bridge.identity(index, ((index = (index + 1) | 0))), Bridge.rValue(t));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.ExposedList$1.InsertEnumeration end.*/

            /*Spine.ExposedList$1.LastIndexOf start.*/
            LastIndexOf: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf", this ); }

                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), ((this.Count - 1) | 0), this.Count);
            },
            /*Spine.ExposedList$1.LastIndexOf end.*/

            /*Spine.ExposedList$1.LastIndexOf$1 start.*/
            LastIndexOf$1: function (item, index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$1", this ); }

                this.CheckIndex(index);
                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, ((index + 1) | 0));
            },
            /*Spine.ExposedList$1.LastIndexOf$1 end.*/

            /*Spine.ExposedList$1.LastIndexOf$2 start.*/
            LastIndexOf$2: function (item, index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#LastIndexOf$2", this ); }

                if (index < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("index", Bridge.box(index, System.Int32), "index is negative");
                }
                if (count < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is negative");
                }
                if (((((index - count) | 0) + 1) | 0) < 0) {
                    throw new System.ArgumentOutOfRangeException.$ctor3("count", Bridge.box(count, System.Int32), "count is too large");
                }
                return System.Array.lastIndexOfT(this.Items, Bridge.rValue(item), index, count);
            },
            /*Spine.ExposedList$1.LastIndexOf$2 end.*/

            /*Spine.ExposedList$1.Remove start.*/
            Remove: function (item) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Remove", this ); }

                var loc = this.IndexOf(Bridge.rValue(item));
                if (loc !== -1) {
                    this.RemoveAt(loc);
                }
                return loc !== -1;
            },
            /*Spine.ExposedList$1.Remove end.*/

            /*Spine.ExposedList$1.RemoveAll start.*/
            RemoveAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                var i = 0;
                var j = 0;
                for (i = 0; i < this.Count && !match(Bridge.rValue(this.Items[i])); i = (i + 1) | 0) {
                }
                if (i === this.Count) {
                    return 0;
                }
                this.version = (this.version + 1) | 0;
                for (j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[j]))) {
                        this.Items[Bridge.identity(i, ((i = (i + 1) | 0)))] = Bridge.rValue(this.Items[j]);
                    }
                }
                if (((j - i) | 0) > 0) {
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, i, ((j - i) | 0));
                }
                this.Count = i;
                return ((j - i) | 0);
            },
            /*Spine.ExposedList$1.RemoveAll end.*/

            /*Spine.ExposedList$1.RemoveAt start.*/
            RemoveAt: function (index) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveAt", this ); }

                if (index < 0 || (index >>> 0) >= (this.Count >>> 0)) {
                    throw new System.ArgumentOutOfRangeException.$ctor1("index");
                }
                this.Shift(index, -1);
                System.Array.fill(this.Items, function () {
                    return Bridge.getDefaultValue(T);
                }, this.Count, 1);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.RemoveAt end.*/

            /*Spine.ExposedList$1.Pop start.*/
            Pop: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Pop", this ); }

                if (this.Count === 0) {
                    throw new System.InvalidOperationException.$ctor1("List is empty. Nothing to pop.");
                }
                var i = (this.Count - 1) | 0;
                var item = Bridge.rValue(this.Items[i]);
                this.Items[i] = Bridge.getDefaultValue(T);
                this.Count = (this.Count - 1) | 0;
                this.version = (this.version + 1) | 0;
                return Bridge.rValue(item);
            },
            /*Spine.ExposedList$1.Pop end.*/

            /*Spine.ExposedList$1.RemoveRange start.*/
            RemoveRange: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#RemoveRange", this ); }

                this.CheckRange(index, count);
                if (count > 0) {
                    this.Shift(index, ((-count) | 0));
                    System.Array.fill(this.Items, function () {
                        return Bridge.getDefaultValue(T);
                    }, this.Count, count);
                    this.version = (this.version + 1) | 0;
                }
            },
            /*Spine.ExposedList$1.RemoveRange end.*/

            /*Spine.ExposedList$1.Reverse start.*/
            Reverse: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse", this ); }

                System.Array.reverse(this.Items, 0, this.Count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse end.*/

            /*Spine.ExposedList$1.Reverse$1 start.*/
            Reverse$1: function (index, count) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Reverse$1", this ); }

                this.CheckRange(index, count);
                System.Array.reverse(this.Items, index, count);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Reverse$1 end.*/

            /*Spine.ExposedList$1.Sort start.*/
            Sort: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort", this ); }

                System.Array.sort(this.Items, 0, this.Count, new (System.Collections.Generic.Comparer$1(T))(System.Collections.Generic.Comparer$1.$default.fn));
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort end.*/

            /*Spine.ExposedList$1.Sort$1 start.*/
            Sort$1: function (comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$1", this ); }

                System.Array.sort(this.Items, 0, this.Count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$1 end.*/

            /*Spine.ExposedList$1.Sort$2 start.*/
            Sort$2: function (comparison) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$2", this ); }

                System.Array.sort(this.Items, comparison);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$2 end.*/

            /*Spine.ExposedList$1.Sort$3 start.*/
            Sort$3: function (index, count, comparer) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#Sort$3", this ); }

                this.CheckRange(index, count);
                System.Array.sort(this.Items, index, count, comparer);
                this.version = (this.version + 1) | 0;
            },
            /*Spine.ExposedList$1.Sort$3 end.*/

            /*Spine.ExposedList$1.ToArray start.*/
            ToArray: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#ToArray", this ); }

                var t = System.Array.init(this.Count, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                System.Array.copy(this.Items, 0, t, 0, this.Count);
                return t;
            },
            /*Spine.ExposedList$1.ToArray end.*/

            /*Spine.ExposedList$1.TrimExcess start.*/
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrimExcess", this ); }

                this.Capacity = this.Count;
            },
            /*Spine.ExposedList$1.TrimExcess end.*/

            /*Spine.ExposedList$1.TrueForAll start.*/
            TrueForAll: function (match) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1#TrueForAll", this ); }

                Spine.ExposedList$1(T).CheckMatch(match);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (!match(Bridge.rValue(this.Items[i]))) {
                        return false;
                    }
                }
                return true;
            },
            /*Spine.ExposedList$1.TrueForAll end.*/


        },
        overloads: {
            "AddRange(IEnumerable<T>)": "AddRange$1",
            "BinarySearch(T, IComparer<T>)": "BinarySearch$1",
            "BinarySearch(int, int, T, IComparer<T>)": "BinarySearch$2",
            "CopyTo(T[], int)": "CopyTo$1",
            "CopyTo(int, T[], int, int)": "CopyTo$2",
            "FindIndex(Predicate<T>)": "FindIndex$2",
            "FindIndex(int, Predicate<T>)": "FindIndex$1",
            "FindLastIndex(Predicate<T>)": "FindLastIndex$2",
            "FindLastIndex(int, Predicate<T>)": "FindLastIndex$1",
            "IndexOf(T, int)": "IndexOf$1",
            "IndexOf(T, int, int)": "IndexOf$2",
            "LastIndexOf(T, int)": "LastIndexOf$1",
            "LastIndexOf(T, int, int)": "LastIndexOf$2",
            "Reverse(int, int)": "Reverse$1",
            "Sort(IComparer<T>)": "Sort$1",
            "Sort(Comparison<T>)": "Sort$2",
            "Sort(int, int, IComparer<T>)": "Sort$3"
        }
    }; });
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    Bridge.define("Spine.ExposedList$1.Enumerator", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator,System.IDisposable],
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getDefaultValue", this ); }
 return new (Spine.ExposedList$1.Enumerator(T))(); }
            }
        },
        fields: {
            l: null,
            next: 0,
            ver: 0,
            current: Bridge.getDefaultValue(T)
        },
        props: {
            Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Current#get", this ); }

                    return Bridge.rValue(this.current);
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$Current#get", this ); }

                    this.VerifyState();
                    if (this.next <= 0) {
                        throw new System.InvalidOperationException.ctor();
                    }
                    return this.current;
                }
            }
        },
        alias: [
            "Current", ["System$Collections$Generic$IEnumerator$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1"],
            "Dispose", "System$IDisposable$Dispose",
            "moveNext", "System$Collections$IEnumerator$moveNext"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#init", this ); }

                this.current = Bridge.getDefaultValue(T);
            },
            $ctor1: function (l) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$ctor1", this ); }

                this.$initialize();
                (Bridge.getDefaultValue(Spine.ExposedList$1.Enumerator(T))).$clone(this);
                this.l = l;
                this.ver = l.version;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.ExposedList$1+Enumerator.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#Dispose", this ); }

                this.l = null;
            },
            /*Spine.ExposedList$1+Enumerator.Dispose end.*/

            /*Spine.ExposedList$1+Enumerator.VerifyState start.*/
            VerifyState: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#VerifyState", this ); }

                if (this.l == null) {
                    throw new System.ObjectDisposedException.$ctor1(Bridge.Reflection.getTypeFullName(Spine.ExposedList$1.Enumerator(T)));
                }
                if (this.ver !== this.l.version) {
                    throw new System.InvalidOperationException.$ctor1("Collection was modified; enumeration operation may not execute.");
                }
            },
            /*Spine.ExposedList$1+Enumerator.VerifyState end.*/

            /*Spine.ExposedList$1+Enumerator.moveNext start.*/
            moveNext: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#moveNext", this ); }

                var $t;
                this.VerifyState();
                if (this.next < 0) {
                    return false;
                }
                if (this.next < this.l.Count) {
                    this.current = Bridge.rValue(($t = this.l.Items)[Bridge.identity(this.next, ((this.next = (this.next + 1) | 0)))]);
                    return true;
                }
                this.next = -1;
                return false;
            },
            /*Spine.ExposedList$1+Enumerator.moveNext end.*/

            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#System$Collections$IEnumerator$reset", this ); }

                this.VerifyState();
                this.next = 0;
            },
            /*Spine.ExposedList$1+Enumerator.System$Collections$IEnumerator$reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#getHashCode", this ); }

                var h = Bridge.addHash([3788985113, this.l, this.next, this.ver, this.current]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#equals", this ); }

                if (!Bridge.is(o, Spine.ExposedList$1.Enumerator(T))) {
                    return false;
                }
                return Bridge.equals(this.l, o.l) && Bridge.equals(this.next, o.next) && Bridge.equals(this.ver, o.ver) && Bridge.equals(this.current, o.current);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.ExposedList$1.Enumerator#$clone", this ); }

                var s = to || new (Spine.ExposedList$1.Enumerator(T))();
                s.l = this.l;
                s.next = this.next;
                s.ver = this.ver;
                s.current = Bridge.rValue(this.current);
                return s;
            }
        },
        overloads: {
            "MoveNext()": "moveNext"
        }
    }; });
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.Format start.*/
    Bridge.define("Spine.Format", {
        $kind: 6,
        statics: {
            fields: {
                Alpha: 0,
                Intensity: 1,
                LuminanceAlpha: 2,
                RGB565: 3,
                RGBA4444: 4,
                RGB888: 5,
                RGBA8888: 6
            }
        }
    });
    /*Spine.Format end.*/

    /*Spine.HashSetExtensions start.*/
    Bridge.define("Spine.HashSetExtensions", {
        statics: {
            methods: {
                /*Spine.HashSetExtensions.AddAll:static start.*/
                AddAll: function (T, set, addSet) {
if ( TRACE ) { TRACE( "Spine.HashSetExtensions#AddAll", this ); }

                    var anyItemAdded = false;
                    var i = 0;
                    for (var j = addSet.length; i < j; i = (i + 1) | 0) {
                        var item = Bridge.rValue(addSet[i]);
                        anyItemAdded = !!(anyItemAdded | set.add(Bridge.rValue(item)));
                    }
                    return anyItemAdded;
                },
                /*Spine.HashSetExtensions.AddAll:static end.*/


            }
        }
    });
    /*Spine.HashSetExtensions end.*/

    /*Spine.IBoneTimeline start.*/
    Bridge.define("Spine.IBoneTimeline", {
        $kind: 3
    });
    /*Spine.IBoneTimeline end.*/

    /*Spine.IHasTextureRegion start.*/
    Bridge.define("Spine.IHasTextureRegion", {
        $kind: 3
    });
    /*Spine.IHasTextureRegion end.*/

    /*Spine.IInterpolation start.*/
    Bridge.define("Spine.IInterpolation", {
        statics: {
            fields: {
                Pow2: null,
                Pow2Out: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IInterpolation#init", this ); }

                    this.Pow2 = new Spine.Pow(2.0);
                    this.Pow2Out = new Spine.PowOut(2.0);
                }
            }
        },
        methods: {
            /*Spine.IInterpolation.Apply start.*/
            Apply: function (start, end, a) {
if ( TRACE ) { TRACE( "Spine.IInterpolation#Apply", this ); }

                return start + (end - start) * this.Apply$1(a);
            },
            /*Spine.IInterpolation.Apply end.*/


        }
    });
    /*Spine.IInterpolation end.*/

    /*Spine.Json start.*/
    Bridge.define("Spine.Json", {
        statics: {
            methods: {
                /*Spine.Json.Deserialize:static start.*/
                Deserialize: function (text) {
if ( TRACE ) { TRACE( "Spine.Json#Deserialize", this ); }

                    var parser = new SharpJson.JsonDecoder();
                    parser.parseNumbersAsFloat = true;
                    return parser.Decode(text.ReadToEnd());
                },
                /*Spine.Json.Deserialize:static end.*/


            }
        }
    });
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    Bridge.define("Spine.MathUtils", {
        statics: {
            fields: {
                PI: 0,
                PI2: 0,
                RadDeg: 0,
                DegRad: 0,
                random: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.MathUtils#init", this ); }

                    this.PI = 3.14159274;
                    this.PI2 = 6.28318548;
                    this.RadDeg = 57.2957764;
                    this.DegRad = 0.0174532924;
                    this.random = new System.Random.ctor();
                }
            },
            methods: {
                /*Spine.MathUtils.Sin:static start.*/
                Sin: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Sin", this ); }

                    return Math.sin(radians);
                },
                /*Spine.MathUtils.Sin:static end.*/

                /*Spine.MathUtils.Cos:static start.*/
                Cos: function (radians) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Cos", this ); }

                    return Math.cos(radians);
                },
                /*Spine.MathUtils.Cos:static end.*/

                /*Spine.MathUtils.SinDeg:static start.*/
                SinDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#SinDeg", this ); }

                    return Math.sin(degrees * (0.0174532924));
                },
                /*Spine.MathUtils.SinDeg:static end.*/

                /*Spine.MathUtils.CosDeg:static start.*/
                CosDeg: function (degrees) {
if ( TRACE ) { TRACE( "Spine.MathUtils#CosDeg", this ); }

                    return Math.cos(degrees * (0.0174532924));
                },
                /*Spine.MathUtils.CosDeg:static end.*/

                /*Spine.MathUtils.Atan2:static start.*/
                Atan2: function (y, x) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Atan2", this ); }

                    return Math.atan2(y, x);
                },
                /*Spine.MathUtils.Atan2:static end.*/

                /*Spine.MathUtils.Clamp:static start.*/
                Clamp: function (value, min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#Clamp", this ); }

                    if (value < min) {
                        return min;
                    }
                    if (value > max) {
                        return max;
                    }
                    return value;
                },
                /*Spine.MathUtils.Clamp:static end.*/

                /*Spine.MathUtils.RandomTriangle:static start.*/
                RandomTriangle: function (min, max) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle", this ); }

                    return Spine.MathUtils.RandomTriangle$1(min, max, (min + max) * 0.5);
                },
                /*Spine.MathUtils.RandomTriangle:static end.*/

                /*Spine.MathUtils.RandomTriangle$1:static start.*/
                RandomTriangle$1: function (min, max, mode) {
if ( TRACE ) { TRACE( "Spine.MathUtils#RandomTriangle$1", this ); }

                    var u = Spine.MathUtils.random.NextDouble();
                    var d = max - min;
                    if (u <= (mode - min) / d) {
                        return min + Math.sqrt(u * d * (mode - min));
                    }
                    return max - Math.sqrt((1.0 - u) * d * (max - mode));
                },
                /*Spine.MathUtils.RandomTriangle$1:static end.*/


            }
        }
    });
    /*Spine.MathUtils end.*/

    /*Spine.MixBlend start.*/
    Bridge.define("Spine.MixBlend", {
        $kind: 6,
        statics: {
            fields: {
                Setup: 0,
                First: 1,
                Replace: 2,
                Add: 3
            }
        }
    });
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    Bridge.define("Spine.MixDirection", {
        $kind: 6,
        statics: {
            fields: {
                In: 0,
                Out: 1
            }
        }
    });
    /*Spine.MixDirection end.*/

    /*Spine.Polygon start.*/
    Bridge.define("Spine.Polygon", {
        fields: {
            Vertices: null,
            Count: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Polygon#ctor", this ); }

                this.$initialize();
                this.Vertices = System.Array.init(16, 0, System.Single);
            }
        }
    });
    /*Spine.Polygon end.*/

    /*Spine.Pool$1 start.*/
    Bridge.define("Spine.Pool$1", function (T) { return {
        fields: {
            max: 0,
            freeObjects: null,
            Peak: 0
        },
        props: {
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Count#get", this ); }

                    return this.freeObjects.Count;
                }
            }
        },
        ctors: {
            ctor: function (initialCapacity, max) {
if ( TRACE ) { TRACE( "Spine.Pool$1#ctor", this ); }

                if (initialCapacity === void 0) { initialCapacity = 16; }
                if (max === void 0) { max = 2147483647; }

                this.$initialize();
                this.freeObjects = new (System.Collections.Generic.Stack$1(T)).$ctor2(initialCapacity);
                this.max = max;
            }
        },
        methods: {
            /*Spine.Pool$1.Obtain start.*/
            Obtain: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Obtain", this ); }

                return (this.freeObjects.Count === 0) ? Bridge.createInstance(T) : this.freeObjects.Pop();
            },
            /*Spine.Pool$1.Obtain end.*/

            /*Spine.Pool$1.Free start.*/
            Free: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Free", this ); }

                if (Bridge.rValue(obj) == null) {
                    throw new System.ArgumentNullException.$ctor3("obj", "obj cannot be null");
                }
                if (this.freeObjects.Count < this.max) {
                    this.freeObjects.Push(Bridge.rValue(obj));
                    this.Peak = Math.max(this.Peak, this.freeObjects.Count);
                }
                this.Reset(Bridge.rValue(obj));
            },
            /*Spine.Pool$1.Free end.*/

            /*Spine.Pool$1.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Pool$1#Clear", this ); }

                this.freeObjects.Clear();
            },
            /*Spine.Pool$1.Clear end.*/

            /*Spine.Pool$1.Reset start.*/
            Reset: function (obj) {
if ( TRACE ) { TRACE( "Spine.Pool$1#Reset", this ); }

                var poolable;
                if (((poolable = Bridge.as(Bridge.rValue(obj), Spine.Pool$1.IPoolable(T)))) != null) {
                    poolable["Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset"]();
                }
            },
            /*Spine.Pool$1.Reset end.*/


        }
    }; });
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    Bridge.definei("Spine.Pool$1.IPoolable", function (T) { return {
        $kind: 1003
    }; });
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.PositionMode start.*/
    Bridge.define("Spine.PositionMode", {
        $kind: 6,
        statics: {
            fields: {
                Fixed: 0,
                Percent: 1
            }
        }
    });
    /*Spine.PositionMode end.*/

    /*Spine.Property start.*/
    Bridge.define("Spine.Property", {
        $kind: 6,
        statics: {
            fields: {
                Rotate: 0,
                X: 1,
                Y: 2,
                ScaleX: 3,
                ScaleY: 4,
                ShearX: 5,
                ShearY: 6,
                RGB: 7,
                Alpha: 8,
                RGB2: 9,
                Attachment: 10,
                Deform: 11,
                Event: 12,
                DrawOrder: 13,
                IkConstraint: 14,
                TransformConstraint: 15,
                PathConstraintPosition: 16,
                PathConstraintSpacing: 17,
                PathConstraintMix: 18,
                Sequence: 19
            }
        }
    });
    /*Spine.Property end.*/

    /*Spine.RotateMode start.*/
    Bridge.define("Spine.RotateMode", {
        $kind: 6,
        statics: {
            fields: {
                Tangent: 0,
                Chain: 1,
                ChainScale: 2
            }
        }
    });
    /*Spine.RotateMode end.*/

    /*Spine.Sequence start.*/
    Bridge.define("Spine.Sequence", {
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            regions: null,
            start: 0,
            digits: 0,
            setupIndex: 0
        },
        props: {
            Start: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Start#get", this ); }

                    return this.start;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#Start#set", this ); }

                    this.start = value;
                }
            },
            Digits: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Digits#get", this ); }

                    return this.digits;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#Digits#set", this ); }

                    this.digits = value;
                }
            },
            SetupIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#SetupIndex#get", this ); }

                    return this.setupIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Sequence#SetupIndex#set", this ); }

                    this.setupIndex = value;
                }
            },
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Regions#get", this ); }

                    return this.regions;
                }
            },
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Sequence#Id#get", this ); }

                    return this.id;
                }
            }
        },
        ctors: {
            $ctor1: function (count) {
if ( TRACE ) { TRACE( "Spine.Sequence#$ctor1", this ); }

                var $t;
                this.$initialize();
                Spine.Sequence.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.Sequence.nextID, (($t = (Spine.Sequence.nextID + 1) | 0, Spine.Sequence.nextID = $t, $t)));
                }
                this.regions = System.Array.init(count, null, Spine.TextureRegion);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.Sequence#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Sequence.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.Sequence.nextID, (($t = (Spine.Sequence.nextID + 1) | 0, Spine.Sequence.nextID = $t, $t)));
                }
                this.regions = System.Array.init(other.regions.length, null, Spine.TextureRegion);
                System.Array.copy(other.regions, 0, this.regions, 0, this.regions.length);
                this.start = other.start;
                this.digits = other.digits;
                this.setupIndex = other.setupIndex;
            }
        },
        methods: {
            /*Spine.Sequence.Apply start.*/
            Apply: function (slot, attachment) {
if ( TRACE ) { TRACE( "Spine.Sequence#Apply", this ); }

                var index = slot.SequenceIndex;
                if (index === -1) {
                    index = this.setupIndex;
                }
                if (index >= this.regions.length) {
                    index = (this.regions.length - 1) | 0;
                }
                var region = this.regions[index];
                if (!Bridge.referenceEquals(attachment.Spine$IHasTextureRegion$Region, region)) {
                    attachment.Spine$IHasTextureRegion$Region = region;
                    attachment.Spine$IHasTextureRegion$UpdateRegion();
                }
            },
            /*Spine.Sequence.Apply end.*/

            /*Spine.Sequence.GetPath start.*/
            GetPath: function (basePath, index) {
if ( TRACE ) { TRACE( "Spine.Sequence#GetPath", this ); }

                var buffer = new System.Text.StringBuilder("", ((basePath.length + this.digits) | 0));
                buffer.append(basePath);
                var frame = Bridge.toString((((this.start + index) | 0)));
                for (var i = (this.digits - frame.length) | 0; i > 0; i = (i - 1) | 0) {
                    buffer.append(String.fromCharCode(48));
                }
                buffer.append(frame);
                return buffer.toString();
            },
            /*Spine.Sequence.GetPath end.*/


        }
    });
    /*Spine.Sequence end.*/

    /*Spine.SequenceMode start.*/
    Bridge.define("Spine.SequenceMode", {
        $kind: 6,
        statics: {
            fields: {
                Hold: 0,
                Once: 1,
                Loop: 2,
                Pingpong: 3,
                OnceReverse: 4,
                LoopReverse: 5,
                PingpongReverse: 6
            }
        }
    });
    /*Spine.SequenceMode end.*/

    /*Spine.Skeleton start.*/
    Bridge.define("Spine.Skeleton", {
        statics: {
            methods: {
                /*Spine.Skeleton.SortReset:static start.*/
                SortReset: function (bones) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortReset", this ); }

                    var bonesItems = bones.Items;
                    var i = 0;
                    for (var j = bones.Count; i < j; i = (i + 1) | 0) {
                        var bone = bonesItems[i];
                        if (bone.active) {
                            if (bone.sorted) {
                                Spine.Skeleton.SortReset(bone.children);
                            }
                            bone.sorted = false;
                        }
                    }
                },
                /*Spine.Skeleton.SortReset:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            slots: null,
            drawOrder: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            updateCache: null,
            skin: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            scaleX: 0,
            scaleY: 0,
            x: 0,
            y: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Data#get", this ); }

                    return this.data;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Bones#get", this ); }

                    return this.bones;
                }
            },
            UpdateCacheList: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCacheList#get", this ); }

                    return this.updateCache;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Slots#get", this ); }

                    return this.slots;
                }
            },
            DrawOrder: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#DrawOrder#get", this ); }

                    return this.drawOrder;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#IkConstraints#get", this ); }

                    return this.ikConstraints;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#PathConstraints#get", this ); }

                    return this.pathConstraints;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                }
            },
            Skin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#get", this ); }

                    return this.skin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Skin#set", this ); }

                    this.SetSkin(value);
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#A#set", this ); }

                    this.a = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#Y#set", this ); }

                    this.y = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#get", this ); }

                    return this.scaleY * ((!Spine.Bone.yDown) ? 1 : (-1));
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            FlipX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#get", this ); }

                    return this.scaleX < 0.0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipX#set", this ); }

                    this.scaleX = (value ? (-1.0) : 1.0);
                }
            },
            FlipY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#get", this ); }

                    return this.scaleY < 0.0;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FlipY#set", this ); }

                    this.scaleY = (value ? (-1.0) : 1.0);
                }
            },
            RootBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#RootBone#get", this ); }

                    var $t;
                    return (this.bones.Count === 0) ? null : ($t = this.bones.Items)[0];
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#init", this ); }

                this.updateCache = new (Spine.ExposedList$1(Spine.IUpdatable)).ctor();
                this.r = 1.0;
                this.g = 1.0;
                this.b = 1.0;
                this.a = 1.0;
                this.scaleX = 1.0;
                this.scaleY = 1.0;
            },
            $ctor1: function (data) {
if ( TRACE ) { TRACE( "Spine.Skeleton#$ctor1", this ); }

                var $t, $t1, $t2, $t3, $t4;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                this.data = data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                var bonesItems = this.bones.Items;
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        var bone2;
                        if (boneData.parent == null) {
                            bone2 = new Spine.Bone.$ctor1(boneData, this, null);
                        } else {
                            var parent = bonesItems[boneData.parent.index];
                            bone2 = new Spine.Bone.$ctor1(boneData, this, parent);
                            parent.children.Add(bone2);
                        }
                        this.bones.Add(bone2);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(data.slots.Count);
                $t1 = Bridge.getEnumerator(data.slots);
                try {
                    while ($t1.moveNext()) {
                        var slotData = $t1.Current;
                        var bone = bonesItems[slotData.boneData.index];
                        var slot = new Spine.Slot.$ctor1(slotData, bone);
                        this.slots.Add(slot);
                        this.drawOrder.Add(slot);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(data.ikConstraints.Count);
                $t2 = Bridge.getEnumerator(data.ikConstraints);
                try {
                    while ($t2.moveNext()) {
                        var ikConstraintData = $t2.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.$ctor1(ikConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(data.transformConstraints.Count);
                $t3 = Bridge.getEnumerator(data.transformConstraints);
                try {
                    while ($t3.moveNext()) {
                        var transformConstraintData = $t3.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.$ctor1(transformConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(data.pathConstraints.Count);
                $t4 = Bridge.getEnumerator(data.pathConstraints);
                try {
                    while ($t4.moveNext()) {
                        var pathConstraintData = $t4.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.$ctor1(pathConstraintData, this));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }
                this.UpdateCache();
            },
            ctor: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Skeleton#ctor", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6;
                this.$initialize();
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = skeleton.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(skeleton.bones.Count);
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone2 = $t.Current;
                        var newBone;
                        if (bone2.parent == null) {
                            newBone = new Spine.Bone.ctor(bone2, this, null);
                        } else {
                            var parent = ($t1 = this.bones.Items)[bone2.parent.data.index];
                            newBone = new Spine.Bone.ctor(bone2, this, parent);
                            parent.children.Add(newBone);
                        }
                        this.bones.Add(newBone);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.slots = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(skeleton.slots.Count);
                var bonesItems = this.bones.Items;
                $t2 = Bridge.getEnumerator(skeleton.slots);
                try {
                    while ($t2.moveNext()) {
                        var slot2 = $t2.Current;
                        var bone = bonesItems[slot2.bone.data.index];
                        this.slots.Add(new Spine.Slot.ctor(slot2, bone));
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                this.drawOrder = new (Spine.ExposedList$1(Spine.Slot)).$ctor3(this.slots.Count);
                var slotsItems = this.slots.Items;
                $t3 = Bridge.getEnumerator(skeleton.drawOrder);
                try {
                    while ($t3.moveNext()) {
                        var slot = $t3.Current;
                        this.drawOrder.Add(slotsItems[slot.data.index]);
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraint)).$ctor3(skeleton.ikConstraints.Count);
                $t4 = Bridge.getEnumerator(skeleton.ikConstraints);
                try {
                    while ($t4.moveNext()) {
                        var ikConstraint = $t4.Current;
                        this.ikConstraints.Add(new Spine.IkConstraint.ctor(ikConstraint, this));
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraint)).$ctor3(skeleton.transformConstraints.Count);
                $t5 = Bridge.getEnumerator(skeleton.transformConstraints);
                try {
                    while ($t5.moveNext()) {
                        var transformConstraint = $t5.Current;
                        this.transformConstraints.Add(new Spine.TransformConstraint.ctor(transformConstraint, this));
                    }
                } finally {
                    if (Bridge.is($t5, System.IDisposable)) {
                        $t5.System$IDisposable$Dispose();
                    }
                }
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraint)).$ctor3(skeleton.pathConstraints.Count);
                $t6 = Bridge.getEnumerator(skeleton.pathConstraints);
                try {
                    while ($t6.moveNext()) {
                        var pathConstraint = $t6.Current;
                        this.pathConstraints.Add(new Spine.PathConstraint.ctor(pathConstraint, this));
                    }
                } finally {
                    if (Bridge.is($t6, System.IDisposable)) {
                        $t6.System$IDisposable$Dispose();
                    }
                }
                this.skin = skeleton.skin;
                this.r = skeleton.r;
                this.g = skeleton.g;
                this.b = skeleton.b;
                this.a = skeleton.a;
                this.scaleX = skeleton.scaleX;
                this.scaleY = skeleton.scaleY;
                this.UpdateCache();
            }
        },
        methods: {
            /*Spine.Skeleton.UpdateCache start.*/
            UpdateCache: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateCache", this ); }

                var updateCache = this.updateCache;
                updateCache.Clear();
                var boneCount = this.bones.Count;
                var bones = this.bones.Items;
                for (var l = 0; l < boneCount; l = (l + 1) | 0) {
                    var bone = bones[l];
                    bone.sorted = bone.data.skinRequired;
                    bone.active = !bone.sorted;
                }
                if (this.skin != null) {
                    var skinBones = this.skin.bones.Items;
                    var k = 0;
                    for (var m = this.skin.bones.Count; k < m; k = (k + 1) | 0) {
                        var bone2 = bones[skinBones[k].index];
                        do {
                            bone2.sorted = false;
                            bone2.active = true;
                            bone2 = bone2.parent;
                        } while (bone2 != null);
                    }
                }
                var ikCount = this.ikConstraints.Count;
                var transformCount = this.transformConstraints.Count;
                var pathCount = this.pathConstraints.Count;
                var ikConstraints = this.ikConstraints.Items;
                var transformConstraints = this.transformConstraints.Items;
                var pathConstraints = this.pathConstraints.Items;
                var constraintCount = (((ikCount + transformCount) | 0) + pathCount) | 0;
                for (var j = 0; j < constraintCount; j = (j + 1) | 0) {
                    var ii3 = 0;
                    while (true) {
                        if (ii3 < ikCount) {
                            var constraint = ikConstraints[ii3];
                            if (constraint.data.order === j) {
                                this.SortIkConstraint(constraint);
                                break;
                            }
                            ii3 = (ii3 + 1) | 0;
                            continue;
                        }
                        var ii2 = 0;
                        while (true) {
                            if (ii2 < transformCount) {
                                var constraint2 = transformConstraints[ii2];
                                if (constraint2.data.order === j) {
                                    this.SortTransformConstraint(constraint2);
                                    break;
                                }
                                ii2 = (ii2 + 1) | 0;
                                continue;
                            }
                            for (var ii = 0; ii < pathCount; ii = (ii + 1) | 0) {
                                var constraint3 = pathConstraints[ii];
                                if (constraint3.data.order === j) {
                                    this.SortPathConstraint(constraint3);
                                    break;
                                }
                            }
                            break;
                        }
                        break;
                    }
                }
                for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                    this.SortBone(bones[i]);
                }
            },
            /*Spine.Skeleton.UpdateCache end.*/

            /*Spine.Skeleton.SortIkConstraint start.*/
            SortIkConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortIkConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (constraint.active) {
                    var target = constraint.target;
                    this.SortBone(target);
                    var constrained = constraint.bones;
                    var parent = constrained.Items[0];
                    this.SortBone(parent);
                    if (constrained.Count === 1) {
                        this.updateCache.Add(constraint);
                        Spine.Skeleton.SortReset(parent.children);
                        return;
                    }
                    var child = constrained.Items[((constrained.Count - 1) | 0)];
                    this.SortBone(child);
                    this.updateCache.Add(constraint);
                    Spine.Skeleton.SortReset(parent.children);
                    child.sorted = true;
                }
            },
            /*Spine.Skeleton.SortIkConstraint end.*/

            /*Spine.Skeleton.SortTransformConstraint start.*/
            SortTransformConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortTransformConstraint", this ); }

                constraint.active = constraint.target.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (!constraint.active) {
                    return;
                }
                this.SortBone(constraint.target);
                var constrained = constraint.bones.Items;
                var boneCount = constraint.bones.Count;
                if (constraint.data.local) {
                    for (var l = 0; l < boneCount; l = (l + 1) | 0) {
                        var child = constrained[l];
                        this.SortBone(child.parent);
                        this.SortBone(child);
                    }
                } else {
                    for (var k = 0; k < boneCount; k = (k + 1) | 0) {
                        this.SortBone(constrained[k]);
                    }
                }
                this.updateCache.Add(constraint);
                for (var j = 0; j < boneCount; j = (j + 1) | 0) {
                    Spine.Skeleton.SortReset(constrained[j].children);
                }
                for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                    constrained[i].sorted = true;
                }
            },
            /*Spine.Skeleton.SortTransformConstraint end.*/

            /*Spine.Skeleton.SortPathConstraint start.*/
            SortPathConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraint", this ); }

                constraint.active = constraint.target.bone.active && (!constraint.data.skinRequired || (this.skin != null && this.skin.constraints.Contains(constraint.data)));
                if (constraint.active) {
                    var slot = constraint.target;
                    var slotIndex = slot.data.index;
                    var slotBone = slot.bone;
                    if (this.skin != null) {
                        this.SortPathConstraintAttachment$1(this.skin, slotIndex, slotBone);
                    }
                    if (this.data.defaultSkin != null && !Bridge.referenceEquals(this.data.defaultSkin, this.skin)) {
                        this.SortPathConstraintAttachment$1(this.data.defaultSkin, slotIndex, slotBone);
                    }
                    var attachment = slot.attachment;
                    if (Bridge.is(attachment, Spine.PathAttachment)) {
                        this.SortPathConstraintAttachment(attachment, slotBone);
                    }
                    var constrained = constraint.bones.Items;
                    var boneCount = constraint.bones.Count;
                    for (var k = 0; k < boneCount; k = (k + 1) | 0) {
                        this.SortBone(constrained[k]);
                    }
                    this.updateCache.Add(constraint);
                    for (var j = 0; j < boneCount; j = (j + 1) | 0) {
                        Spine.Skeleton.SortReset(constrained[j].children);
                    }
                    for (var i = 0; i < boneCount; i = (i + 1) | 0) {
                        constrained[i].sorted = true;
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraint end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment$1 start.*/
            SortPathConstraintAttachment$1: function (skin, slotIndex, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment$1", this ); }

                var $t;
                $t = Bridge.getEnumerator(skin.Attachments, Spine.Skin.SkinEntry);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        if (entry.SlotIndex === slotIndex) {
                            this.SortPathConstraintAttachment(entry.Attachment, slotBone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment$1 end.*/

            /*Spine.Skeleton.SortPathConstraintAttachment start.*/
            SortPathConstraintAttachment: function (attachment, slotBone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortPathConstraintAttachment", this ); }

                if (!(Bridge.is(attachment, Spine.PathAttachment))) {
                    return;
                }
                var pathBones = Bridge.cast(attachment, Spine.PathAttachment).bones;
                if (pathBones == null) {
                    this.SortBone(slotBone);
                    return;
                }
                var bones = this.bones.Items;
                var i = 0;
                var j = pathBones.length;
                while (i < j) {
                    var nn = pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))];
                    nn = (nn + i) | 0;
                    while (i < nn) {
                        this.SortBone(bones[pathBones[Bridge.identity(i, ((i = (i + 1) | 0)))]]);
                    }
                }
            },
            /*Spine.Skeleton.SortPathConstraintAttachment end.*/

            /*Spine.Skeleton.SortBone start.*/
            SortBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SortBone", this ); }

                if (!bone.sorted) {
                    var parent = bone.parent;
                    if (parent != null) {
                        this.SortBone(parent);
                    }
                    bone.sorted = true;
                    this.updateCache.Add(bone);
                }
            },
            /*Spine.Skeleton.SortBone end.*/

            /*Spine.Skeleton.UpdateWorldTransform start.*/
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform", this ); }

                var bones = this.bones.Items;
                var j = 0;
                for (var l = this.bones.Count; j < l; j = (j + 1) | 0) {
                    var bone = bones[j];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                }
                var updateCache = this.updateCache.Items;
                var i = 0;
                for (var k = this.updateCache.Count; i < k; i = (i + 1) | 0) {
                    updateCache[i].Spine$IUpdatable$Update();
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform end.*/

            /*Spine.Skeleton.UpdateWorldTransform$1 start.*/
            UpdateWorldTransform$1: function (parent) {
if ( TRACE ) { TRACE( "Spine.Skeleton#UpdateWorldTransform$1", this ); }

                if (parent == null) {
                    throw new System.ArgumentNullException.$ctor3("parent", "parent cannot be null.");
                }
                var rootBone = this.RootBone;
                var pa = parent.a;
                var pb = parent.b;
                var pc = parent.c;
                var pd = parent.d;
                rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;
                rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;
                var rotationY = rootBone.rotation + 90.0 + rootBone.shearY;
                var la = Spine.MathUtils.CosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var lb = Spine.MathUtils.CosDeg(rotationY) * rootBone.scaleY;
                var lc = Spine.MathUtils.SinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;
                var ld = Spine.MathUtils.SinDeg(rotationY) * rootBone.scaleY;
                rootBone.a = (pa * la + pb * lc) * this.scaleX;
                rootBone.b = (pa * lb + pb * ld) * this.scaleX;
                rootBone.c = (pc * la + pd * lc) * this.scaleY;
                rootBone.d = (pc * lb + pd * ld) * this.scaleY;
                var updateCache = this.updateCache.Items;
                var i = 0;
                for (var j = this.updateCache.Count; i < j; i = (i + 1) | 0) {
                    var updatable = updateCache[i];
                    if (!Bridge.referenceEquals(updatable, rootBone)) {
                        updatable.Spine$IUpdatable$Update();
                    }
                }
            },
            /*Spine.Skeleton.UpdateWorldTransform$1 end.*/

            /*Spine.Skeleton.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetToSetupPose", this ); }

                this.SetBonesToSetupPose();
                this.SetSlotsToSetupPose();
            },
            /*Spine.Skeleton.SetToSetupPose end.*/

            /*Spine.Skeleton.SetBonesToSetupPose start.*/
            SetBonesToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetBonesToSetupPose", this ); }

                var bones = this.bones.Items;
                var l = 0;
                for (var n3 = this.bones.Count; l < n3; l = (l + 1) | 0) {
                    bones[l].SetToSetupPose();
                }
                var ikConstraints = this.ikConstraints.Items;
                var k = 0;
                for (var n2 = this.ikConstraints.Count; k < n2; k = (k + 1) | 0) {
                    var constraint = ikConstraints[k];
                    var data = constraint.data;
                    constraint.mix = data.mix;
                    constraint.softness = data.softness;
                    constraint.bendDirection = data.bendDirection;
                    constraint.compress = data.compress;
                    constraint.stretch = data.stretch;
                }
                var transformConstraints = this.transformConstraints.Items;
                var j = 0;
                for (var n = this.transformConstraints.Count; j < n; j = (j + 1) | 0) {
                    var constraint2 = transformConstraints[j];
                    var data2 = constraint2.data;
                    constraint2.mixRotate = data2.mixRotate;
                    constraint2.mixX = data2.mixX;
                    constraint2.mixY = data2.mixY;
                    constraint2.mixScaleX = data2.mixScaleX;
                    constraint2.mixScaleY = data2.mixScaleY;
                    constraint2.mixShearY = data2.mixShearY;
                }
                var pathConstraints = this.pathConstraints.Items;
                var i = 0;
                for (var m = this.pathConstraints.Count; i < m; i = (i + 1) | 0) {
                    var constraint3 = pathConstraints[i];
                    var data3 = constraint3.data;
                    constraint3.position = data3.position;
                    constraint3.spacing = data3.spacing;
                    constraint3.mixRotate = data3.mixRotate;
                    constraint3.mixX = data3.mixX;
                    constraint3.mixY = data3.mixY;
                }
            },
            /*Spine.Skeleton.SetBonesToSetupPose end.*/

            /*Spine.Skeleton.SetSlotsToSetupPose start.*/
            SetSlotsToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSlotsToSetupPose", this ); }

                var slots = this.slots.Items;
                var j = this.slots.Count;
                System.Array.copy(slots, 0, this.drawOrder.Items, 0, j);
                for (var i = 0; i < j; i = (i + 1) | 0) {
                    slots[i].SetToSetupPose();
                }
            },
            /*Spine.Skeleton.SetSlotsToSetupPose end.*/

            /*Spine.Skeleton.FindBone start.*/
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (Bridge.referenceEquals(bone.data.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindBone end.*/

            /*Spine.Skeleton.FindSlot start.*/
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                var i = 0;
                for (var j = this.slots.Count; i < j; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (Bridge.referenceEquals(slot.data.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindSlot end.*/

            /*Spine.Skeleton.SetSkin$1 start.*/
            SetSkin$1: function (skinName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin$1", this ); }

                var foundSkin = this.data.FindSkin(skinName);
                if (foundSkin == null) {
                    throw new System.ArgumentException.$ctor3("Skin not found: " + (skinName || ""), "skinName");
                }
                this.SetSkin(foundSkin);
            },
            /*Spine.Skeleton.SetSkin$1 end.*/

            /*Spine.Skeleton.SetSkin start.*/
            SetSkin: function (newSkin) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetSkin", this ); }

                if (Bridge.referenceEquals(newSkin, this.skin)) {
                    return;
                }
                if (newSkin != null) {
                    if (this.skin != null) {
                        newSkin.AttachAll(this, this.skin);
                    } else {
                        var slots = this.slots.Items;
                        var i = 0;
                        for (var j = this.slots.Count; i < j; i = (i + 1) | 0) {
                            var slot = slots[i];
                            var name = slot.data.attachmentName;
                            if (name != null) {
                                var attachment = newSkin.GetAttachment(i, name);
                                if (attachment != null) {
                                    slot.Attachment = attachment;
                                }
                            }
                        }
                    }
                }
                this.skin = newSkin;
                this.UpdateCache();
            },
            /*Spine.Skeleton.SetSkin end.*/

            /*Spine.Skeleton.GetAttachment$1 start.*/
            GetAttachment$1: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment$1", this ); }

                return this.GetAttachment(this.data.FindSlot(slotName).index, attachmentName);
            },
            /*Spine.Skeleton.GetAttachment$1 end.*/

            /*Spine.Skeleton.GetAttachment start.*/
            GetAttachment: function (slotIndex, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetAttachment", this ); }

                if (attachmentName == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentName", "attachmentName cannot be null.");
                }
                if (this.skin != null) {
                    var attachment = this.skin.GetAttachment(slotIndex, attachmentName);
                    if (attachment != null) {
                        return attachment;
                    }
                }
                return (this.data.defaultSkin != null) ? this.data.defaultSkin.GetAttachment(slotIndex, attachmentName) : null;
            },
            /*Spine.Skeleton.GetAttachment end.*/

            /*Spine.Skeleton.SetAttachment start.*/
            SetAttachment: function (slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#SetAttachment", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                var i = 0;
                for (var j = this.slots.Count; i < j; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (!(Bridge.referenceEquals(slot.data.name, slotName))) {
                        continue;
                    }
                    var attachment = null;
                    if (attachmentName != null) {
                        attachment = this.GetAttachment(i, attachmentName);
                        if (attachment == null) {
                            throw new System.Exception("Attachment not found: " + (attachmentName || "") + ", for slot: " + (slotName || ""));
                        }
                    }
                    slot.Attachment = attachment;
                    return;
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.Skeleton.SetAttachment end.*/

            /*Spine.Skeleton.FindIkConstraint start.*/
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints.Items;
                var i = 0;
                for (var j = this.ikConstraints.Count; i < j; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints[i];
                    if (Bridge.referenceEquals(ikConstraint.data.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindIkConstraint end.*/

            /*Spine.Skeleton.FindTransformConstraint start.*/
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints.Items;
                var i = 0;
                for (var j = this.transformConstraints.Count; i < j; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints[i];
                    if (Bridge.referenceEquals(transformConstraint.data.Name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindTransformConstraint end.*/

            /*Spine.Skeleton.FindPathConstraint start.*/
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.Skeleton#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints.Items;
                var i = 0;
                for (var j = this.pathConstraints.Count; i < j; i = (i + 1) | 0) {
                    var constraint = pathConstraints[i];
                    if (System.String.equals(constraint.data.Name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.Skeleton.FindPathConstraint end.*/

            /*Spine.Skeleton.GetBounds start.*/
            GetBounds: function (x, y, width, height, vertexBuffer) {
if ( TRACE ) { TRACE( "Spine.Skeleton#GetBounds", this ); }

                var temp = vertexBuffer.v;
                temp = temp || System.Array.init(8, 0, System.Single);
                var drawOrder = this.drawOrder.Items;
                var minX = 2.14748365E+09;
                var minY = 2.14748365E+09;
                var maxX = -2.14748365E+09;
                var maxY = -2.14748365E+09;
                var i = 0;
                for (var j = this.drawOrder.Count; i < j; i = (i + 1) | 0) {
                    var slot = drawOrder[i];
                    if (!slot.bone.active) {
                        continue;
                    }
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.attachment;
                    var region;
                    if (((region = Bridge.as(attachment, Spine.RegionAttachment))) != null) {
                        verticesLength = 8;
                        vertices = temp;
                        if (vertices.length < 8) {
                            vertices = ((temp = System.Array.init(8, 0, System.Single)));
                        }
                        region.ComputeWorldVertices(slot, temp, 0);
                    } else {
                        var mesh;
                        if (((mesh = Bridge.as(attachment, Spine.MeshAttachment))) != null) {
                            verticesLength = mesh.WorldVerticesLength;
                            vertices = temp;
                            if (vertices.length < verticesLength) {
                                vertices = ((temp = System.Array.init(verticesLength, 0, System.Single)));
                            }

                            mesh.ComputeWorldVertices(slot, 0, verticesLength, temp, 0);
                        }
                    }
                    if (vertices != null) {
                        for (var ii = 0; ii < verticesLength; ii = (ii + 2) | 0) {
                            var vx = vertices[ii];
                            var vy = vertices[((ii + 1) | 0)];
                            minX = Math.min(minX, vx);
                            minY = Math.min(minY, vy);
                            maxX = Math.max(maxX, vx);
                            maxY = Math.max(maxY, vy);
                        }
                    }
                }
                x.v = minX;
                y.v = minY;
                width.v = maxX - minX;
                height.v = maxY - minY;
                vertexBuffer.v = temp;
            },
            /*Spine.Skeleton.GetBounds end.*/


        },
        overloads: {
            "SortPathConstraintAttachment(Skin, int, Bone)": "SortPathConstraintAttachment$1",
            "UpdateWorldTransform(Bone)": "UpdateWorldTransform$1",
            "SetSkin(string)": "SetSkin$1",
            "GetAttachment(string, string)": "GetAttachment$1"
        }
    });
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonLoader start.*/
    Bridge.define("Spine.SkeletonLoader", {
        fields: {
            attachmentLoader: null,
            scale: 0,
            linkedMeshes: null
        },
        props: {
            Scale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#Scale#get", this ); }

                    return this.scale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#Scale#set", this ); }

                    if (this.scale === 0.0) {
                        throw new System.ArgumentNullException.$ctor3("scale", "scale cannot be 0.");
                    }
                    this.scale = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#init", this ); }

                this.scale = 1.0;
                this.linkedMeshes = new (System.Collections.Generic.List$1(Spine.SkeletonLoader.LinkedMesh)).ctor();
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                this.attachmentLoader = new Spine.AtlasAttachmentLoader(atlasArray);
            },
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader#$ctor1", this ); }

                this.$initialize();
                if (attachmentLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("attachmentLoader", "attachmentLoader cannot be null.");
                }
                this.attachmentLoader = attachmentLoader;
            }
        }
    });
    /*Spine.SkeletonLoader end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    Bridge.define("Spine.SkeletonBinary.SkeletonInput", {
        $kind: 1002,
        fields: {
            chars: null,
            bytesBigEndian: null,
            strings: null,
            input: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#init", this ); }

                this.chars = System.Array.init(32, 0, System.Byte);
                this.bytesBigEndian = System.Array.init(8, 0, System.Byte);
            },
            ctor: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ctor", this ); }

                this.$initialize();
                this.input = input;
            }
        },
        methods: {
            /*Spine.SkeletonBinary+SkeletonInput.Read start.*/
            Read: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#Read", this ); }

                return this.input.ReadByte();
            },
            /*Spine.SkeletonBinary+SkeletonInput.Read end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadByte start.*/
            ReadByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadByte", this ); }

                return ((this.input.ReadByte()) & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte start.*/
            ReadSByte: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadSByte", this ); }

                var value = this.input.ReadByte();
                if (value === -1) {
                    throw new System.IO.EndOfStreamException.ctor();
                }
                return Bridge.Int.sxb(value & 255);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadSByte end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean start.*/
            ReadBoolean: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadBoolean", this ); }

                return this.input.ReadByte() !== 0;
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadBoolean end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat start.*/
            ReadFloat: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFloat", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                this.chars[3] = this.bytesBigEndian[0];
                this.chars[2] = this.bytesBigEndian[1];
                this.chars[1] = this.bytesBigEndian[2];
                this.chars[0] = this.bytesBigEndian[3];
                return System.BitConverter.toSingle(this.chars, 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFloat end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt start.*/
            ReadInt: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt", this ); }

                this.input.Read(this.bytesBigEndian, 0, 4);
                return (((((((this.bytesBigEndian[0] << 24) + (this.bytesBigEndian[1] << 16)) | 0) + (this.bytesBigEndian[2] << 8)) | 0) + this.bytesBigEndian[3]) | 0);
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 start.*/
            ReadInt$1: function (optimizePositive) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadInt$1", this ); }

                var b = this.input.ReadByte();
                var result = b & 127;
                if (((((b >>> 0) & 128) >>> 0)) !== 0) {
                    b = this.input.ReadByte();
                    result = result | ((b & 127) << 7);
                    if (((((b >>> 0) & 128) >>> 0)) !== 0) {
                        b = this.input.ReadByte();
                        result = result | ((b & 127) << 14);
                        if (((((b >>> 0) & 128) >>> 0)) !== 0) {
                            b = this.input.ReadByte();
                            result = result | ((b & 127) << 21);
                            if (((((b >>> 0) & 128) >>> 0)) !== 0) {
                                result = result | ((this.input.ReadByte() & 127) << 28);
                            }
                        }
                    }
                }
                return optimizePositive ? result : ((result >> 1) ^ ((-(result & 1)) | 0));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadInt$1 end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadLong start.*/
            ReadLong: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadLong", this ); }

                this.input.Read(this.bytesBigEndian, 0, 8);
                return System.Int64.clip64((System.UInt64(this.bytesBigEndian[0]).shl(56)).add((System.UInt64(this.bytesBigEndian[1]).shl(48))).add((System.UInt64(this.bytesBigEndian[2]).shl(40))).add((System.UInt64(this.bytesBigEndian[3]).shl(32))).add((System.UInt64(this.bytesBigEndian[4]).shl(24))).add((System.UInt64(this.bytesBigEndian[5]).shl(16))).add((System.UInt64(this.bytesBigEndian[6]).shl(8))).add(System.UInt64(this.bytesBigEndian[7])));
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadLong end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadString start.*/
            ReadString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadString", this ); }

                var byteCount = this.ReadInt$1(true);
                switch (byteCount) {
                    case 0: 
                        return null;
                    case 1: 
                        return "";
                    default: 
                        {
                            byteCount = (byteCount - 1) | 0;
                            var buffer = this.chars;
                            if (buffer.length < byteCount) {
                                buffer = System.Array.init(byteCount, 0, System.Byte);
                            }
                            this.ReadFully(buffer, 0, byteCount);
                            return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
                        }
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef start.*/
            ReadStringRef: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadStringRef", this ); }

                var index = this.ReadInt$1(true);
                return (index === 0) ? null : this.strings[((index - 1) | 0)];
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadStringRef end.*/

            /*Spine.SkeletonBinary+SkeletonInput.ReadFully start.*/
            ReadFully: function (buffer, offset, length) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#ReadFully", this ); }

                while (length > 0) {
                    var count = this.input.Read(buffer, offset, length);
                    if (count <= 0) {
                        throw new System.IO.EndOfStreamException.ctor();
                    }
                    offset = (offset + count) | 0;
                    length = (length - count) | 0;
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.ReadFully end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString start.*/
            GetVersionString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionString", this ); }

                try {
                    var initialPosition = this.input.Position;
                    this.ReadLong();
                    var stringPosition = this.input.Position;
                    var stringByteCount = this.ReadInt$1(true);
                    this.input.Position = stringPosition;
                    if (stringByteCount <= 13) {
                        var version = this.ReadString();
                        if (System.Char.isDigit(version.charCodeAt(0))) {
                            return version;
                        }
                    }
                    this.input.Position = initialPosition;
                    return this.GetVersionStringOld3X();
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    throw new System.ArgumentException.$ctor3(System.String.concat("Stream does not contain valid binary Skeleton Data.\n", ex), "input");
                }
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionString end.*/

            /*Spine.SkeletonBinary+SkeletonInput.GetVersionStringOld3X start.*/
            GetVersionStringOld3X: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary.SkeletonInput#GetVersionStringOld3X", this ); }

                var $t;
                var byteCount = this.ReadInt$1(true);
                if (byteCount > 1) {
                    ($t = this.input).Position = $t.Position.add(System.Int64(byteCount - 1));
                }
                byteCount = this.ReadInt$1(true);
                if (byteCount > 1 && byteCount <= 13) {
                    byteCount = (byteCount - 1) | 0;
                    var buffer = System.Array.init(byteCount, 0, System.Byte);
                    this.ReadFully(buffer, 0, byteCount);
                    return System.Text.Encoding.UTF8.GetString$1(buffer, 0, byteCount);
                }
                throw new System.ArgumentException.$ctor1("Stream does not contain valid binary Skeleton Data.");
            },
            /*Spine.SkeletonBinary+SkeletonInput.GetVersionStringOld3X end.*/


        },
        overloads: {
            "ReadInt(bool)": "ReadInt$1"
        }
    });
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    Bridge.define("Spine.SkeletonBinary.Vertices", {
        $kind: 1002,
        fields: {
            bones: null,
            vertices: null
        }
    });
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBounds start.*/
    Bridge.define("Spine.SkeletonBounds", {
        fields: {
            polygonPool: null,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            BoundingBoxes: null,
            Polygons: null
        },
        props: {
            MinX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#get", this ); }

                    return this.minX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinX#set", this ); }

                    this.minX = value;
                }
            },
            MinY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#get", this ); }

                    return this.minY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MinY#set", this ); }

                    this.minY = value;
                }
            },
            MaxX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#get", this ); }

                    return this.maxX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxX#set", this ); }

                    this.maxX = value;
                }
            },
            MaxY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#get", this ); }

                    return this.maxY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#MaxY#set", this ); }

                    this.maxY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Width#get", this ); }

                    return this.maxX - this.minX;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Height#get", this ); }

                    return this.maxY - this.minY;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#init", this ); }

                this.polygonPool = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ctor", this ); }

                this.$initialize();
                this.BoundingBoxes = new (Spine.ExposedList$1(Spine.BoundingBoxAttachment)).ctor();
                this.Polygons = new (Spine.ExposedList$1(Spine.Polygon)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonBounds.Update start.*/
            Update: function (skeleton, updateAabb) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#Update", this ); }

                var $t;
                var boundingBoxes = this.BoundingBoxes;
                var polygons = this.Polygons;
                var slots = skeleton.slots.Items;
                var slotCount = skeleton.slots.Count;
                boundingBoxes.Clear();
                var j = 0;
                for (var k = polygons.Count; j < k; j = (j + 1) | 0) {
                    this.polygonPool.Add(polygons.Items[j]);
                }
                polygons.Clear();
                for (var i = 0; i < slotCount; i = (i + 1) | 0) {
                    var slot = slots[i];
                    var boundingBox;
                    if (slot.bone.active && ((boundingBox = Bridge.as(slot.attachment, Spine.BoundingBoxAttachment))) != null) {
                        boundingBoxes.Add(boundingBox);
                        var polygon = null;
                        var poolCount = this.polygonPool.Count;
                        if (poolCount > 0) {
                            polygon = ($t = this.polygonPool.Items)[((poolCount - 1) | 0)];
                            this.polygonPool.RemoveAt(((poolCount - 1) | 0));
                        } else {
                            polygon = new Spine.Polygon();
                        }
                        polygons.Add(polygon);
                        var count = ((polygon.Count = boundingBox.worldVerticesLength, boundingBox.worldVerticesLength));
                        if (polygon.Vertices.length < count) {
                            polygon.Vertices = System.Array.init(count, 0, System.Single);
                        }
                        boundingBox.ComputeWorldVertices$1(slot, polygon.Vertices);
                    }
                }
                if (updateAabb) {
                    this.AabbCompute();
                    return;
                }
                this.minX = -2.14748365E+09;
                this.minY = -2.14748365E+09;
                this.maxX = 2.14748365E+09;
                this.maxY = 2.14748365E+09;
            },
            /*Spine.SkeletonBounds.Update end.*/

            /*Spine.SkeletonBounds.AabbCompute start.*/
            AabbCompute: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbCompute", this ); }

                var minX = 2.14748365E+09;
                var minY = 2.14748365E+09;
                var maxX = -2.14748365E+09;
                var maxY = -2.14748365E+09;
                var polygons = this.Polygons.Items;
                var i = 0;
                for (var j = this.Polygons.Count; i < j; i = (i + 1) | 0) {
                    var polygon = polygons[i];
                    var vertices = polygon.Vertices;
                    var ii = 0;
                    for (var nn = polygon.Count; ii < nn; ii = (ii + 2) | 0) {
                        var x = vertices[ii];
                        var y = vertices[((ii + 1) | 0)];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
                this.minX = minX;
                this.minY = minY;
                this.maxX = maxX;
                this.maxY = maxY;
            },
            /*Spine.SkeletonBounds.AabbCompute end.*/

            /*Spine.SkeletonBounds.AabbContainsPoint start.*/
            AabbContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbContainsPoint", this ); }

                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
            },
            /*Spine.SkeletonBounds.AabbContainsPoint end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSegment start.*/
            AabbIntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSegment", this ); }

                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
                if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {
                    return false;
                }
                var i = (y2 - y1) / (x2 - x1);
                var y3 = i * (minX - x1) + y1;
                if (y3 > minY && y3 < maxY) {
                    return true;
                }
                y3 = i * (maxX - x1) + y1;
                if (y3 > minY && y3 < maxY) {
                    return true;
                }
                var x3 = (minY - y1) / i + x1;
                if (x3 > minX && x3 < maxX) {
                    return true;
                }
                x3 = (maxY - y1) / i + x1;
                if (x3 > minX && x3 < maxX) {
                    return true;
                }
                return false;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSegment end.*/

            /*Spine.SkeletonBounds.AabbIntersectsSkeleton start.*/
            AabbIntersectsSkeleton: function (bounds) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#AabbIntersectsSkeleton", this ); }

                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
            },
            /*Spine.SkeletonBounds.AabbIntersectsSkeleton end.*/

            /*Spine.SkeletonBounds.ContainsPoint$1 start.*/
            ContainsPoint$1: function (polygon, x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;
                var prevIndex = (nn - 2) | 0;
                var inside = false;
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var vertexY = vertices[((ii + 1) | 0)];
                    var prevY = vertices[((prevIndex + 1) | 0)];
                    if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {
                        var vertexX = vertices[ii];
                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) {
                            inside = !inside;
                        }
                    }
                    prevIndex = ii;
                }
                return inside;
            },
            /*Spine.SkeletonBounds.ContainsPoint$1 end.*/

            /*Spine.SkeletonBounds.ContainsPoint start.*/
            ContainsPoint: function (x, y) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#ContainsPoint", this ); }

                var $t;
                var polygons = this.Polygons.Items;
                var i = 0;
                for (var j = this.Polygons.Count; i < j; i = (i + 1) | 0) {
                    if (this.ContainsPoint$1(polygons[i], x, y)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.ContainsPoint end.*/

            /*Spine.SkeletonBounds.IntersectsSegment start.*/
            IntersectsSegment: function (x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment", this ); }

                var $t;
                var polygons = this.Polygons.Items;
                var i = 0;
                for (var j = this.Polygons.Count; i < j; i = (i + 1) | 0) {
                    if (this.IntersectsSegment$1(polygons[i], x1, y1, x2, y2)) {
                        return ($t = this.BoundingBoxes.Items)[i];
                    }
                }
                return null;
            },
            /*Spine.SkeletonBounds.IntersectsSegment end.*/

            /*Spine.SkeletonBounds.IntersectsSegment$1 start.*/
            IntersectsSegment$1: function (polygon, x1, y1, x2, y2) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#IntersectsSegment$1", this ); }

                var vertices = polygon.Vertices;
                var nn = polygon.Count;
                var width12 = x1 - x2;
                var height12 = y1 - y2;
                var det1 = x1 * y2 - y1 * x2;
                var x4 = vertices[((nn - 2) | 0)];
                var y4 = vertices[((nn - 1) | 0)];
                for (var ii = 0; ii < nn; ii = (ii + 2) | 0) {
                    var x5 = vertices[ii];
                    var y5 = vertices[((ii + 1) | 0)];
                    var det2 = x4 * y5 - y4 * x5;
                    var width13 = x4 - x5;
                    var height13 = y4 - y5;
                    var det3 = width12 * height13 - height12 * width13;
                    var x3 = (det1 * width13 - width12 * det2) / det3;
                    if (((x3 >= x4 && x3 <= x5) || (x3 >= x5 && x3 <= x4)) && ((x3 >= x1 && x3 <= x2) || (x3 >= x2 && x3 <= x1))) {
                        var y3 = (det1 * height13 - height12 * det2) / det3;
                        if (((y3 >= y4 && y3 <= y5) || (y3 >= y5 && y3 <= y4)) && ((y3 >= y1 && y3 <= y2) || (y3 >= y2 && y3 <= y1))) {
                            return true;
                        }
                    }
                    x4 = x5;
                    y4 = y5;
                }
                return false;
            },
            /*Spine.SkeletonBounds.IntersectsSegment$1 end.*/

            /*Spine.SkeletonBounds.GetPolygon start.*/
            GetPolygon: function (attachment) {
if ( TRACE ) { TRACE( "Spine.SkeletonBounds#GetPolygon", this ); }

                var $t;
                var index = this.BoundingBoxes.IndexOf(attachment);
                return (index === -1) ? null : ($t = this.Polygons.Items)[index];
            },
            /*Spine.SkeletonBounds.GetPolygon end.*/


        },
        overloads: {
            "ContainsPoint(Polygon, float, float)": "ContainsPoint$1",
            "IntersectsSegment(Polygon, float, float, float, float)": "IntersectsSegment$1"
        }
    });
    /*Spine.SkeletonBounds end.*/

    /*Spine.SkeletonClipping start.*/
    Bridge.define("Spine.SkeletonClipping", {
        statics: {
            methods: {
                /*Spine.SkeletonClipping.MakeClockwise:static start.*/
                MakeClockwise: function (polygon) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#MakeClockwise", this ); }

                    var vertices = polygon.Items;
                    var verticeslength = polygon.Count;
                    var area = vertices[((verticeslength - 2) | 0)] * vertices[1] - vertices[0] * vertices[((verticeslength - 1) | 0)];
                    var j = 0;
                    for (var l = (verticeslength - 3) | 0; j < l; j = (j + 2) | 0) {
                        var p1x = vertices[j];
                        var p1y = vertices[((j + 1) | 0)];
                        var p2x = vertices[((j + 2) | 0)];
                        var p2y = vertices[((j + 3) | 0)];
                        area += p1x * p2y - p2x * p1y;
                    }
                    if (!(area < 0.0)) {
                        var i = 0;
                        var lastX = (verticeslength - 2) | 0;
                        for (var k = verticeslength >> 1; i < k; i = (i + 2) | 0) {
                            var x = vertices[i];
                            var y = vertices[((i + 1) | 0)];
                            var other = (lastX - i) | 0;
                            vertices[i] = vertices[other];
                            vertices[((i + 1) | 0)] = vertices[((other + 1) | 0)];
                            vertices[other] = x;
                            vertices[((other + 1) | 0)] = y;
                        }
                    }
                },
                /*Spine.SkeletonClipping.MakeClockwise:static end.*/


            }
        },
        fields: {
            triangulator: null,
            clippingPolygon: null,
            clipOutput: null,
            clippedVertices: null,
            clippedTriangles: null,
            clippedUVs: null,
            scratch: null,
            clipAttachment: null,
            clippingPolygons: null
        },
        props: {
            ClippedVertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedVertices#get", this ); }

                    return this.clippedVertices;
                }
            },
            ClippedTriangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedTriangles#get", this ); }

                    return this.clippedTriangles;
                }
            },
            ClippedUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClippedUVs#get", this ); }

                    return this.clippedUVs;
                }
            },
            IsClipping: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#IsClipping#get", this ); }

                    return this.clipAttachment != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#init", this ); }

                this.triangulator = new Spine.Triangulator();
                this.clippingPolygon = new (Spine.ExposedList$1(System.Single)).ctor();
                this.clipOutput = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedVertices = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.clippedTriangles = new (Spine.ExposedList$1(System.Int32)).$ctor3(128);
                this.clippedUVs = new (Spine.ExposedList$1(System.Single)).$ctor3(128);
                this.scratch = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonClipping.ClipStart start.*/
            ClipStart: function (slot, clip) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipStart", this ); }

                var $t;
                if (this.clipAttachment != null) {
                    return 0;
                }
                this.clipAttachment = clip;
                var i = clip.worldVerticesLength;
                var vertices = this.clippingPolygon.Resize(i).Items;
                clip.ComputeWorldVertices(slot, 0, i, vertices, 0);
                Spine.SkeletonClipping.MakeClockwise(this.clippingPolygon);
                this.clippingPolygons = this.triangulator.Decompose(this.clippingPolygon, this.triangulator.Triangulate(this.clippingPolygon));
                $t = Bridge.getEnumerator(this.clippingPolygons);
                try {
                    while ($t.moveNext()) {
                        var polygon = $t.Current;
                        Spine.SkeletonClipping.MakeClockwise(polygon);
                        polygon.Add(polygon.Items[0]);
                        polygon.Add(polygon.Items[1]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return this.clippingPolygons.Count;
            },
            /*Spine.SkeletonClipping.ClipStart end.*/

            /*Spine.SkeletonClipping.ClipEnd$1 start.*/
            ClipEnd$1: function (slot) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd$1", this ); }

                if (this.clipAttachment != null && Bridge.referenceEquals(this.clipAttachment.endSlot, slot.data)) {
                    this.ClipEnd();
                }
            },
            /*Spine.SkeletonClipping.ClipEnd$1 end.*/

            /*Spine.SkeletonClipping.ClipEnd start.*/
            ClipEnd: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipEnd", this ); }

                if (this.clipAttachment != null) {
                    this.clipAttachment = null;
                    this.clippingPolygons = null;
                    this.clippedVertices.Clear();
                    this.clippedTriangles.Clear();
                    this.clippingPolygon.Clear();
                }
            },
            /*Spine.SkeletonClipping.ClipEnd end.*/

            /*Spine.SkeletonClipping.ClipTriangles start.*/
            ClipTriangles: function (vertices, verticesLength, triangles, trianglesLength, uvs) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#ClipTriangles", this ); }

                var clipOutput = this.clipOutput;
                var clippedVertices = this.clippedVertices;
                var clippedTriangles = this.clippedTriangles;
                var polygons = this.clippingPolygons.Items;
                var polygonsCount = this.clippingPolygons.Count;
                var index = 0;
                clippedVertices.Clear();
                this.clippedUVs.Clear();
                clippedTriangles.Clear();
                for (var i = 0; i < trianglesLength; i = (i + 3) | 0) {
                    var vertexOffset = triangles[i] << 1;
                    var x2 = vertices[vertexOffset];
                    var y2 = vertices[((vertexOffset + 1) | 0)];
                    var u1 = uvs[vertexOffset];
                    var v1 = uvs[((vertexOffset + 1) | 0)];
                    vertexOffset = triangles[((i + 1) | 0)] << 1;
                    var x3 = vertices[vertexOffset];
                    var y3 = vertices[((vertexOffset + 1) | 0)];
                    var u2 = uvs[vertexOffset];
                    var v2 = uvs[((vertexOffset + 1) | 0)];
                    vertexOffset = triangles[((i + 2) | 0)] << 1;
                    var x4 = vertices[vertexOffset];
                    var y4 = vertices[((vertexOffset + 1) | 0)];
                    var u3 = uvs[vertexOffset];
                    var v3 = uvs[((vertexOffset + 1) | 0)];
                    for (var p = 0; p < polygonsCount; p = (p + 1) | 0) {
                        var s = clippedVertices.Count;
                        if (this.Clip(x2, y2, x3, y3, x4, y4, polygons[p], clipOutput)) {
                            var clipOutputLength = clipOutput.Count;
                            if (clipOutputLength !== 0) {
                                var d2 = y3 - y4;
                                var d3 = x4 - x3;
                                var d4 = x2 - x4;
                                var d5 = y4 - y2;
                                var d = 1.0 / (d2 * d4 + d3 * (y2 - y4));
                                var clipOutputCount = clipOutputLength >> 1;
                                var clipOutputItems = clipOutput.Items;
                                var clippedVerticesItems2 = clippedVertices.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                                var clippedUVsItems2 = this.clippedUVs.Resize(((s + Bridge.Int.mul(clipOutputCount, 2)) | 0)).Items;
                                for (var ii2 = 0; ii2 < clipOutputLength; ii2 = (ii2 + 2) | 0) {
                                    var x = clipOutputItems[ii2];
                                    var y = clipOutputItems[((ii2 + 1) | 0)];
                                    clippedVerticesItems2[s] = x;
                                    clippedVerticesItems2[((s + 1) | 0)] = y;
                                    var c2 = x - x4;
                                    var c3 = y - y4;
                                    var a = (d2 * c2 + d3 * c3) * d;
                                    var b = (d5 * c2 + d4 * c3) * d;
                                    var c = 1.0 - a - b;
                                    clippedUVsItems2[s] = u1 * a + u2 * b + u3 * c;
                                    clippedUVsItems2[((s + 1) | 0)] = v1 * a + v2 * b + v3 * c;
                                    s = (s + 2) | 0;
                                }
                                s = clippedTriangles.Count;
                                var clippedTrianglesItems2 = clippedTriangles.Resize(((s + Bridge.Int.mul(3, (((clipOutputCount - 2) | 0)))) | 0)).Items;
                                clipOutputCount = (clipOutputCount - 1) | 0;
                                for (var ii = 1; ii < clipOutputCount; ii = (ii + 1) | 0) {
                                    clippedTrianglesItems2[s] = index;
                                    clippedTrianglesItems2[((s + 1) | 0)] = (index + ii) | 0;
                                    clippedTrianglesItems2[((s + 2) | 0)] = (((index + ii) | 0) + 1) | 0;
                                    s = (s + 3) | 0;
                                }
                                index = (index + (((clipOutputCount + 1) | 0))) | 0;
                            }
                            continue;
                        }
                        var clippedVerticesItems = clippedVertices.Resize(((s + 6) | 0)).Items;
                        var clippedUVsItems = this.clippedUVs.Resize(((s + 6) | 0)).Items;
                        clippedVerticesItems[s] = x2;
                        clippedVerticesItems[((s + 1) | 0)] = y2;
                        clippedVerticesItems[((s + 2) | 0)] = x3;
                        clippedVerticesItems[((s + 3) | 0)] = y3;
                        clippedVerticesItems[((s + 4) | 0)] = x4;
                        clippedVerticesItems[((s + 5) | 0)] = y4;
                        clippedUVsItems[s] = u1;
                        clippedUVsItems[((s + 1) | 0)] = v1;
                        clippedUVsItems[((s + 2) | 0)] = u2;
                        clippedUVsItems[((s + 3) | 0)] = v2;
                        clippedUVsItems[((s + 4) | 0)] = u3;
                        clippedUVsItems[((s + 5) | 0)] = v3;
                        s = clippedTriangles.Count;
                        var clippedTrianglesItems = clippedTriangles.Resize(((s + 3) | 0)).Items;
                        clippedTrianglesItems[s] = index;
                        clippedTrianglesItems[((s + 1) | 0)] = (index + 1) | 0;
                        clippedTrianglesItems[((s + 2) | 0)] = (index + 2) | 0;
                        index = (index + 3) | 0;
                        break;
                    }
                }
            },
            /*Spine.SkeletonClipping.ClipTriangles end.*/

            /*Spine.SkeletonClipping.Clip start.*/
            Clip: function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
if ( TRACE ) { TRACE( "Spine.SkeletonClipping#Clip", this ); }

                var originalOutput = output;
                var clipped = false;
                var input = null;
                if (clippingArea.Count % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                } else {
                    input = this.scratch;
                }
                input.Clear();
                input.Add(x1);
                input.Add(y1);
                input.Add(x2);
                input.Add(y2);
                input.Add(x3);
                input.Add(y3);
                input.Add(x1);
                input.Add(y1);
                output.Clear();
                var clippingVertices = clippingArea.Items;
                var clippingVerticesLast = (clippingArea.Count - 4) | 0;
                var j = 0;
                while (true) {
                    var edgeX = clippingVertices[j];
                    var edgeY = clippingVertices[((j + 1) | 0)];
                    var edgeX2 = clippingVertices[((j + 2) | 0)];
                    var edgeY2 = clippingVertices[((j + 3) | 0)];
                    var deltaX = edgeX - edgeX2;
                    var deltaY = edgeY - edgeY2;
                    var inputVertices = input.Items;
                    var inputVerticesLength = (input.Count - 2) | 0;
                    var outputStart = output.Count;
                    for (var ii = 0; ii < inputVerticesLength; ii = (ii + 2) | 0) {
                        var inputX = inputVertices[ii];
                        var inputY = inputVertices[((ii + 1) | 0)];
                        var inputX2 = inputVertices[((ii + 2) | 0)];
                        var inputY2 = inputVertices[((ii + 3) | 0)];
                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0.0;
                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0.0) {
                            if (side2) {
                                output.Add(inputX2);
                                output.Add(inputY2);
                                continue;
                            }
                            var c = inputY2 - inputY;
                            var c3 = inputX2 - inputX;
                            var s2 = c * (edgeX2 - edgeX) - c3 * (edgeY2 - edgeY);
                            if (Math.abs(s2) > 1E-06) {
                                var ua2 = (c3 * (edgeY - inputY) - c * (edgeX - inputX)) / s2;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua2);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua2);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                        } else if (side2) {
                            var c0 = inputY2 - inputY;
                            var c2 = inputX2 - inputX;
                            var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);
                            if (Math.abs(s) > 1E-06) {
                                var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                                output.Add(edgeX + (edgeX2 - edgeX) * ua);
                                output.Add(edgeY + (edgeY2 - edgeY) * ua);
                            } else {
                                output.Add(edgeX);
                                output.Add(edgeY);
                            }
                            output.Add(inputX2);
                            output.Add(inputY2);
                        }
                        clipped = true;
                    }
                    if (outputStart === output.Count) {
                        originalOutput.Clear();
                        return true;
                    }
                    output.Add(output.Items[0]);
                    output.Add(output.Items[1]);
                    if (j === clippingVerticesLast) {
                        break;
                    }
                    var temp = output;
                    output = input;
                    output.Clear();
                    input = temp;
                    j = (j + 2) | 0;
                }
                if (!Bridge.referenceEquals(originalOutput, output)) {
                    originalOutput.Clear();
                    var i = 0;
                    for (var k = (output.Count - 2) | 0; i < k; i = (i + 1) | 0) {
                        originalOutput.Add(output.Items[i]);
                    }
                } else {
                    originalOutput.Resize(((originalOutput.Count - 2) | 0));
                }
                return clipped;
            },
            /*Spine.SkeletonClipping.Clip end.*/


        },
        overloads: {
            "ClipEnd(Slot)": "ClipEnd$1"
        }
    });
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    Bridge.define("Spine.SkeletonData", {
        fields: {
            name: null,
            bones: null,
            slots: null,
            skins: null,
            defaultSkin: null,
            events: null,
            animations: null,
            ikConstraints: null,
            transformConstraints: null,
            pathConstraints: null,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            version: null,
            hash: null,
            fps: 0,
            imagesPath: null,
            audioPath: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#get", this ); }

                    return this.name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Name#set", this ); }

                    this.name = value;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Slots: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Slots#get", this ); }

                    return this.slots;
                }
            },
            Skins: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#get", this ); }

                    return this.skins;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Skins#set", this ); }

                    this.skins = value;
                }
            },
            DefaultSkin: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#get", this ); }

                    return this.defaultSkin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#DefaultSkin#set", this ); }

                    this.defaultSkin = value;
                }
            },
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#get", this ); }

                    return this.events;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Events#set", this ); }

                    this.events = value;
                }
            },
            Animations: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#get", this ); }

                    return this.animations;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Animations#set", this ); }

                    this.animations = value;
                }
            },
            IkConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#get", this ); }

                    return this.ikConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#IkConstraints#set", this ); }

                    this.ikConstraints = value;
                }
            },
            TransformConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#get", this ); }

                    return this.transformConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#TransformConstraints#set", this ); }

                    this.transformConstraints = value;
                }
            },
            PathConstraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#get", this ); }

                    return this.pathConstraints;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#PathConstraints#set", this ); }

                    this.pathConstraints = value;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Y#set", this ); }

                    this.y = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Height#set", this ); }

                    this.height = value;
                }
            },
            Version: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#get", this ); }

                    return this.version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Version#set", this ); }

                    this.version = value;
                }
            },
            Hash: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#get", this ); }

                    return this.hash;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Hash#set", this ); }

                    this.hash = value;
                }
            },
            ImagesPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#get", this ); }

                    return this.imagesPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#ImagesPath#set", this ); }

                    this.imagesPath = value;
                }
            },
            AudioPath: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#get", this ); }

                    return this.audioPath;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#AudioPath#set", this ); }

                    this.audioPath = value;
                }
            },
            Fps: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#get", this ); }

                    return this.fps;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#Fps#set", this ); }

                    this.fps = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.slots = new (Spine.ExposedList$1(Spine.SlotData)).ctor();
                this.skins = new (Spine.ExposedList$1(Spine.Skin)).ctor();
                this.events = new (Spine.ExposedList$1(Spine.EventData)).ctor();
                this.animations = new (Spine.ExposedList$1(Spine.Animation)).ctor();
                this.ikConstraints = new (Spine.ExposedList$1(Spine.IkConstraintData)).ctor();
                this.transformConstraints = new (Spine.ExposedList$1(Spine.TransformConstraintData)).ctor();
                this.pathConstraints = new (Spine.ExposedList$1(Spine.PathConstraintData)).ctor();
            }
        },
        methods: {
            /*Spine.SkeletonData.FindBone start.*/
            FindBone: function (boneName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindBone", this ); }

                if (boneName == null) {
                    throw new System.ArgumentNullException.$ctor3("boneName", "boneName cannot be null.");
                }
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (Bridge.referenceEquals(bone.name, boneName)) {
                        return bone;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindBone end.*/

            /*Spine.SkeletonData.FindSlot start.*/
            FindSlot: function (slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSlot", this ); }

                if (slotName == null) {
                    throw new System.ArgumentNullException.$ctor3("slotName", "slotName cannot be null.");
                }
                var slots = this.slots.Items;
                var i = 0;
                for (var j = this.slots.Count; i < j; i = (i + 1) | 0) {
                    var slot = slots[i];
                    if (Bridge.referenceEquals(slot.name, slotName)) {
                        return slot;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSlot end.*/

            /*Spine.SkeletonData.FindSkin start.*/
            FindSkin: function (skinName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindSkin", this ); }

                var $t;
                if (skinName == null) {
                    throw new System.ArgumentNullException.$ctor3("skinName", "skinName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.skins);
                try {
                    while ($t.moveNext()) {
                        var skin = $t.Current;
                        if (Bridge.referenceEquals(skin.name, skinName)) {
                            return skin;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindSkin end.*/

            /*Spine.SkeletonData.FindEvent start.*/
            FindEvent: function (eventDataName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindEvent", this ); }

                var $t;
                if (eventDataName == null) {
                    throw new System.ArgumentNullException.$ctor3("eventDataName", "eventDataName cannot be null.");
                }
                $t = Bridge.getEnumerator(this.events);
                try {
                    while ($t.moveNext()) {
                        var eventData = $t.Current;
                        if (Bridge.referenceEquals(eventData.name, eventDataName)) {
                            return eventData;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindEvent end.*/

            /*Spine.SkeletonData.FindAnimation start.*/
            FindAnimation: function (animationName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindAnimation", this ); }

                if (animationName == null) {
                    throw new System.ArgumentNullException.$ctor3("animationName", "animationName cannot be null.");
                }
                var animations = this.animations.Items;
                var i = 0;
                for (var j = this.animations.Count; i < j; i = (i + 1) | 0) {
                    var animation = animations[i];
                    if (Bridge.referenceEquals(animation.name, animationName)) {
                        return animation;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindAnimation end.*/

            /*Spine.SkeletonData.FindIkConstraint start.*/
            FindIkConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindIkConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var ikConstraints = this.ikConstraints.Items;
                var i = 0;
                for (var j = this.ikConstraints.Count; i < j; i = (i + 1) | 0) {
                    var ikConstraint = ikConstraints[i];
                    if (Bridge.referenceEquals(ikConstraint.name, constraintName)) {
                        return ikConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindIkConstraint end.*/

            /*Spine.SkeletonData.FindTransformConstraint start.*/
            FindTransformConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindTransformConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var transformConstraints = this.transformConstraints.Items;
                var i = 0;
                for (var j = this.transformConstraints.Count; i < j; i = (i + 1) | 0) {
                    var transformConstraint = transformConstraints[i];
                    if (Bridge.referenceEquals(transformConstraint.name, constraintName)) {
                        return transformConstraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindTransformConstraint end.*/

            /*Spine.SkeletonData.FindPathConstraint start.*/
            FindPathConstraint: function (constraintName) {
if ( TRACE ) { TRACE( "Spine.SkeletonData#FindPathConstraint", this ); }

                if (constraintName == null) {
                    throw new System.ArgumentNullException.$ctor3("constraintName", "constraintName cannot be null.");
                }
                var pathConstraints = this.pathConstraints.Items;
                var i = 0;
                for (var j = this.pathConstraints.Count; i < j; i = (i + 1) | 0) {
                    var constraint = pathConstraints[i];
                    if (System.String.equals(constraint.name, constraintName)) {
                        return constraint;
                    }
                }
                return null;
            },
            /*Spine.SkeletonData.FindPathConstraint end.*/

            /*Spine.SkeletonData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonData#toString", this ); }

                var $t;
                return ($t = this.name, $t != null ? $t : Bridge.toString(this));
            },
            /*Spine.SkeletonData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonLoader+LinkedMesh start.*/
    Bridge.define("Spine.SkeletonLoader.LinkedMesh", {
        $kind: 1002,
        fields: {
            parent: null,
            skin: null,
            slotIndex: 0,
            mesh: null,
            inheritTimelines: false
        },
        ctors: {
            ctor: function (mesh, skin, slotIndex, parent, inheritTimelines) {
if ( TRACE ) { TRACE( "Spine.SkeletonLoader.LinkedMesh#ctor", this ); }

                this.$initialize();
                this.mesh = mesh;
                this.skin = skin;
                this.slotIndex = slotIndex;
                this.parent = parent;
                this.inheritTimelines = inheritTimelines;
            }
        }
    });
    /*Spine.SkeletonLoader+LinkedMesh end.*/

    /*Spine.Skin start.*/
    Bridge.define("Spine.Skin", {
        fields: {
            name: null,
            attachments: null,
            bones: null,
            constraints: null
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Name#get", this ); }

                    return this.name;
                }
            },
            Attachments: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Attachments#get", this ); }

                    return this.attachments.Values;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Bones#get", this ); }

                    return this.bones;
                }
            },
            Constraints: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Constraints#get", this ); }

                    return this.constraints;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Skin#init", this ); }

                this.attachments = new (System.Collections.Generic.Dictionary$2(Spine.Skin.SkinKey,Spine.Skin.SkinEntry)).$ctor3(Spine.Skin.SkinKeyComparer.Instance);
                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.constraints = new (Spine.ExposedList$1(Spine.ConstraintData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.Skin#ctor", this ); }

                this.$initialize();
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                this.name = name;
            }
        },
        methods: {
            /*Spine.Skin.SetAttachment start.*/
            SetAttachment: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin#SetAttachment", this ); }

                if (attachment == null) {
                    throw new System.ArgumentNullException.$ctor3("attachment", "attachment cannot be null.");
                }
                this.attachments.setItem(new Spine.Skin.SkinKey.$ctor1(slotIndex, name), new Spine.Skin.SkinEntry.$ctor1(slotIndex, name, attachment));
            },
            /*Spine.Skin.SetAttachment end.*/

            /*Spine.Skin.AddSkin start.*/
            AddSkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#AddSkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data2 = $t.Current;
                        if (!this.bones.Contains(data2)) {
                            this.bones.Add(data2);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data = $t1.Current;
                        if (!this.constraints.Contains(data)) {
                            this.constraints.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(skin.attachments);
                try {
                    while ($t2.moveNext()) {
                        var attachment = $t2.Current;
                        var entry = attachment.value;
                        this.SetAttachment(entry.slotIndex, entry.name, entry.attachment);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AddSkin end.*/

            /*Spine.Skin.CopySkin start.*/
            CopySkin: function (skin) {
if ( TRACE ) { TRACE( "Spine.Skin#CopySkin", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(skin.bones);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        if (!this.bones.Contains(data)) {
                            this.bones.Add(data);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(skin.constraints);
                try {
                    while ($t1.moveNext()) {
                        var data2 = $t1.Current;
                        if (!this.constraints.Contains(data2)) {
                            this.constraints.Add(data2);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(skin.attachments);
                try {
                    while ($t2.moveNext()) {
                        var attachment = $t2.Current;
                        var entry = attachment.value;
                        if (Bridge.is(entry.attachment, Spine.MeshAttachment)) {
                            this.SetAttachment(entry.slotIndex, entry.name, (entry.attachment != null) ? Bridge.cast(entry.attachment, Spine.MeshAttachment).NewLinkedMesh() : null);
                        } else {
                            this.SetAttachment(entry.slotIndex, entry.name, (entry.attachment != null) ? entry.attachment.Copy() : null);
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.CopySkin end.*/

            /*Spine.Skin.GetAttachment start.*/
            GetAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachment", this ); }

                var entry = { v : new Spine.Skin.SkinEntry() };
                return this.attachments.tryGetValue(new Spine.Skin.SkinKey.$ctor1(slotIndex, name), entry) ? entry.v.attachment : null;
            },
            /*Spine.Skin.GetAttachment end.*/

            /*Spine.Skin.RemoveAttachment start.*/
            RemoveAttachment: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin#RemoveAttachment", this ); }

                this.attachments.remove(new Spine.Skin.SkinKey.$ctor1(slotIndex, name));
            },
            /*Spine.Skin.RemoveAttachment end.*/

            /*Spine.Skin.GetAttachments start.*/
            GetAttachments: function (slotIndex, attachments) {
if ( TRACE ) { TRACE( "Spine.Skin#GetAttachments", this ); }

                var $t;
                if (slotIndex < 0) {
                    throw new System.ArgumentException.$ctor1("slotIndex must be >= 0.");
                }
                if (attachments == null) {
                    throw new System.ArgumentNullException.$ctor3("attachments", "attachments cannot be null.");
                }
                $t = Bridge.getEnumerator(this.attachments);
                try {
                    while ($t.moveNext()) {
                        var attachment = $t.Current;
                        var entry = attachment.value;
                        if (entry.slotIndex === slotIndex) {
                            attachments.add(entry);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.GetAttachments end.*/

            /*Spine.Skin.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Skin#Clear", this ); }

                this.attachments.clear();
                this.bones.Clear();
                this.constraints.Clear();
            },
            /*Spine.Skin.Clear end.*/

            /*Spine.Skin.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Skin#toString", this ); }

                return this.name;
            },
            /*Spine.Skin.toString end.*/

            /*Spine.Skin.AttachAll start.*/
            AttachAll: function (skeleton, oldSkin) {
if ( TRACE ) { TRACE( "Spine.Skin#AttachAll", this ); }

                var $t;
                var slots = skeleton.slots.Items;
                $t = Bridge.getEnumerator(oldSkin.attachments);
                try {
                    while ($t.moveNext()) {
                        var attachment2 = $t.Current;
                        var entry = attachment2.value;
                        var slotIndex = entry.slotIndex;
                        var slot = slots[slotIndex];
                        if (Bridge.referenceEquals(slot.Attachment, entry.attachment)) {
                            var attachment = this.GetAttachment(slotIndex, entry.name);
                            if (attachment != null) {
                                slot.Attachment = attachment;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Skin.AttachAll end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    Bridge.define("Spine.Skin.SkinEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getDefaultValue", this ); }
 return new Spine.Skin.SkinEntry(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            attachment: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Name#get", this ); }

                    return this.name;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#Attachment#get", this ); }

                    return this.attachment;
                }
            }
        },
        ctors: {
            $ctor1: function (slotIndex, name, attachment) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$ctor1", this ); }

                this.$initialize();
                this.slotIndex = slotIndex;
                this.name = name;
                this.attachment = attachment;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#getHashCode", this ); }

                var h = Bridge.addHash([3772635665, this.slotIndex, this.name, this.attachment]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinEntry)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.attachment, o.attachment);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinEntry#$clone", this ); }

                var s = to || new Spine.Skin.SkinEntry();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.attachment = this.attachment;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinKey start.*/
    Bridge.define("Spine.Skin.SkinKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#getDefaultValue", this ); }
 return new Spine.Skin.SkinKey(); }
            }
        },
        fields: {
            slotIndex: 0,
            name: null,
            hashCode: 0
        },
        ctors: {
            $ctor1: function (slotIndex, name) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#$ctor1", this ); }

                this.$initialize();
                if (slotIndex < 0) {
                    throw new System.ArgumentException.$ctor1("slotIndex must be >= 0.");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null");
                }
                this.slotIndex = slotIndex;
                this.name = name;
                this.hashCode = (Bridge.getHashCode(name) + Bridge.Int.mul(slotIndex, 37)) | 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#getHashCode", this ); }

                var h = Bridge.addHash([1860358302, this.slotIndex, this.name, this.hashCode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#equals", this ); }

                if (!Bridge.is(o, Spine.Skin.SkinKey)) {
                    return false;
                }
                return Bridge.equals(this.slotIndex, o.slotIndex) && Bridge.equals(this.name, o.name) && Bridge.equals(this.hashCode, o.hashCode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKey#$clone", this ); }

                var s = to || new Spine.Skin.SkinKey();
                s.slotIndex = this.slotIndex;
                s.name = this.name;
                s.hashCode = this.hashCode;
                return s;
            }
        }
    });
    /*Spine.Skin+SkinKey end.*/

    /*Spine.Slot start.*/
    Bridge.define("Spine.Slot", {
        fields: {
            data: null,
            bone: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachment: null,
            sequenceIndex: 0,
            deform: null,
            attachmentState: 0
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Data#get", this ); }

                    return this.data;
                }
            },
            Bone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Bone#get", this ); }

                    return this.bone;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Skeleton#get", this ); }

                    return this.bone.skeleton;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#A#set", this ); }

                    this.a = value;
                }
            },
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#R2#set", this ); }

                    this.r2 = value;
                }
            },
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#G2#set", this ); }

                    this.g2 = value;
                }
            },
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#B2#set", this ); }

                    this.b2 = value;
                }
            },
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#get", this ); }

                    return this.data.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#HasSecondColor#set", this ); }

                    this.data.hasSecondColor = value;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#get", this ); }

                    return this.attachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Attachment#set", this ); }

                    if (!Bridge.referenceEquals(this.attachment, value)) {
                        if (!(Bridge.is(value, Spine.VertexAttachment)) || !(Bridge.is(this.attachment, Spine.VertexAttachment)) || !Bridge.referenceEquals(Bridge.cast(value, Spine.VertexAttachment).TimelineAttachment, Bridge.cast(this.attachment, Spine.VertexAttachment).TimelineAttachment)) {
                            this.deform.Clear();
                        }
                        this.attachment = value;
                        this.sequenceIndex = -1;
                    }
                }
            },
            SequenceIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SequenceIndex#get", this ); }

                    return this.sequenceIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#SequenceIndex#set", this ); }

                    this.sequenceIndex = value;
                }
            },
            Deform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#get", this ); }

                    return this.deform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Slot#Deform#set", this ); }

                    if (this.deform == null) {
                        throw new System.ArgumentNullException.$ctor3("deform", "deform cannot be null.");
                    }
                    this.deform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Slot#init", this ); }

                this.deform = new (Spine.ExposedList$1(System.Single)).ctor();
            },
            $ctor1: function (data, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = data;
                this.bone = bone;
                if (data.hasSecondColor) {
                    this.r2 = ((this.g2 = ((this.b2 = 0.0))));
                }
                this.SetToSetupPose();
            },
            ctor: function (slot, bone) {
if ( TRACE ) { TRACE( "Spine.Slot#ctor", this ); }

                this.$initialize();
                if (slot == null) {
                    throw new System.ArgumentNullException.$ctor3("slot", "slot cannot be null.");
                }
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                this.data = slot.data;
                this.bone = bone;
                this.r = slot.r;
                this.g = slot.g;
                this.b = slot.b;
                this.a = slot.a;
                if (slot.hasSecondColor) {
                    this.r2 = slot.r2;
                    this.g2 = slot.g2;
                    this.b2 = slot.b2;
                } else {
                    this.r2 = ((this.g2 = ((this.b2 = 0.0))));
                }
                this.hasSecondColor = slot.hasSecondColor;
                this.attachment = slot.attachment;
                this.sequenceIndex = slot.sequenceIndex;
                this.deform.AddRange(slot.deform);
            }
        },
        methods: {
            /*Spine.Slot.ClampColor start.*/
            ClampColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampColor", this ); }

                this.r = Spine.MathUtils.Clamp(this.r, 0.0, 1.0);
                this.g = Spine.MathUtils.Clamp(this.g, 0.0, 1.0);
                this.b = Spine.MathUtils.Clamp(this.b, 0.0, 1.0);
                this.a = Spine.MathUtils.Clamp(this.a, 0.0, 1.0);
            },
            /*Spine.Slot.ClampColor end.*/

            /*Spine.Slot.ClampSecondColor start.*/
            ClampSecondColor: function () {
if ( TRACE ) { TRACE( "Spine.Slot#ClampSecondColor", this ); }

                this.r2 = Spine.MathUtils.Clamp(this.r2, 0.0, 1.0);
                this.g2 = Spine.MathUtils.Clamp(this.g2, 0.0, 1.0);
                this.b2 = Spine.MathUtils.Clamp(this.b2, 0.0, 1.0);
            },
            /*Spine.Slot.ClampSecondColor end.*/

            /*Spine.Slot.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Slot#SetToSetupPose", this ); }

                this.r = this.data.r;
                this.g = this.data.g;
                this.b = this.data.b;
                this.a = this.data.a;
                if (this.HasSecondColor) {
                    this.r2 = this.data.r2;
                    this.g2 = this.data.g2;
                    this.b2 = this.data.b2;
                }
                if (this.data.attachmentName == null) {
                    this.Attachment = null;
                    return;
                }
                this.attachment = null;
                this.Attachment = this.bone.skeleton.GetAttachment(this.data.index, this.data.attachmentName);
            },
            /*Spine.Slot.SetToSetupPose end.*/

            /*Spine.Slot.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Slot#toString", this ); }

                return this.data.name;
            },
            /*Spine.Slot.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    Bridge.define("Spine.SlotData", {
        fields: {
            index: 0,
            name: null,
            boneData: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            r2: 0,
            g2: 0,
            b2: 0,
            hasSecondColor: false,
            attachmentName: null,
            blendMode: 0
        },
        props: {
            Index: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Index#get", this ); }

                    return this.index;
                }
            },
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#Name#get", this ); }

                    return this.name;
                }
            },
            BoneData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BoneData#get", this ); }

                    return this.boneData;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#A#set", this ); }

                    this.a = value;
                }
            },
            R2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#get", this ); }

                    return this.r2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#R2#set", this ); }

                    this.r2 = value;
                }
            },
            G2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#get", this ); }

                    return this.g2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#G2#set", this ); }

                    this.g2 = value;
                }
            },
            B2: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#get", this ); }

                    return this.b2;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#B2#set", this ); }

                    this.b2 = value;
                }
            },
            HasSecondColor: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#get", this ); }

                    return this.hasSecondColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#HasSecondColor#set", this ); }

                    this.hasSecondColor = value;
                }
            },
            AttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#get", this ); }

                    return this.attachmentName;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#AttachmentName#set", this ); }

                    this.attachmentName = value;
                }
            },
            BlendMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#get", this ); }

                    return this.blendMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.SlotData#BlendMode#set", this ); }

                    this.blendMode = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#init", this ); }

                this.r = 1.0;
                this.g = 1.0;
                this.b = 1.0;
                this.a = 1.0;
                this.r2 = 0.0;
                this.g2 = 0.0;
                this.b2 = 0.0;
                this.hasSecondColor = false;
            },
            ctor: function (index, name, boneData) {
if ( TRACE ) { TRACE( "Spine.SlotData#ctor", this ); }

                this.$initialize();
                if (index < 0) {
                    throw new System.ArgumentException.$ctor3("index must be >= 0.", "index");
                }
                if (name == null) {
                    throw new System.ArgumentNullException.$ctor3("name", "name cannot be null.");
                }
                if (boneData == null) {
                    throw new System.ArgumentNullException.$ctor3("boneData", "boneData cannot be null.");
                }
                this.index = index;
                this.name = name;
                this.boneData = boneData;
            }
        },
        methods: {
            /*Spine.SlotData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.SlotData#toString", this ); }

                return this.name;
            },
            /*Spine.SlotData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.SlotData end.*/

    /*Spine.SpacingMode start.*/
    Bridge.define("Spine.SpacingMode", {
        $kind: 6,
        statics: {
            fields: {
                Length: 0,
                Fixed: 1,
                Percent: 2,
                Proportional: 3
            }
        }
    });
    /*Spine.SpacingMode end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.Bones != null && va.Bones.length !== 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    return (Bridge.Int.clipu64(mode).and(System.UInt64(1))).equals(System.UInt64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    return (Bridge.Int.clipu64(mode).and(System.UInt64(2))).equals(System.UInt64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.TextureFilter start.*/
    Bridge.define("Spine.TextureFilter", {
        $kind: 6,
        statics: {
            fields: {
                Nearest: 0,
                Linear: 1,
                MipMap: 2,
                MipMapNearestNearest: 3,
                MipMapLinearNearest: 4,
                MipMapNearestLinear: 5,
                MipMapLinearLinear: 6
            }
        }
    });
    /*Spine.TextureFilter end.*/

    /*Spine.TextureLoader start.*/
    Bridge.define("Spine.TextureLoader", {
        $kind: 3
    });
    /*Spine.TextureLoader end.*/

    /*Spine.TextureWrap start.*/
    Bridge.define("Spine.TextureWrap", {
        $kind: 6,
        statics: {
            fields: {
                MirroredRepeat: 0,
                ClampToEdge: 1,
                Repeat: 2
            }
        }
    });
    /*Spine.TextureWrap end.*/

    /*Spine.TransformMode start.*/
    Bridge.define("Spine.TransformMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                OnlyTranslation: 7,
                NoRotationOrReflection: 1,
                NoScale: 2,
                NoScaleOrReflection: 6
            }
        },
        $flags: true
    });
    /*Spine.TransformMode end.*/

    /*Spine.Triangulator start.*/
    Bridge.define("Spine.Triangulator", {
        statics: {
            methods: {
                /*Spine.Triangulator.IsConcave:static start.*/
                IsConcave: function (index, vertexCount, vertices, indices) {
if ( TRACE ) { TRACE( "Spine.Triangulator#IsConcave", this ); }

                    var previous = indices[(((((vertexCount + index) | 0) - 1) | 0)) % vertexCount] << 1;
                    var current = indices[index] << 1;
                    var next = indices[(((index + 1) | 0)) % vertexCount] << 1;
                    return !Spine.Triangulator.PositiveArea(vertices[previous], vertices[((previous + 1) | 0)], vertices[current], vertices[((current + 1) | 0)], vertices[next], vertices[((next + 1) | 0)]);
                },
                /*Spine.Triangulator.IsConcave:static end.*/

                /*Spine.Triangulator.PositiveArea:static start.*/
                PositiveArea: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#PositiveArea", this ); }

                    return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0.0;
                },
                /*Spine.Triangulator.PositiveArea:static end.*/

                /*Spine.Triangulator.Winding:static start.*/
                Winding: function (p1x, p1y, p2x, p2y, p3x, p3y) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Winding", this ); }

                    var px = p2x - p1x;
                    var py = p2y - p1y;
                    return (p3x * py - p3y * px + px * p1y - p1x * py >= 0.0) ? 1 : (-1);
                },
                /*Spine.Triangulator.Winding:static end.*/


            }
        },
        fields: {
            convexPolygons: null,
            convexPolygonsIndices: null,
            indicesArray: null,
            isConcaveArray: null,
            triangles: null,
            polygonPool: null,
            polygonIndicesPool: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Triangulator#init", this ); }

                this.convexPolygons = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Single))).ctor();
                this.convexPolygonsIndices = new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor();
                this.indicesArray = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.isConcaveArray = new (Spine.ExposedList$1(System.Boolean)).ctor();
                this.triangles = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.polygonPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Single)))();
                this.polygonIndicesPool = new (Spine.Pool$1(Spine.ExposedList$1(System.Int32)))();
            }
        },
        methods: {
            /*Spine.Triangulator.Triangulate start.*/
            Triangulate: function (verticesArray) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Triangulate", this ); }

                var $step = 0,
                    $jumpFromFinally, 
                    vertices, 
                    vertexCount, 
                    indicesArray, 
                    indices, 
                    isConcaveArray, 
                    isConcave, 
                    j, 
                    triangles, 
                    previous, 
                    i, 
                    next, 
                    p1, 
                    p2, 
                    p3, 
                    p1x, 
                    p1y, 
                    p2x, 
                    p2y, 
                    p3x, 
                    p3y, 
                    ii, 
                    v, 
                    vx, 
                    vy, 
                    previousIndex, 
                    nextIndex, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,12,13], $step);
                            switch ($step) {
                                case 0: {
                                    vertices = verticesArray.Items;
                                    vertexCount = verticesArray.Count >> 1;
                                    indicesArray = this.indicesArray;
                                    indicesArray.Clear();
                                    indices = indicesArray.Resize(vertexCount).Items;
                                    for (var k = 0; k < vertexCount; k = (k + 1) | 0) {
                                        indices[k] = k;
                                    }
                                    isConcaveArray = this.isConcaveArray;
                                    isConcave = isConcaveArray.Resize(vertexCount).Items;
                                    j = 0;
                                    for (var l = vertexCount; j < l; j = (j + 1) | 0) {
                                        isConcave[j] = Spine.Triangulator.IsConcave(j, vertexCount, vertices, indices);
                                    }
                                    triangles = this.triangles;
                                    triangles.Clear();
                                    triangles.EnsureCapacity(Math.max(0, ((vertexCount - 2) | 0)) << 2);
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( vertexCount > 3 ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 13;
                                    continue;
                                }
                                case 2: {
                                    previous = (vertexCount - 1) | 0;
                                    i = 0;
                                    next = 1;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( true ) {
                                        $step = 4;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 4: {
                                    if (!isConcave[i]) {
                                        $step = 5;
                                        continue;
                                    } 
                                    $step = 10;
                                    continue;
                                }
                                case 5: {
                                    p1 = indices[previous] << 1;
                                    p2 = indices[i] << 1;
                                    p3 = indices[next] << 1;
                                    p1x = vertices[p1];
                                    p1y = vertices[((p1 + 1) | 0)];
                                    p2x = vertices[p2];
                                    p2y = vertices[((p2 + 1) | 0)];
                                    p3x = vertices[p3];
                                    p3y = vertices[((p3 + 1) | 0)];
                                    ii = (((next + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    if ( ii !== previous ) {
                                        $step = 7;
                                        continue;
                                    }
                                    $step = 9;
                                    continue;
                                }
                                case 7: {
                                    if (!isConcave[ii]) {
                                        $step = 8;
                                        continue;
                                    }
                                    v = indices[ii] << 1;
                                    vx = vertices[v];
                                    vy = vertices[((v + 1) | 0)];
                                    if (!Spine.Triangulator.PositiveArea(p3x, p3y, p1x, p1y, vx, vy) || !Spine.Triangulator.PositiveArea(p1x, p1y, p2x, p2y, vx, vy) || !Spine.Triangulator.PositiveArea(p2x, p2y, p3x, p3y, vx, vy)) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 11;
                                    continue;
                                }
                                case 8: {
                                    ii = (((ii + 1) | 0)) % vertexCount;
                                    $step = 6;
                                    continue;
                                }
                                case 9: {
                                    $step = 12;
                                    continue;
                                }
                                case 10: {
                                    $step = 11;
                                    continue;
                                }
                                case 11: {
                                    if (next === 0) {
                                        while (isConcave[i]) {
                                            i = (i - 1) | 0;
                                            if (i <= 0) {
                                                break;
                                            }
                                        }
                                        $step = 12;
                                        continue;
                                    }
                                    previous = i;
                                    i = next;
                                    next = (((next + 1) | 0)) % vertexCount;

                                    $step = 3;
                                    continue;
                                }
                                case 12: {
                                    triangles.Add(indices[(((((vertexCount + i) | 0) - 1) | 0)) % vertexCount]);
                                    triangles.Add(indices[i]);
                                    triangles.Add(indices[(((i + 1) | 0)) % vertexCount]);
                                    indicesArray.RemoveAt(i);
                                    isConcaveArray.RemoveAt(i);
                                    vertexCount = (vertexCount - 1) | 0;
                                    previousIndex = (((((vertexCount + i) | 0) - 1) | 0)) % vertexCount;
                                    nextIndex = ((i !== vertexCount) ? i : 0);
                                    isConcave[previousIndex] = Spine.Triangulator.IsConcave(previousIndex, vertexCount, vertices, indices);
                                    isConcave[nextIndex] = Spine.Triangulator.IsConcave(nextIndex, vertexCount, vertices, indices);

                                    $step = 1;
                                    continue;
                                }
                                case 13: {
                                    if (vertexCount === 3) {
                                        triangles.Add(indices[2]);
                                        triangles.Add(indices[0]);
                                        triangles.Add(indices[1]);
                                    }
                                    return triangles;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            /*Spine.Triangulator.Triangulate end.*/

            /*Spine.Triangulator.Decompose start.*/
            Decompose: function (verticesArray, triangles) {
if ( TRACE ) { TRACE( "Spine.Triangulator#Decompose", this ); }

                var vertices = verticesArray.Items;
                var convexPolygons = this.convexPolygons;
                var i = 0;
                for (var n4 = convexPolygons.Count; i < n4; i = (i + 1) | 0) {
                    this.polygonPool.Free(convexPolygons.Items[i]);
                }
                convexPolygons.Clear();
                var convexPolygonsIndices = this.convexPolygonsIndices;
                var m = 0;
                for (var n3 = convexPolygonsIndices.Count; m < n3; m = (m + 1) | 0) {
                    this.polygonIndicesPool.Free(convexPolygonsIndices.Items[m]);
                }
                convexPolygonsIndices.Clear();
                var polygonIndices = this.polygonIndicesPool.Obtain();
                polygonIndices.Clear();
                var polygon = this.polygonPool.Obtain();
                polygon.Clear();
                var fanBaseIndex = -1;
                var lastWinding = 0;
                var trianglesItems = triangles.Items;
                var l = 0;
                for (var n2 = triangles.Count; l < n2; l = (l + 3) | 0) {
                    var t1 = trianglesItems[l] << 1;
                    var t2 = trianglesItems[((l + 1) | 0)] << 1;
                    var t3 = trianglesItems[((l + 2) | 0)] << 1;
                    var x1 = vertices[t1];
                    var y1 = vertices[((t1 + 1) | 0)];
                    var x2 = vertices[t2];
                    var y2 = vertices[((t2 + 1) | 0)];
                    var x3 = vertices[t3];
                    var y3 = vertices[((t3 + 1) | 0)];
                    var merged = false;
                    if (fanBaseIndex === t1) {
                        var o = (polygon.Count - 4) | 0;
                        var p = polygon.Items;
                        var winding2 = Spine.Triangulator.Winding(p[o], p[((o + 1) | 0)], p[((o + 2) | 0)], p[((o + 3) | 0)], x3, y3);
                        var winding4 = Spine.Triangulator.Winding(x3, y3, p[0], p[1], p[2], p[3]);
                        if (winding2 === lastWinding && winding4 === lastWinding) {
                            polygon.Add(x3);
                            polygon.Add(y3);
                            polygonIndices.Add(t3);
                            merged = true;
                        }
                    }
                    if (!merged) {
                        if (polygon.Count > 0) {
                            convexPolygons.Add(polygon);
                            convexPolygonsIndices.Add(polygonIndices);
                        } else {
                            this.polygonPool.Free(polygon);
                            this.polygonIndicesPool.Free(polygonIndices);
                        }
                        polygon = this.polygonPool.Obtain();
                        polygon.Clear();
                        polygon.Add(x1);
                        polygon.Add(y1);
                        polygon.Add(x2);
                        polygon.Add(y2);
                        polygon.Add(x3);
                        polygon.Add(y3);
                        polygonIndices = this.polygonIndicesPool.Obtain();
                        polygonIndices.Clear();
                        polygonIndices.Add(t1);
                        polygonIndices.Add(t2);
                        polygonIndices.Add(t3);
                        lastWinding = Spine.Triangulator.Winding(x1, y1, x2, y2, x3, y3);
                        fanBaseIndex = t1;
                    }
                }
                if (polygon.Count > 0) {
                    convexPolygons.Add(polygon);
                    convexPolygonsIndices.Add(polygonIndices);
                }
                var k = 0;
                for (var n = convexPolygons.Count; k < n; k = (k + 1) | 0) {
                    polygonIndices = convexPolygonsIndices.Items[k];
                    if (polygonIndices.Count === 0) {
                        continue;
                    }
                    var firstIndex = polygonIndices.Items[0];
                    var lastIndex = polygonIndices.Items[((polygonIndices.Count - 1) | 0)];
                    polygon = convexPolygons.Items[k];
                    var o2 = (polygon.Count - 4) | 0;
                    var p2 = polygon.Items;
                    var prevPrevX = p2[o2];
                    var prevPrevY = p2[((o2 + 1) | 0)];
                    var prevX = p2[((o2 + 2) | 0)];
                    var prevY = p2[((o2 + 3) | 0)];
                    var firstX = p2[0];
                    var firstY = p2[1];
                    var secondX = p2[2];
                    var secondY = p2[3];
                    var winding = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);
                    for (var ii = 0; ii < n; ii = (ii + 1) | 0) {
                        if (ii === k) {
                            continue;
                        }
                        var otherIndices = convexPolygonsIndices.Items[ii];
                        if (otherIndices.Count !== 3) {
                            continue;
                        }
                        var otherFirstIndex = otherIndices.Items[0];
                        var otherSecondIndex = otherIndices.Items[1];
                        var otherLastIndex = otherIndices.Items[2];
                        var otherPoly = convexPolygons.Items[ii];
                        var x4 = otherPoly.Items[((otherPoly.Count - 2) | 0)];
                        var y4 = otherPoly.Items[((otherPoly.Count - 1) | 0)];
                        if (otherFirstIndex === firstIndex && otherSecondIndex === lastIndex) {
                            var winding3 = Spine.Triangulator.Winding(prevPrevX, prevPrevY, prevX, prevY, x4, y4);
                            var winding5 = Spine.Triangulator.Winding(x4, y4, firstX, firstY, secondX, secondY);
                            if (winding3 === winding && winding5 === winding) {
                                otherPoly.Clear();
                                otherIndices.Clear();
                                polygon.Add(x4);
                                polygon.Add(y4);
                                polygonIndices.Add(otherLastIndex);
                                prevPrevX = prevX;
                                prevPrevY = prevY;
                                prevX = x4;
                                prevY = y4;
                                ii = 0;
                            }
                        }
                    }
                }
                for (var j = (convexPolygons.Count - 1) | 0; j >= 0; j = (j - 1) | 0) {
                    polygon = convexPolygons.Items[j];
                    if (polygon.Count === 0) {
                        convexPolygons.RemoveAt(j);
                        this.polygonPool.Free(polygon);
                        polygonIndices = convexPolygonsIndices.Items[j];
                        convexPolygonsIndices.RemoveAt(j);
                        this.polygonIndicesPool.Free(polygonIndices);
                    }
                }
                return convexPolygons;
            },
            /*Spine.Triangulator.Decompose end.*/


        }
    });
    /*Spine.Triangulator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                var obj;
                if (!(UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null))) {
                    var skeletonComponent = this.skeletonGraphic;
                    obj = skeletonComponent;
                } else {
                    var skeletonComponent1 = this.skeletonRenderer;
                    obj = skeletonComponent1;
                }
                this.skeletonComponent = obj;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.ScaleX < 0.0;
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = (isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX);
                var gameObjectToDeactivate = (isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX);
                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);
                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                var $t;
                $t = Bridge.getEnumerator(joints);
                try {
                    while ($t.moveNext()) {
                        var joint = $t.Current;
                        var parent = joint.connectedBody.transform;
                        joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                Evaluate$1: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.Frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }
                    var x = { };
                    var y = { };
                    timeline.GetCurveValue(x, y, time);
                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    }
                    var boneData = ($t1 = skeletonData.Bones.Items)[timeline.BoneIndex];
                    return new pc.Vec2( boneData.X + x.v, boneData.Y + y.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    var x = 0.0;
                    var y = 0.0;
                    if (xTimeline != null && time > ($t = xTimeline.Frames)[0]) {
                        x = xTimeline.GetCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.Frames)[0]) {
                        y = yTimeline.GetCurveValue(time);
                    }
                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    }
                    var bonesItems = skeletonData.Bones.Items;
                    var boneDataX = bonesItems[xTimeline.BoneIndex];
                    var boneDataY = bonesItems[yTimeline.BoneIndex];
                    return new pc.Vec2( boneDataX.X + x, boneDataY.Y + y );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.Frames)[0]) {
                        return 0.0;
                    }
                    var rotation = timeline.GetCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    }
                    var boneData = ($t1 = skeletonData.Bones.Items)[timeline.BoneIndex];
                    return boneData.Rotation + rotation;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                EvaluateTranslateXYMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix", this ); }

                    var $t;
                    if (time < ($t = timeline.Frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }
                    var _discard1 = { };
                    var _discard2 = { };
                    var _discard3 = { };
                    var _discard4 = { };
                    var mixX = { };
                    var mixY = { };
                    timeline.GetCurveValue(_discard1, mixX, mixY, _discard2, _discard3, _discard4, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                EvaluateRotateMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix", this ); }

                    var $t;
                    if (time < ($t = timeline.Frames)[0]) {
                        return 0.0;
                    }
                    var _discard5 = { };
                    var _discard6 = { };
                    var _discard7 = { };
                    var _discard8 = { };
                    var _discard9 = { };
                    var rotate = { };
                    timeline.GetCurveValue(rotate, _discard5, _discard6, _discard7, _discard8, _discard9, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TranslateTimeline) || !(((translateTimeline = Bridge.as(timeline, Spine.TranslateTimeline))) != null) || translateTimeline.BoneIndex !== boneIndex) {
                                continue;
                            }
                            return translateTimeline;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline;
                            if (((translateTimeline = Bridge.as(timeline, T))) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var transformConstraintTimeline;
                            if ((Bridge.getType(timeline).prototype instanceof Spine.TransformConstraintTimeline) || !(((transformConstraintTimeline = Bridge.as(timeline, Spine.TransformConstraintTimeline))) != null) || transformConstraintTimeline.TransformConstraintIndex !== transformConstraintIndex) {
                                continue;
                            }
                            return transformConstraintTimeline;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            textureLoadingMode: 0,
            onDemandTextureLoader: null
        },
        props: {
            TextureLoadingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#get", this ); }

                    return this.textureLoadingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#set", this ); }

                    this.textureLoadingMode = value;
                }
            },
            OnDemandTextureLoader: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get", this ); }

                    return this.onDemandTextureLoader;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set", this ); }

                    this.onDemandTextureLoader = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#init", this ); }

                this.textureLoadingMode = Spine.Unity.AtlasAssetBase.LoadingMode.Normal;
            }
        },
        methods: {
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading start.*/
            BeginCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.BeginCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading start.*/
            EndCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#EndCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.EndCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded start.*/
            RequireTexturesLoaded: function (material, overrideMaterial) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTexturesLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadMaterialTextures(material, overrideMaterial);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded start.*/
            RequireTextureLoaded: function (placeholderTexture, replacementTexture, onTextureLoaded) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTextureLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadTexture(placeholderTexture, replacementTexture, onTextureLoaded);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded end.*/


        }
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase.LoadingMode", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                OnDemand: 1
            }
        }
    });
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(Spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    var width = t.width;
                    var height = t.height;
                    var region = new Spine.AtlasRegion();
                    region.name = t.name;
                    var boundsMin = pc.Vec2.ZERO.clone();
                    var boundsMax = new pc.Vec2( width, height ).scale( scale );
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0.0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0.0));
                    region.u = 0.0;
                    region.v = 1.0;
                    region.u2 = 1.0;
                    region.v2 = 0.0;
                    region.x = 0;
                    region.y = 0;
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = ((s.packed && s.packingRotation !== 0) ? 90 : 0);
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone());
                    var boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.textureRect, s.texture.height);
                    var originalRect = s.rect.$clone();
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(originalRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(originalRect.height);
                    region.offsetX = s.textureRectOffset.x + spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0.0));
                    region.offsetY = s.textureRectOffset.y + spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0.0));
                    if (isolatedTexture) {
                        region.u = 0.0;
                        region.v = 1.0;
                        region.u2 = 1.0;
                        region.v2 = 0.0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);
                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");
                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");
                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);
                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }
                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }
                    var shader = ((materialPropertySource == null) ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader);
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }
                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();
                    var numTextureParamsToRepack = (1 + ((additionalTexturePropertyIDsToCopy != null) ? additionalTexturePropertyIDsToCopy.length : 0)) | 0;
                    additionalOutputTextures = ((additionalTexturePropertyIDsToCopy == null) ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var k = 0; k < numTextureParamsToRepack; k = (k + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[k] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[k].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[k] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();
                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }
                    var newRegionIndex = 0;
                    var attachmentIndex = 0;
                    for (var n2 = sourceAttachments.Count; attachmentIndex < n2; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);
                        if (Bridge.is(originalAttachment, Spine.IHasTextureRegion)) {
                            var originalMeshAttachment;
                            var newAttachment = ((((originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment))) != null) ? originalMeshAttachment.NewLinkedMesh() : originalAttachment.Copy());
                            var region = Bridge.as(Bridge.cast(newAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                for (var j = 0; j < numTextureParamsToRepack; j = (j + 1) | 0) {
                                    var regionTexture = ((j === 0) ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((j - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((j - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((j - 1) | 0)], additionalTextureIsLinear[((j - 1) | 0)]));
                                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[j].add(regionTexture);
                                }
                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }
                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, (useOriginalNonrenderables ? originalAttachment : originalAttachment.Copy()));
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(-1);
                        }
                    }
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;
                    var rects = null;
                    for (var l = 0; l < numTextureParamsToRepack; l = (l + 1) | 0) {
                        var newTexture = new UnityEngine.Texture2D.$ctor12(maxAtlasSize, maxAtlasSize, (l > 0 && additionalTextureFormats != null && ((l - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((l - 1) | 0)] : textureFormat, mipmaps, l > 0 && additionalTextureIsLinear[((l - 1) | 0)]);
                        newTexture.mipMapBias = -0.5;
                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[l];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (l === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((l - 1) | 0)], newTexture);
                            additionalOutputTextures[((l - 1) | 0)] = newTexture;
                        }
                    }
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;
                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    var n = 0;
                    for (var n4 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; n < n4; n = (n + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(n);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[n].$clone(), oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }
                    var m = 0;
                    for (var n3 = outputAttachments.Count; m < n3; m = (m + 1) | 0) {
                        var attachment = outputAttachments.getItem(m);
                        var iHasRegion;
                        if (((iHasRegion = Bridge.as(attachment, Spine.IHasTextureRegion))) != null) {
                            iHasRegion.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(m));
                            iHasRegion.Spine$IHasTextureRegion$UpdateRegion();
                        }
                    }
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }
                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }
                    outputTexture.v = null;
                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);
                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);
                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(skinAttachments, Spine.Skin.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.Attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(skinAttachments, Spine.Skin.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.SetAttachment(originalSkinEntry.SlotIndex, originalSkinEntry.Name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }
                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    var output = { };
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = ((texturePropertyId === 0) ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId));
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor12(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r.$clone(), output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r.$clone(), output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }
                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }
                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = Bridge.getDefaultValue(UnityEngine.Rect);
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor12(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r.$clone(), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r.$clone(), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }
                    var newTexture = new UnityEngine.Texture2D.$ctor12(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0.0, 0.0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0.0, 0.0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    var i = 0;
                    for (var j = pixelBuffer.length; i < j; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r *= a;
                        p.g *= a;
                        p.b *= a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasTextureRegion);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    var width = region.packedWidth;
                    var height = region.packedHeight;
                    if (includeRotate && region.degrees === 270) {
                        width = region.packedHeight;
                        height = region.packedWidth;
                    }
                    return new UnityEngine.Rect.$ctor1(region.x, region.y, width, height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0.0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0.0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0.0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0.0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);
                    var x = Bridge.Int.clip32(rr.x);
                    var y = Bridge.Int.clip32(rr.y);
                    var w = Bridge.Int.clip32(rr.width);
                    var h = Bridge.Int.clip32(rr.height);
                    if (referenceRegion.degrees === 270) {
                        var tempW = w;
                        w = h;
                        h = tempW;
                    }
                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));
                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));
                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;
                    if (referenceRegion.degrees === 270) {
                        var du = uvRect.width;
                        var dv = uvRect.height;
                        var atlasAspectRatio = page.width / page.height;
                        u2 = u + dv / atlasAspectRatio;
                        v2 = v - du * atlasAspectRatio;
                    }
                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = Bridge.as(region.page.rendererObject, UnityEngine.Material);
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = Bridge.as(region.page.rendererObject, UnityEngine.Material);
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = Bridge.as(region.page.rendererObject, UnityEngine.Material);
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return (Bridge.Int.mul(Bridge.getHashCode(this.i), 23)) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale, pmaCloneTextureFormat, pmaCloneMipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    if (pmaCloneTextureFormat === void 0) { pmaCloneTextureFormat = 4; }
                    if (pmaCloneMipmaps === void 0) { pmaCloneMipmaps = false; }
                    var atlasRegion = (premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial, pmaCloneTextureFormat, pmaCloneMipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t)));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        atlasRegion.offsetX = 0.0;
                        atlasRegion.offsetY = 0.0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    var regionAttachment;
                    if (useOriginalRegionScale && ((regionAttachment = Bridge.as(o, Spine.RegionAttachment))) != null) {
                        scale = regionAttachment.Width / regionAttachment.Region.OriginalWidth;
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment;
                    if (((regionAttachment = Bridge.as(o, Spine.RegionAttachment))) != null) {
                        var newAttachment = Bridge.cast(regionAttachment.Copy(), Spine.RegionAttachment);
                        newAttachment.Region = atlasRegion;
                        if (!useOriginalRegionSize) {
                            newAttachment.Width = atlasRegion.width * scale;
                            newAttachment.Height = atlasRegion.height * scale;
                        }
                        newAttachment.UpdateRegion();
                        return newAttachment;
                    }
                    var meshAttachment;
                    if (((meshAttachment = Bridge.as(o, Spine.MeshAttachment))) != null) {
                        var newAttachment2 = (cloneMeshAsLinked ? meshAttachment.NewLinkedMesh() : Bridge.cast(meshAttachment.Copy(), Spine.MeshAttachment));
                        newAttachment2.Region = atlasRegion;
                        newAttachment2.UpdateRegion();
                        return newAttachment2;
                    }
                    return o.Copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    var $t, $t1;
                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }
                    var attachment = new Spine.RegionAttachment.$ctor1(attachmentName);
                    attachment.Region = region;
                    attachment.Path = region.name;
                    attachment.ScaleX = 1.0;
                    attachment.ScaleY = 1.0;
                    attachment.Rotation = rotation;
                    attachment.R = 1.0;
                    attachment.G = 1.0;
                    attachment.B = 1.0;
                    attachment.A = 1.0;
                    var textreRegion = attachment.Region;
                    var atlasRegion = Bridge.as(textreRegion, Spine.AtlasRegion);
                    var originalWidth = ($t = (atlasRegion != null ? atlasRegion.originalWidth : null), $t != null ? $t : textreRegion.width);
                    var originalHeight = ($t1 = (atlasRegion != null ? atlasRegion.originalHeight : null), $t1 != null ? $t1 : textreRegion.height);
                    attachment.Width = originalWidth * scale;
                    attachment.Height = originalHeight * scale;
                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.UpdateRegion();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.ScaleX = scale.x;
                    regionAttachment.ScaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.ScaleX = x;
                    regionAttachment.ScaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.X = offset.x;
                    regionAttachment.Y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.X = x;
                    regionAttachment.Y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.Rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair3 = $t.Current;
                        if (Bridge.referenceEquals(pair3.material, material)) {
                            return Spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair2 = $t1.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return Spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair = $t2.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return Spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return Spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                var slotIndex = 0;
                for (var slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.BlendMode === Spine.BlendMode.Normal || (!this.applyAdditiveMaterial && slot.BlendMode === Spine.BlendMode.Additive)) {
                        continue;
                    }
                    var replacementMaterials = null;
                    switch (slot.BlendMode) {
                        case Spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case Spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case Spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }
                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            skin.GetAttachments(slotIndex, skinEntries);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var item = $t1.Current;
                            var renderableAttachment;
                            if (!(((renderableAttachment = Bridge.as(item.Attachment, Spine.IHasTextureRegion))) != null)) {
                                continue;
                            }
                            if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                            } else if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.Regions;
                                for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                    regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }
                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);
                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }
                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (this.valid) {
                    this.skeletonTransform = this.skeletonRenderer.transform;
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                    this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);
                    if (!System.String.isNullOrEmpty(this.boneName)) {
                        this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                    }
                }
            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }
                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }
                var thisTransform = this.transform;
                var additionalFlipScale = 1.0;
                if (this.skeletonTransformIsParent) {
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.WorldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.WorldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.C, this.bone.A) * 0.5;
                        if (this.followLocalScale && this.bone.ScaleX < 0.0) {
                            halfRotation += 1.57079637;
                        }
                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.WorldX, this.bone.WorldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }
                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = ((UnityEngine.Component.op_Inequality(transformParent, null)) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 ));
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;
                        if (skeletonLossyScale.x * skeletonLossyScale.y < 0.0) {
                            boneWorldRotation = 0.0 - boneWorldRotation;
                        }
                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if (skeletonLossyScale.x * parentLossyScale.x < 0.0) {
                                boneWorldRotation += 180.0;
                            }
                        } else if (skeletonLossyScale.y * parentLossyScale.y < 0.0) {
                            boneWorldRotation += 180.0;
                        }
                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.ScaleX < 0.0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }
                var parentBone = this.bone.Parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.WorldScaleX, parentBone.WorldScaleY, 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.FindBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (this.valid) {
                    this.skeletonTransform = this.skeletonGraphic.transform;
                    this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);
                    if (!System.String.isNullOrEmpty(this.boneName)) {
                        this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                    }
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }
                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.FindBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }
                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }
                var scale = this.skeletonGraphic.MeshScale;
                var additionalFlipScale = 1.0;
                if (this.skeletonTransformIsParent) {
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? (this.bone.WorldX * scale) : thisTransform.localPosition.x, this.followXYPosition ? (this.bone.WorldY * scale) : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.WorldX * scale, this.bone.WorldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }
                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = ((UnityEngine.Component.op_Inequality(transformParent, null)) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 ));
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.WorldRotationX;
                        if (skeletonLossyScale.x * skeletonLossyScale.y < 0.0) {
                            boneWorldRotation = 0.0 - boneWorldRotation;
                        }
                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if (skeletonLossyScale.x * parentLossyScale.x < 0.0) {
                                boneWorldRotation += 180.0;
                            }
                        } else if (skeletonLossyScale.y * parentLossyScale.y < 0.0) {
                            boneWorldRotation += 180.0;
                        }
                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.ScaleX < 0.0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }
                var parentBone = this.bone.Parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.WorldScaleX, parentBone.WorldScaleY, 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.Initialize(false);
                if (System.String.isNullOrEmpty(this.slotName) || (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.Data.Name))) {
                    return;
                }
                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();
                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.Data.Index;
                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (skeleton.Skin != null) {
                        this.AddCollidersForSkin(skeleton.Skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);
                if (Spine.Unity.BoundingBoxFollower.DebugMessages && this.colliderTable.Count === 0) {
                    if (Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.activeInHierarchy) {
                        UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                    } else {
                        UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments(slotIndex, skinEntries);
                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }
                        if (boundingBoxAttachment != null && !this.colliderTable.containsKey(boundingBoxAttachment)) {
                            var bbCollider = ((collidersCount.v < previousColliders.length) ? previousColliders[collidersCount.v] : Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.AddComponent(UnityEngine.PolygonCollider2D));
                            collidersCount.v = (collidersCount.v + 1) | 0;
                            Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                            bbCollider.isTrigger = this.isTrigger;
                            bbCollider.usedByEffector = this.usedByEffector;
                            bbCollider.usedByComposite = this.usedByComposite;
                            bbCollider.enabled = false;
                            bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                            this.colliderTable.add(boundingBoxAttachment, bbCollider);
                            this.nameTable.add(boundingBoxAttachment, entry.Name);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }
                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }
                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }
                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                    return;
                }
                var foundCollider = { };
                this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                    this.currentCollider = foundCollider.v;
                    this.currentCollider.enabled = true;
                    this.currentAttachment = bbAttachment;
                    this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    return;
                }
                this.currentCollider = null;
                this.currentAttachment = bbAttachment;
                this.currentAttachmentName = null;
                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.Name]);
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(Spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }
                this.skeletonGraphic.Initialize(false);
                if (System.String.isNullOrEmpty(this.slotName) || (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.Skeleton) && Bridge.referenceEquals(this.slotName, this.slot.Data.Name))) {
                    return;
                }
                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();
                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.FindSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.Data.Index;
                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.activeInHierarchy) {
                    var scale = this.skeletonGraphic.MeshScale;
                    $t = Bridge.getEnumerator(skeleton.Data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (skeleton.Skin != null) {
                        this.AddCollidersForSkin(skeleton.Skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);
                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && this.colliderTable.Count === 0) {
                    if (Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.activeInHierarchy) {
                        UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                    } else {
                        UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                skin.GetAttachments(slotIndex, skinEntries);
                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.GetAttachment(slotIndex, entry.Name);
                        var boundingBoxAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }
                        if (boundingBoxAttachment != null && !this.colliderTable.containsKey(boundingBoxAttachment)) {
                            var bbCollider = ((collidersCount.v < previousColliders.length) ? previousColliders[collidersCount.v] : Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.AddComponent(UnityEngine.PolygonCollider2D));
                            collidersCount.v = (collidersCount.v + 1) | 0;
                            Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                            bbCollider.isTrigger = this.isTrigger;
                            bbCollider.usedByEffector = this.usedByEffector;
                            bbCollider.usedByComposite = this.usedByComposite;
                            bbCollider.enabled = false;
                            bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                            this.colliderTable.add(boundingBoxAttachment, bbCollider);
                            this.nameTable.add(boundingBoxAttachment, entry.Name);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }
                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.Attachment, this.currentAttachment)) {
                    this.MatchAttachment(this.slot.Attachment);
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, Spine.BoundingBoxAttachment);
                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }
                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }
                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                    return;
                }
                var foundCollider = { };
                this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                    this.currentCollider = foundCollider.v;
                    this.currentCollider.enabled = true;
                    this.currentAttachment = bbAttachment;
                    this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    return;
                }
                this.currentCollider = null;
                this.currentAttachment = bbAttachment;
                this.currentAttachmentName = null;
                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.Name]);
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (!(this.skeletonDataAsset == null)) {
                    this.eventData = this.skeletonDataAsset.GetSkeletonData(true).FindEvent(this.eventName);
                    if (this.eventData == null) {
                        UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                    }
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    Bridge.define("Spine.Unity.FollowLocationRigidbody", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Spine.Unity.FollowLocationRigidbody.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody#FixedUpdate", this ); }

                this.ownRigidbody.rotation = this.reference.rotation.$clone();
                this.ownRigidbody.position = this.reference.position.$clone();
            },
            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    Bridge.define("Spine.Unity.FollowLocationRigidbody2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            followFlippedX: false,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody2D.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#Awake", this ); }

                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Spine.Unity.FollowLocationRigidbody2D.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowLocationRigidbody2D#FixedUpdate", this ); }

                if (this.followFlippedX) {
                    this.ownRigidbody.rotation = (0.0 - this.reference.rotation.getPositiveEulerAngles().z + 270.0) % 360.0 - 90.0;
                } else {
                    this.ownRigidbody.rotation = this.reference.rotation.getPositiveEulerAngles().z;
                }
                this.ownRigidbody.position = UnityEngine.Vector2.FromVector3(this.reference.position.$clone());
            },
            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    Bridge.define("Spine.Unity.FollowSkeletonUtilityRootRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                FLIP_ANGLE_THRESHOLD: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                    this.FLIP_ANGLE_THRESHOLD = 100.0;
                }
            }
        },
        fields: {
            reference: null,
            prevLocalEulerAngles: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#init", this ); }

                this.prevLocalEulerAngles = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#Start", this ); }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#FixedUpdate", this ); }

                this.transform.rotation = this.reference.rotation.$clone();
                var wasFlippedAroundY = Math.abs(this.transform.localEulerAngles.y - this.prevLocalEulerAngles.y) > 100.0;
                var wasFlippedAroundX = Math.abs(this.transform.localEulerAngles.x - this.prevLocalEulerAngles.x) > 100.0;
                if (wasFlippedAroundY) {
                    this.CompensatePositionToYRotation();
                }
                if (wasFlippedAroundX) {
                    this.CompensatePositionToXRotation();
                }
                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation start.*/
            CompensatePositionToYRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToYRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.y = this.transform.position.y;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation start.*/
            CompensatePositionToXRotation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.FollowSkeletonUtilityRootRotation#CompensatePositionToXRotation", this ); }

                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.x = this.transform.position.x;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation end.*/


        }
    });
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MathUtilities start.*/
    Bridge.define("Spine.Unity.MathUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.MathUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.MathUtilities.InverseLerp:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$1:static start.*/
                InverseLerp$1: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$1", this ); }

                    return new pc.Vec2( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$1:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$2:static start.*/
                InverseLerp$2: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$2", this ); }

                    return new pc.Vec3( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$2:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$3:static start.*/
                InverseLerp$3: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.MathUtilities#InverseLerp$3", this ); }

                    return new pc.Vec4( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z), (value.w - a.w) / (b.w - a.w) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$3:static end.*/


            }
        }
    });
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.MeshGenerator start.*/
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    instructionOutput.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var submeshInstruction = Bridge.getDefaultValue(Spine.Unity.SubmeshInstruction);
                    submeshInstruction.skeleton = skeleton;
                    submeshInstruction.preActiveClippingSlotSource = -1;
                    submeshInstruction.startSlot = 0;
                    submeshInstruction.rawFirstVertexIndex = 0;
                    submeshInstruction.material = material;
                    submeshInstruction.forceSeparate = false;
                    submeshInstruction.endSlot = drawOrderCount;
                    var current = submeshInstruction.$clone();
                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.Data.BlendMode === Spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = (($t = slot.Attachment, workingAttachmentsItems[i] = $t, $t));
                        var attachmentVertexCount;
                        var attachmentTriangleCount;
                        var regionAttachment;
                        if (((regionAttachment = Bridge.as(attachment, Spine.RegionAttachment))) != null) {
                            if (regionAttachment.Sequence != null) {
                                regionAttachment.Sequence.Apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.Region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment;
                            if (((meshAttachment = Bridge.as(attachment, Spine.MeshAttachment))) != null) {
                                if (meshAttachment.Sequence != null) {
                                    meshAttachment.Sequence.Apply(slot, meshAttachment);
                                }

                                rendererObject = meshAttachment.Region;
                                attachmentVertexCount = meshAttachment.WorldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.Triangles.length;
                            } else {
                                if (Bridge.is(attachment, Spine.ClippingAttachment)) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }

                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }
                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }
                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;
                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active) {
                            continue;
                        }
                        var attachment = slot.Attachment;
                        var rendererAttachment;
                        if (!(((rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion))) != null)) {
                            continue;
                        }
                        if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                            rendererAttachment.Spine$IHasTextureRegion$Sequence.Apply(slot, rendererAttachment);
                        }
                        var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                        var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                        if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                            if (lastRendererMaterial != null) {
                                return true;
                            }
                            lastRendererMaterial = material;
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t, $t1;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    instructionOutput.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;
                    var submeshInstruction = Bridge.getDefaultValue(Spine.Unity.SubmeshInstruction);
                    submeshInstruction.skeleton = skeleton;
                    submeshInstruction.preActiveClippingSlotSource = -1;
                    var current = submeshInstruction.$clone();
                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;
                    var separatorCount = ($t = (separatorSlots != null ? separatorSlots.Count : null), $t != null ? $t : 0);
                    var hasSeparators = separatorCount > 0;
                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1;
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.Bone.Active) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.Data.BlendMode === Spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = (($t1 = slot.Attachment, workingAttachmentsItems[i] = $t1, $t1));
                        var attachmentVertexCount = 0;
                        var attachmentTriangleCount = 0;
                        var region = null;
                        var noRender = false;
                        var regionAttachment;
                        if (((regionAttachment = Bridge.as(attachment, Spine.RegionAttachment))) != null) {
                            if (regionAttachment.Sequence != null) {
                                regionAttachment.Sequence.Apply(slot, regionAttachment);
                            }
                            region = regionAttachment.Region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment;
                            if (((meshAttachment = Bridge.as(attachment, Spine.MeshAttachment))) != null) {
                                if (meshAttachment.Sequence != null) {
                                    meshAttachment.Sequence.Apply(slot, meshAttachment);
                                }

                                region = meshAttachment.Region;
                                attachmentVertexCount = meshAttachment.WorldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.Triangles.length;
                            } else {
                                var clippingAttachment;
                                if (((clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment))) != null) {
                                    clippingEndSlot = clippingAttachment.EndSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }

                                noRender = true;
                            }
                        }
                        if (hasSeparators) {
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }
                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) {
                                current.endSlot = i;
                                current.preActiveClippingSlotSource = lastPreActiveClipping;
                                workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                submeshIndex = (submeshIndex + 1) | 0;
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }
                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) {
                                current.endSlot = i;
                                current.preActiveClippingSlotSource = lastPreActiveClipping;
                                workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                submeshIndex = (submeshIndex + 1) | 0;
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }
                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.Data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }
                    if (current.rawVertexCount > 0) {
                        current.endSlot = drawOrderCount;
                        current.preActiveClippingSlotSource = lastPreActiveClipping;
                        current.forceSeparate = false;
                        workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                        workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                    }
                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        var overrideMaterial = { };
                        if (!(material == null) && customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }
                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var tdir = Bridge.getDefaultValue(UnityEngine.Vector2);
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[t];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];
                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();
                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();
                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;
                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t2 = w2.y - w1.y;
                        var t3 = w3.y - w1.y;
                        var div = s1 * t3 - s2 * t2;
                        var r = ((div === 0.0) ? 0.0 : (1.0 / div));
                        sdir.x = (t3 * x1 - t2 * x2) * r;
                        sdir.y = (t3 * y1 - t2 * y2) * r;
                        tempTanBuffer[i1] = (($t = ((tempTanBuffer[i3] = sdir.$clone(), sdir.$clone())), tempTanBuffer[i2] = $t.$clone(), $t));
                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = (($t1 = ((tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone())), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1));
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = Bridge.getDefaultValue(UnityEngine.Vector4);
                    tangent.z = 0.0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }
                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        tangent.w = ((t.y * t2.x > t.x * t2.y) ? 1 : (-1));
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (!(mesh == null) && regionAttachment != null) {
                        Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                        var offsets = regionAttachment.Offset;
                        Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[0], offsets[1], 0 ));
                        Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[2], offsets[3], 0 ));
                        Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[4], offsets[5], 0 ));
                        Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[6], offsets[7], 0 ));
                        Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                        var uvs = regionAttachment.UVs;
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[2], uvs[3] ));
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[4], uvs[5] ));
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[6], uvs[7] ));
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[0], uvs[1] ));
                        Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                        var c = UnityEngine.Color32.op_Implicit$1(new pc.Color( regionAttachment.R, regionAttachment.G, regionAttachment.B, regionAttachment.A ));
                        for (var i = 0; i < 4; i = (i + 1) | 0) {
                            Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                        }
                        Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                        Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));
                        mesh.Clear();
                        mesh.name = regionAttachment.Name;
                        mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                        mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                        mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                        mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                        mesh.RecalculateBounds();
                        Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                        Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                        Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                        Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    }
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null || meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.WorldVerticesLength, 2)) | 0;
                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.WorldVerticesLength;
                        var meshAttachmentBones = meshAttachment.Bones;
                        var v = 0;
                        var vertices = meshAttachment.Vertices;
                        var w = 0;
                        var b = 0;
                        for (; w < count; w = (w + 2) | 0) {
                            var wx = 0.0;
                            var wy = 0.0;
                            var k = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            k = (k + v) | 0;
                            while (v < k) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b];
                                var vy = vertices[((b + 1) | 0)];
                                var weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                                v = (v + 1) | 0;
                                b = (b + 3) | 0;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.Vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var j = 0; j < vertexCount; j = (j + 1) | 0) {
                            var ii = Bridge.Int.mul(j, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }
                    var uvs = meshAttachment.UVs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1(new pc.Color( meshAttachment.R, meshAttachment.G, meshAttachment.B, meshAttachment.A ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var ii2 = Bridge.Int.mul(i, 2);
                        uv.x = uvs[ii2];
                        uv.y = uvs[((ii2 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.Triangles);
                    mesh.Clear();
                    mesh.name = meshAttachment.Name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();
                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var result = Bridge.getDefaultValue(Spine.Unity.MeshGeneratorBuffers);
                    result.vertexCount = this.VertexCount;
                    result.vertexBuffer = this.vertexBuffer.Items;
                    result.uvBuffer = this.uvBuffer.Items;
                    result.colorBuffer = this.colorBuffer.Items;
                    result.meshGenerator = this;
                    return result.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([0, 1, 2, 2, 3, 0], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.ClipEnd();
                this.meshBoundsMin.x = Number.POSITIVE_INFINITY;
                this.meshBoundsMin.y = Number.POSITIVE_INFINITY;
                this.meshBoundsMax.x = Number.NEGATIVE_INFINITY;
                this.meshBoundsMax.y = Number.NEGATIVE_INFINITY;
                this.meshBoundsThickness = 0.0;
                this.submeshIndex = 0;
                this.submeshes.Count = 1;
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2, $t3;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();
                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    submesh = (($t1 = new (Spine.ExposedList$1(System.Int32)).ctor(), ($t2 = this.submeshes.Items)[this.submeshIndex] = $t1, $t1));
                }
                submesh.Clear(false);
                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;
                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.A;
                var skeletonR = skeleton.R;
                var skeletonG = skeleton.G;
                var skeletonB = skeleton.B;
                var meshBoundsMin = this.meshBoundsMin.$clone();
                var meshBoundsMax = this.meshBoundsMax.$clone();
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                if (useClipping && instruction.preActiveClippingSlotSource >= 0) {
                    var slot2 = drawOrderItems[instruction.preActiveClippingSlotSource];
                    this.clipper.ClipStart(slot2, Bridge.as(slot2.Attachment, Spine.ClippingAttachment));
                }
                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot = drawOrderItems[slotIndex];
                    if (!slot.Bone.Active) {
                        this.clipper.ClipEnd$1(slot);
                        continue;
                    }
                    var attachment = slot.Attachment;
                    var z = zSpacing * slotIndex;
                    var workingVerts = this.tempVerts;
                    var c = Bridge.getDefaultValue(UnityEngine.Color);
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;
                    var region;
                    if (((region = Bridge.as(attachment, Spine.RegionAttachment))) != null) {
                        region.ComputeWorldVertices(slot, workingVerts, 0);
                        uvs = region.UVs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.R;
                        c.g = region.G;
                        c.b = region.B;
                        c.a = region.A;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh;
                        if (!(((mesh = Bridge.as(attachment, Spine.MeshAttachment))) != null)) {
                            var clippingAttachment;
                            if (useClipping && ((clippingAttachment = Bridge.as(attachment, Spine.ClippingAttachment))) != null) {
                                this.clipper.ClipStart(slot, clippingAttachment);
                            } else {
                                this.clipper.ClipEnd$1(slot);
                            }
                            continue;
                        }
                        var meshVerticesLength = mesh.WorldVerticesLength;
                        if (workingVerts.length < meshVerticesLength) {
                            workingVerts = ((this.tempVerts = System.Array.init(meshVerticesLength, 0, System.Single)));
                        }
                        mesh.ComputeWorldVertices(slot, 0, meshVerticesLength, workingVerts, 0);
                        uvs = mesh.UVs;
                        attachmentTriangleIndices = mesh.Triangles;
                        c.r = mesh.R;
                        c.g = mesh.G;
                        c.b = mesh.B;
                        c.a = mesh.A;
                        attachmentVertexCount = meshVerticesLength >> 1;
                        attachmentIndexCount = mesh.Triangles.length;
                    }
                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot.A * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255.0);
                        color.r = Bridge.Int.clipu8(skeletonR * slot.R * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot.G * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot.B * c.b * color.a);
                        if (slot.Data.BlendMode === Spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0.0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) {
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot.A * c.a * 255.0);
                        color.r = Bridge.Int.clipu8(skeletonR * slot.R * c.r * 255.0);
                        color.g = Bridge.Int.clipu8(skeletonG * slot.G * c.g * 255.0);
                        color.b = Bridge.Int.clipu8(skeletonB * slot.B * c.b * 255.0);
                    }
                    if (useClipping && this.clipper.IsClipping) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot.R2;
                            var g2 = slot.G2;
                            var b2 = slot.B2;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot.A * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }
                        var ovc = this.vertexBuffer.Count;
                        var newVertexCount = (ovc + attachmentVertexCount) | 0;
                        var oldArraySize = this.vertexBuffer.Items.length;
                        if (newVertexCount > oldArraySize) {
                            var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                            if (newArraySize < newVertexCount) {
                                newArraySize = newVertexCount;
                            }
                            System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector2);
                            }, UnityEngine.Vector2);
                            System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                return Bridge.getDefaultValue(UnityEngine.Color32);
                            }, UnityEngine.Color32);
                        }
                        this.vertexBuffer.Count = (($t3 = ((this.colorBuffer.Count = newVertexCount, newVertexCount)), this.uvBuffer.Count = $t3, $t3));
                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var k = 0; k < attachmentVertexCount; k = (k + 1) | 0) {
                                var vi2 = (ovc + k) | 0;
                                var i3 = k << 1;
                                var x2 = workingVerts[i3];
                                var y2 = workingVerts[((i3 + 1) | 0)];
                                vbi[vi2].x = x2;
                                vbi[vi2].y = y2;
                                vbi[vi2].z = z;
                                ubi[vi2].x = uvs[i3];
                                ubi[vi2].y = uvs[((i3 + 1) | 0)];
                                cbi[vi2] = color.$clone();
                                if (x2 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x2;
                                }
                                if (x2 > meshBoundsMax.x) {
                                    meshBoundsMax.x = x2;
                                }
                                if (y2 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y2;
                                }
                                if (y2 > meshBoundsMax.y) {
                                    meshBoundsMax.y = y2;
                                }
                            }
                        } else {
                            for (var j = 0; j < attachmentVertexCount; j = (j + 1) | 0) {
                                var vi = (ovc + j) | 0;
                                var i2 = j << 1;
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];
                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                } else if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                } else if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        }
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                            if (newTriangleCount > submesh.Items.length) {
                                System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                            }
                            submesh.Count = newTriangleCount;
                            var submeshItems = submesh.Items;
                            for (var i = 0; i < attachmentIndexCount; i = (i + 1) | 0) {
                                submeshItems[((oldTriangleCount + i) | 0)] = (attachmentTriangleIndices[i] + ovc) | 0;
                            }
                        }
                    }
                    this.clipper.ClipEnd$1(slot);
                }
                this.clipper.ClipEnd();
                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;
                var currentSubmeshItems = submesh.Items;
                var l = submesh.Count;
                for (var m = currentSubmeshItems.length; l < m; l = (l + 1) | 0) {
                    currentSubmeshItems[l] = 0;
                }
                this.submeshIndex = (this.submeshIndex + 1) | 0;
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                var i = 0;
                for (var j = instruction.submeshInstructions.Count; i < j; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i].$clone(), updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;
                if (totalVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);
                }
                this.vertexBuffer.Count = (($t = ((this.colorBuffer.Count = totalVertexCount, totalVertexCount)), this.uvBuffer.Count = $t, $t));
                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();
                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;
                var si = 0;
                var b2 = Bridge.getDefaultValue(UnityEngine.Vector2);
                var rg = Bridge.getDefaultValue(UnityEngine.Vector2);
                for (var j = instruction.submeshInstructions.Count; si < j; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.A;
                    var r = skeleton.R;
                    var g = skeleton.G;
                    var b = skeleton.B;
                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;
                    if (settings.tintBlack) {
                        var vi = vertexIndex;
                        b2.y = 1.0;
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        }
                        if (totalVertexCount > this.uv2.Items.length) {
                            System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector2);
                            }, UnityEngine.Vector2);
                            System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector2);
                            }, UnityEngine.Vector2);
                        }
                        this.uv2.Count = ((this.uv3.Count = totalVertexCount, totalVertexCount));
                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;
                        for (var slotIndex2 = startSlot; slotIndex2 < endSlot; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems[slotIndex2];
                            if (!slot2.Bone.Active) {
                                continue;
                            }
                            var attachment2 = slot2.Attachment;
                            rg.x = slot2.R2;
                            rg.y = slot2.G2;
                            b2.x = slot2.B2;
                            b2.y = 1.0;
                            var regionAttachment2;
                            if (((regionAttachment2 = Bridge.as(attachment2, Spine.RegionAttachment))) != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha2 = a * slot2.A * regionAttachment2.A;
                                    rg.x *= alpha2;
                                    rg.y *= alpha2;
                                    b2.x *= alpha2;
                                    b2.y = ((slot2.Data.BlendMode === Spine.BlendMode.Additive) ? 0.0 : alpha2);
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else {
                                var meshAttachment2;
                                if (((meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment))) != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha = a * slot2.A * meshAttachment2.A;
                                        rg.x *= alpha;
                                        rg.y *= alpha;
                                        b2.x *= alpha;
                                        b2.y = ((slot2.Data.BlendMode === Spine.BlendMode.Additive) ? 0.0 : alpha);
                                    }

                                    var verticesArrayLength2 = meshAttachment2.WorldVerticesLength;
                                    for (var iii2 = 0; iii2 < verticesArrayLength2; iii2 = (iii2 + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }
                    for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                        var slot = drawOrderItems[slotIndex];
                        if (!slot.Bone.Active) {
                            continue;
                        }
                        var attachment = slot.Attachment;
                        var z = slotIndex * settings.zSpacing;
                        var regionAttachment;
                        if (((regionAttachment = Bridge.as(attachment, Spine.RegionAttachment))) != null) {
                            regionAttachment.ComputeWorldVertices(slot, tempVerts, 0);
                            var x2 = tempVerts[0];
                            var y2 = tempVerts[1];
                            var x3 = tempVerts[2];
                            var y3 = tempVerts[3];
                            var x4 = tempVerts[4];
                            var y4 = tempVerts[5];
                            var x5 = tempVerts[6];
                            var y5 = tempVerts[7];
                            vbi[vertexIndex].x = x2;
                            vbi[vertexIndex].y = y2;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x5;
                            vbi[((vertexIndex + 1) | 0)].y = y5;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x3;
                            vbi[((vertexIndex + 2) | 0)].y = y3;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x4;
                            vbi[((vertexIndex + 3) | 0)].y = y4;
                            vbi[((vertexIndex + 3) | 0)].z = z;
                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot.A * regionAttachment.A * 255.0);
                                color.r = Bridge.Int.clipu8(r * slot.R * regionAttachment.R * color.a);
                                color.g = Bridge.Int.clipu8(g * slot.G * regionAttachment.G * color.a);
                                color.b = Bridge.Int.clipu8(b * slot.B * regionAttachment.B * color.a);
                                if (slot.Data.BlendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot.A * regionAttachment.A * 255.0);
                                color.r = Bridge.Int.clipu8(r * slot.R * regionAttachment.R * 255.0);
                                color.g = Bridge.Int.clipu8(g * slot.G * regionAttachment.G * 255.0);
                                color.b = Bridge.Int.clipu8(b * slot.B * regionAttachment.B * 255.0);
                            }
                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();
                            var regionUVs = regionAttachment.UVs;
                            ubi[vertexIndex].x = regionUVs[0];
                            ubi[vertexIndex].y = regionUVs[1];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[6];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[7];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[2];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[3];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[4];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[5];
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            }
                            if (x2 > bmax.x) {
                                bmax.x = x2;
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else if (x3 > bmax.x) {
                                bmax.x = x3;
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else if (x4 > bmax.x) {
                                bmax.x = x4;
                            }
                            if (x5 < bmin.x) {
                                bmin.x = x5;
                            } else if (x5 > bmax.x) {
                                bmax.x = x5;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            }
                            if (y2 > bmax.y) {
                                bmax.y = y2;
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else if (y3 > bmax.y) {
                                bmax.y = y3;
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else if (y4 > bmax.y) {
                                bmax.y = y4;
                            }
                            if (y5 < bmin.y) {
                                bmin.y = y5;
                            } else if (y5 > bmax.y) {
                                bmax.y = y5;
                            }
                            vertexIndex = (vertexIndex + 4) | 0;
                        } else {
                            var meshAttachment;
                            if (!(((meshAttachment = Bridge.as(attachment, Spine.MeshAttachment))) != null)) {
                                continue;
                            }
                            var verticesArrayLength = meshAttachment.WorldVerticesLength;
                            if (tempVerts.length < verticesArrayLength) {
                                tempVerts = ((this.tempVerts = System.Array.init(verticesArrayLength, 0, System.Single)));
                            }
                            meshAttachment.ComputeWorldVertices$1(slot, tempVerts);
                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot.A * meshAttachment.A * 255.0);
                                color.r = Bridge.Int.clipu8(r * slot.R * meshAttachment.R * color.a);
                                color.g = Bridge.Int.clipu8(g * slot.G * meshAttachment.G * color.a);
                                color.b = Bridge.Int.clipu8(b * slot.B * meshAttachment.B * color.a);
                                if (slot.Data.BlendMode === Spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot.A * meshAttachment.A * 255.0);
                                color.r = Bridge.Int.clipu8(r * slot.R * meshAttachment.R * 255.0);
                                color.g = Bridge.Int.clipu8(g * slot.G * meshAttachment.G * 255.0);
                                color.b = Bridge.Int.clipu8(b * slot.B * meshAttachment.B * 255.0);
                            }
                            var attachmentUVs = meshAttachment.UVs;
                            if (vertexIndex === 0) {
                                var fx = tempVerts[0];
                                var fy = tempVerts[1];
                                if (fx < bmin.x) {
                                    bmin.x = fx;
                                }
                                if (fx > bmax.x) {
                                    bmax.x = fx;
                                }
                                if (fy < bmin.y) {
                                    bmin.y = fy;
                                }
                                if (fy > bmax.y) {
                                    bmax.y = fy;
                                }
                            }
                            for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                var x = tempVerts[iii];
                                var y = tempVerts[((iii + 1) | 0)];
                                vbi[vertexIndex].x = x;
                                vbi[vertexIndex].y = y;
                                vbi[vertexIndex].z = z;
                                cbi[vertexIndex] = color.$clone();
                                ubi[vertexIndex].x = attachmentUVs[iii];
                                ubi[vertexIndex].y = attachmentUVs[((iii + 1) | 0)];
                                if (x < bmin.x) {
                                    bmin.x = x;
                                } else if (x > bmax.x) {
                                    bmax.x = x;
                                }
                                if (y < bmin.y) {
                                    bmin.y = y;
                                } else if (y > bmax.y) {
                                    bmax.y = y;
                                }
                                vertexIndex = (vertexIndex + 1) | 0;
                            }
                        }
                    }
                }
                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;
                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;
                if (!updateTriangles) {
                    return;
                }
                if (this.submeshes.Items.length < submeshInstructionCount) {
                    this.submeshes.Resize(submeshInstructionCount);
                    var i = 0;
                    for (var k = submeshInstructionCount; i < k; i = (i + 1) | 0) {
                        var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                        if (submeshBuffer == null) {
                            ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                        } else {
                            submeshBuffer.Clear(false);
                        }
                    }
                }
                var submeshInstructionsItems = instruction.submeshInstructions.Items;
                var attachmentFirstVertex = 0;
                for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                    var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                    var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                    var newTriangleCount = submeshInstruction.rawTriangleCount;
                    if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                        System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                    } else if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                        var sbi = currentSubmeshBuffer.Items;
                        var ei = newTriangleCount;
                        for (var nn2 = sbi.length; ei < nn2; ei = (ei + 1) | 0) {
                            sbi[ei] = 0;
                        }
                    }
                    currentSubmeshBuffer.Count = newTriangleCount;
                    var tris = currentSubmeshBuffer.Items;
                    var triangleIndex = 0;
                    var skeleton2 = submeshInstruction.skeleton;
                    var drawOrderItems2 = skeleton2.DrawOrder.Items;
                    var slotIndex3 = submeshInstruction.startSlot;
                    for (var endSlot2 = submeshInstruction.endSlot; slotIndex3 < endSlot2; slotIndex3 = (slotIndex3 + 1) | 0) {
                        var slot3 = drawOrderItems2[slotIndex3];
                        if (!slot3.Bone.Active) {
                            continue;
                        }
                        var attachment3 = drawOrderItems2[slotIndex3].Attachment;
                        if (Bridge.is(attachment3, Spine.RegionAttachment)) {
                            tris[triangleIndex] = attachmentFirstVertex;
                            tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                            tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                            tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                            tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                            tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                            triangleIndex = (triangleIndex + 6) | 0;
                            attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                        } else {
                            var meshAttachment3;
                            if (((meshAttachment3 = Bridge.as(attachment3, Spine.MeshAttachment))) != null) {
                                var attachmentTriangles = meshAttachment3.Triangles;
                                var ii = 0;
                                var nn = attachmentTriangles.length;
                                while (ii < nn) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                    ii = (ii + 1) | 0;
                                    triangleIndex = (triangleIndex + 1) | 0;
                                }

                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment3.WorldVerticesLength >> 1)) | 0;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var i = 0;
                for (var j = this.vertexBuffer.Count; i < j; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale );
                }
                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) {
                    return Bridge.getDefaultValue(UnityEngine.Bounds);
                }
                var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                var result = Bridge.getDefaultValue(UnityEngine.Bounds);
                result.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 );
                result.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 );
                return result;
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );
                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                if (this.uv2 == null) {
                    this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                }
                if (newVertexCount > this.uv2.Items.length) {
                    System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                }
                this.uv2.Count = ((this.uv3.Count = newVertexCount, newVertexCount));
                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;
                var listCount = this.vertexBuffer.Count;
                var vector3zero = pc.Vec3.ZERO.clone();
                for (var j = listCount; j < vbiLength; j = (j + 1) | 0) {
                    vbi[j] = vector3zero.$clone();
                }
                mesh.vertices = vbi;
                mesh.uv = ubi;
                mesh.colors32 = cbi;
                mesh.bounds = this.GetMeshBounds();
                if (this.settings.addNormals) {
                    var oldLength = 0;
                    if (this.normals == null) {
                        this.normals = System.Array.init(vbiLength, function (){
                            return new UnityEngine.Vector3();
                        }, UnityEngine.Vector3);
                    } else {
                        oldLength = this.normals.length;
                    }
                    if (oldLength !== vbiLength) {
                        System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        var localNormals = this.normals;
                        for (var i = oldLength; i < vbiLength; i = (i + 1) | 0) {
                            localNormals[i] = new pc.Vec3( 0, 0, -1 );
                        }
                    }
                    mesh.normals = this.normals;
                }
                if (this.settings.tintBlack && this.uv2 != null) {
                    if (vbiLength !== this.uv2.Items.length) {
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        this.uv2.Count = ((this.uv3.Count = vbiLength, vbiLength));
                    }
                    mesh.uv2 = this.uv2.Items;
                    mesh.uv3 = this.uv3.Items;
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;
                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount <= this.vertexBuffer.Items.length) {
                    return;
                }
                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, UnityEngine.Vector3);
                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                }, UnityEngine.Vector2);
                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                    return Bridge.getDefaultValue(UnityEngine.Color32);
                }, UnityEngine.Color32);
                if (inlcudeTintBlack) {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                    }
                    this.uv2.Resize(minimumVertexCount);
                    this.uv3.Resize(minimumVertexCount);
                }
                if (includeNormals) {
                    if (this.normals == null) {
                        this.normals = System.Array.init(minimumVertexCount, function (){
                            return new UnityEngine.Vector3();
                        }, UnityEngine.Vector3);
                    } else {
                        System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                    }
                }
                if (includeTangents) {
                    if (this.tangents == null) {
                        this.tangents = System.Array.init(minimumVertexCount, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    } else {
                        System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector4);
                        }, UnityEngine.Vector4);
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();
                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }
                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var result = Bridge.getDefaultValue(Spine.Unity.MeshGenerator.Settings);
                        result.pmaVertexColors = true;
                        result.zSpacing = 0.0;
                        result.useClipping = true;
                        result.tintBlack = false;
                        result.calculateTangents = false;
                        result.addNormals = false;
                        result.immutableTriangles = false;
                        return result.$clone();
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            vertexCount: 0,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }
                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }
                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                }
                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                if (newSize > this.submeshMaterials.Items.length) {
                    System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                }
                this.submeshMaterials.Count = newSize;
                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Dispose();
                    this.doubleBufferedMesh.GetNext().Dispose();
                    this.doubleBufferedMesh = null;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    Bridge.define("Spine.Unity.OnDemandTextureLoader", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            atlasAsset: null
        },
        events: {
            onTextureRequested: null,
            onTextureLoaded: null,
            onTextureUnloaded: null
        },
        methods: {
            addTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureRequested", this ); }

                this.addonTextureRequested(value);
            },
            removeTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureRequested", this ); }

                this.removeonTextureRequested(value);
            },
            addTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureLoaded", this ); }

                this.addonTextureLoaded(value);
            },
            removeTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureLoaded", this ); }

                this.removeonTextureLoaded(value);
            },
            addTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureUnloaded", this ); }

                this.addonTextureUnloaded(value);
            },
            removeTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded", this ); }

                this.removeonTextureUnloaded(value);
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned start.*/
            HasNullMainTexturesAssigned: function (nullTextureMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned", this ); }

                var $t;
                nullTextureMaterials.v = null;
                if (!UnityEngine.Object.op_Implicit(this.atlasAsset)) {
                    return false;
                }
                var anyNullTexture = false;
                $t = Bridge.getEnumerator(this.atlasAsset.Materials, UnityEngine.Material);
                try {
                    while ($t.moveNext()) {
                        var material = $t.Current;
                        if (material.mainTexture == null) {
                            anyNullTexture = true;
                            if (nullTextureMaterials.v == null) {
                                nullTextureMaterials.v = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                            }
                            nullTextureMaterials.v.add(material);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return anyNullTexture;
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested start.*/
            OnTextureRequested: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureRequested", this ); }

                if (!Bridge.staticEquals(this.onTextureRequested, null)) {
                    this.onTextureRequested(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded start.*/
            OnTextureLoaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureLoaded", this ); }

                if (!Bridge.staticEquals(this.onTextureLoaded, null)) {
                    this.onTextureLoaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded start.*/
            OnTextureUnloaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded", this ); }

                if (!Bridge.staticEquals(this.onTextureUnloaded, null)) {
                    this.onTextureUnloaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded end.*/


        }
    });
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.SettingsTriState start.*/
    Bridge.define("Spine.Unity.SettingsTriState", {
        $kind: 6,
        statics: {
            fields: {
                Disable: 0,
                Enable: 1,
                UseGlobalSetting: 2
            }
        }
    });
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;
                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }
                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                        return binary.ReadSkeletonData$1(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson.$ctor1(attachmentLoader), $t.Scale = scale, $t);
                    return json.ReadSkeletonData$1(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || ""), this);
                    }
                    this.Clear();
                    return null;
                }
                if (this.skeletonData != null) {
                    return this.skeletonData;
                }
                var atlasArray = this.GetAtlasArray();
                var attachmentLoader3;
                if (atlasArray.length !== 0) {
                    var attachmentLoader2 = new Spine.AtlasAttachmentLoader(atlasArray);
                    attachmentLoader3 = attachmentLoader2;
                } else {
                    var attachmentLoader21 = new Spine.Unity.RegionlessAttachmentLoader();
                    attachmentLoader3 = attachmentLoader21;
                }
                var attachmentLoader = attachmentLoader3;
                var skeletonDataScale = this.scale;
                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;
                try {
                    loadedSkeletonData = ((!hasBinaryExtension) ? Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale) : Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale));
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }
                if (loadedSkeletonData == null) {
                    return null;
                }
                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && (!this.isUpgradingBlendModeMaterials || !(Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset)))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }
                this.InitializeWithData(loadedSkeletonData);
                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new Spine.AnimationStateData(this.skeletonData);
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.stateData == null) {
                    return;
                }
                this.stateData.DefaultMix = this.defaultMix;
                var i = 0;
                for (var j = this.fromAnimation.length; i < j; i = (i + 1) | 0) {
                    var fromAnimationName = this.fromAnimation[i];
                    var toAnimationName = this.toAnimation[i];
                    if (fromAnimationName.length !== 0 && toAnimationName.length !== 0) {
                        this.stateData.SetMix$1(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (!(aa == null)) {
                        var a = aa.GetAtlas();
                        if (a != null) {
                            returnList.add(a);
                        }
                    }
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }
                var compatibleVersionString = "";
                var optionalOr = null;
                var array = this.compatibleVersions;
                $t = Bridge.getEnumerator(array);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.R, s.G, s.B, s.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.R, a.G, a.B, a.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.R, a.G, a.B, a.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.R, s.G, s.B, s.A );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.R2, s.G2, s.B2, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.A = color.a;
                    skeleton.R = color.r;
                    skeleton.G = color.g;
                    skeleton.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.A = color.a * 0.003921569;
                    skeleton.R = color.r * 0.003921569;
                    skeleton.G = color.g * 0.003921569;
                    skeleton.B = color.b * 0.003921569;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.A = color.a;
                    slot.R = color.r;
                    slot.G = color.g;
                    slot.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.A = color.a * 0.003921569;
                    slot.R = color.r * 0.003921569;
                    slot.G = color.g * 0.003921569;
                    slot.B = color.b * 0.003921569;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.A = color.a * 0.003921569;
                    attachment.R = color.r * 0.003921569;
                    attachment.G = color.g * 0.003921569;
                    attachment.B = color.b * 0.003921569;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.A = color.a;
                    attachment.R = color.r;
                    attachment.G = color.g;
                    attachment.B = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.A = color.a * 0.003921569;
                    attachment.R = color.r * 0.003921569;
                    attachment.G = color.g * 0.003921569;
                    attachment.B = color.b * 0.003921569;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.ScaleX = scale.x;
                    skeleton.ScaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var result = Bridge.getDefaultValue(UnityEngine.Matrix4x4);
                    result.e00 = bone.A;
                    result.e01 = bone.B;
                    result.e03 = bone.WorldX;
                    result.e10 = bone.C;
                    result.e11 = bone.D;
                    result.e13 = bone.WorldY;
                    result.e33 = 1.0;
                    return result.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.X = position.x;
                    bone.Y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.X, bone.Y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.WorldX, bone.WorldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = Bridge.getDefaultValue(UnityEngine.Vector2);
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.WorldX, bone.WorldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.WorldX * positionScale, bone.WorldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = Bridge.getDefaultValue(UnityEngine.Vector3);
                    skeletonSpacePosition.z = 0.0;
                    attachment.ComputeWorldPosition(slot.Bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = Bridge.getDefaultValue(UnityEngine.Vector3);
                    skeletonSpacePosition.z = 0.0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.C, bone.A) * 0.5;
                    return new pc.Quat( 0.0, 0.0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.Rotation * (0.0174532924) * 0.5;
                    return new pc.Quat( 0.0, 0.0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.ScaleX, skeleton.ScaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.A;
                    var b = bone.B;
                    var c = bone.C;
                    var d = bone.D;
                    var invDet = 1.0 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * (0.0 - b);
                    ic.v = invDet * (0.0 - c);
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = Bridge.getDefaultValue(UnityEngine.Vector2);
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.Parent == null) {
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    }
                    var parent = bone.Parent;
                    var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                    Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                    return parentLocal.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment;
                    if (((renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion))) != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }
                    if (rendererObject == null) {
                        return null;
                    }
                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.WorldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.Name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }
                    if (va.Bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.Vertices;
                        for (var j = 0; j < bufferTargetSize; j = (j + 1) | 0) {
                            var l = Bridge.Int.mul(j, 2);
                            buffer[j] = new pc.Vec2( localVerts[l], localVerts[((l + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.ComputeWorldVertices$1(slot, floats);
                        var sb = slot.Bone;
                        var bwx = sb.WorldX;
                        var bwy = sb.WorldY;
                        var ia = { };
                        var ib = { };
                        var ic = { };
                        var id = { };
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var k = Bridge.Int.mul(i, 2);
                            var x = floats[k] - bwx;
                            var y = floats[((k + 1) | 0)] - bwy;
                            buffer[i] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }
                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.WorldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.Name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }
                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.ComputeWorldVertices$1(slot, floats);
                    var i = 0;
                    for (var k = worldVertsLength >> 1; i < k; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }
                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };
                    if (this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial) && !(!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial))) {
                        this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };
                    if (this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture) && !(!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture))) {
                        this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }
                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    return (clipLength - time < 0.0333333351) ? clipLength : time;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = 1.0 - normalizedTime;
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = (loop ? (normalizedTime % 1.0 + 1.0) : 0.0);
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, Spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;
                this.previousAnimations.clear();
                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.Name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < 0.0001) {
                    return false;
                }
                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0.0);
                weight = (useClipWeight1 ? layerWeight : weight);
                clip.Apply(skeleton, 0.0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var clipWeight = (interpolateWeightTo1 ? ((info.weight + 1.0) * 0.5) : info.weight);
                var weight = clipWeight * layerWeight;
                if (weight < 0.0001) {
                    return false;
                }
                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0.0);
                weight = (useClipWeight1 ? layerWeight : weight);
                clip.Apply(skeleton, 0.0, time, info.clip.isLooping, null, weight, layerBlendMode, Spine.MixDirection.In);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }

                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - UnityEngine.Time.deltaTime * speedFactor;
                var clipDuration = clip.Duration;
                if (isLooping && clipDuration !== 0.0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0.0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }

                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === Spine.MixBlend.Add;
                        }
                        this.layerMixModes[layer] = ((!isAdditiveLayer) ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix);
                    }
                }
                this.InitClipInfosForLayers();
                var layer2 = 0;
                for (var j = this.animator.layerCount; layer2 < j; layer2 = (layer2 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer2);
                }
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    var i = 0;
                    for (var l = previousAnimations.Count; i < l; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).Apply(skeleton, 0.0, 0.0, false, null, 0.0, Spine.MixBlend.Setup, Spine.MixDirection.Out);
                    }
                    previousAnimations.clear();
                    var layer4 = 0;
                    for (var m = this.animator.layerCount; layer4 < m; layer4 = (layer4 + 1) | 0) {
                        var layerWeight2 = ((layer4 === 0) ? 1.0 : this.animator.GetLayerWeight(layer4));
                        if (layerWeight2 <= 0.0) {
                            continue;
                        }
                        var hasNext2 = this.animator.GetNextAnimatorStateInfo(layer4).fullPathHash !== 0;
                        var isInterruptionActive2 = { };
                        var clipInfoCount2 = { };
                        var nextClipInfoCount2 = { };
                        var interruptingClipInfoCount2 = { };
                        var clipInfo2 = { };
                        var nextClipInfo2 = { };
                        var interruptingClipInfo2 = { };
                        var shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer4, isInterruptionActive2, clipInfoCount2, nextClipInfoCount2, interruptingClipInfoCount2, clipInfo2, nextClipInfo2, interruptingClipInfo2, shallInterpolateWeightTo1);
                        for (var c7 = 0; c7 < clipInfoCount2.v; c7 = (c7 + 1) | 0) {
                            var info = System.Array.getItem(clipInfo2.v, c7, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight2;
                            if (!(weight < 0.0001)) {
                                var clip = this.GetAnimation(info.clip);
                                if (clip != null) {
                                    previousAnimations.add(clip);
                                }
                            }
                        }
                        if (hasNext2) {
                            for (var c6 = 0; c6 < nextClipInfoCount2.v; c6 = (c6 + 1) | 0) {
                                var info3 = System.Array.getItem(nextClipInfo2.v, c6, UnityEngine.AnimatorClipInfo).$clone();
                                var weight3 = info3.weight * layerWeight2;
                                if (!(weight3 < 0.0001)) {
                                    var clip3 = this.GetAnimation(info3.clip);
                                    if (clip3 != null) {
                                        previousAnimations.add(clip3);
                                    }
                                }
                            }
                        }
                        if (!isInterruptionActive2.v) {
                            continue;
                        }
                        for (var c5 = 0; c5 < interruptingClipInfoCount2.v; c5 = (c5 + 1) | 0) {
                            var info2 = System.Array.getItem(interruptingClipInfo2.v, c5, UnityEngine.AnimatorClipInfo).$clone();
                            var clipWeight = (shallInterpolateWeightTo1.v ? ((info2.weight + 1.0) * 0.5) : info2.weight);
                            var weight2 = clipWeight * layerWeight2;
                            if (!(weight2 < 0.0001)) {
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }
                var layer3 = 0;
                for (var k = this.animator.layerCount; layer3 < k; layer3 = (layer3 + 1) | 0) {
                    var layerWeight = ((layer3 === 0) ? 1.0 : this.animator.GetLayerWeight(layer3));
                    var isInterruptionActive = { };
                    var stateInfo = { };
                    var nextStateInfo = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition);
                    var hasNext = nextStateInfo.v.fullPathHash !== 0;
                    var clipInfoCount = { };
                    var nextClipInfoCount = { };
                    var interruptingClipInfoCount = { };
                    var clipInfo = { };
                    var nextClipInfo = { };
                    var interruptingClipInfo = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, interpolateWeightTo1);
                    var layerBlendMode = ((layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : Spine.MixBlend.Replace);
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        for (var c4 = 0; c4 < clipInfoCount.v; c4 = (c4 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo.v, c4, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight, layerBlendMode);
                        }
                        if (hasNext) {
                            for (var c3 = 0; c3 < nextClipInfoCount.v; c3 = (c3 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo.v, c3, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo.v, layer3, layerWeight, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                        continue;
                    }
                    var c;
                    for (c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                        if (this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight, layerBlendMode, true)) {
                            c = (c + 1) | 0;
                            break;
                        }
                    }
                    for (; c < clipInfoCount.v; c = (c + 1) | 0) {
                        this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight, layerBlendMode);
                    }
                    c = 0;
                    if (hasNext) {
                        if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                            for (; c < nextClipInfoCount.v; c = (c + 1) | 0) {
                                if (this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo.v, layer3, layerWeight, layerBlendMode, true)) {
                                    c = (c + 1) | 0;
                                    break;
                                }
                            }
                        }
                        for (; c < nextClipInfoCount.v; c = (c + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo.v, layer3, layerWeight, layerBlendMode)) {
                            }
                        }
                    }
                    c = 0;
                    if (!isInterruptionActive.v) {
                        continue;
                    }
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                        for (; c < interruptingClipInfoCount.v; c = (c + 1) | 0) {
                            if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight, layerBlendMode, interruptingClipTimeAddition.v, true)) {
                                c = (c + 1) | 0;
                                break;
                            }
                        }
                    }
                    for (; c < interruptingClipInfoCount.v; c = (c + 1) | 0) {
                        this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight, layerBlendMode, interruptingClipTimeAddition.v);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0.0);
                }
                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0.0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length >= this.animator.layerCount) {
                    return;
                }
                System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                var layer = 0;
                for (var i = this.animator.layerCount; layer < i; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                var layer = 0;
                for (var i = this.layerClipInfos.length; layer < i; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        continue;
                    }
                    this.layerClipInfos[layer].isInterruptionActive = false;
                    this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                    this.layerClipInfos[layer].clipInfos.clear();
                    this.layerClipInfos[layer].nextClipInfos.clear();
                    this.layerClipInfos[layer].interruptingClipInfos.clear();
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    if (layerBlendMode === Spine.MixBlend.Add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                }
                return (layerBlendMode !== Spine.MixBlend.Add) ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }

                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);
                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;
                layerInfos.isInterruptionActive = clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0;
                if (layerInfos.isInterruptionActive) {
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                    return;
                }
                layerInfos.clipInfoCount = clipInfoCount;
                layerInfos.nextClipInfoCount = nextClipInfoCount;
                layerInfos.interruptingClipInfoCount = 0;
                layerInfos.isLastFrameOfInterruption = false;
                if (clipInfos.Capacity < clipInfoCount) {
                    clipInfos.Capacity = clipInfoCount;
                }
                if (nextClipInfos.Capacity < nextClipInfoCount) {
                    nextClipInfos.Capacity = nextClipInfoCount;
                }
                this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);
                layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }

                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;
                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;
                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = (isInterruptionActive.v ? layerInfos.interruptingClipInfos : null);
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }

                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;
                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = (layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0.0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0.0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            rootMotionTranslateXPerY: 0,
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            ProcessRootMotionOverride: null,
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get", this ); }

                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            PreviousRigidbodyRootMotion2D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get", this ); }

                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            PreviousRigidbodyRootMotion3D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get", this ); }

                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            AdditionalRigidbody2DMovement: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get", this ); }

                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set", this ); }

                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get", this ); }

                    var skeletonAnimation;
                    if (((skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation))) != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get", this ); }

                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1.0;
                this.rootMotionScaleY = 1.0;
                this.rootMotionScaleRotation = 1.0;
                this.rootMotionTranslateXPerY = 0.0;
                this.rootMotionTranslateYPerX = 0.0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.X, this.rootMotionBone.Y );
                    this.initialOffsetRotation = this.rootMotionBone.Rotation;
                }
                var skeletonAnimation;
                if (((skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation))) != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                if (this.isActiveAndEnabled && !this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate", this ); }

                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;
                if (Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = deltaTime * deltaTime;
                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }
                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.rigidBody2D.position.x, this.rigidBody2D.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.rigidBody.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }
                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v.$clone());
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.UpdateWorldTransform();
                }
                this.ClearRigidbodyTempMovement();
                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta", this ); }

                return 0.0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.FindBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.Data.Index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.RootBone;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }
                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }
                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0.0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0.0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }
                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }
                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0.0, animation.Duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }

                var $t, $t1;
                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }
                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex2 = $t.Current;
                        var constraint2 = transformConstraintsItems[constraintIndex2];
                        this.ApplyConstraintToPos(animation, constraint2, constraintIndex2, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint2, constraintIndex2, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0.0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0.0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex = $t1.Current;
                            var constraint = transformConstraintsItems[constraintIndex];
                            this.ApplyConstraintToPos(animation, constraint, constraintIndex, animation.Duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint, constraintIndex, 0.0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation", this ); }

                return this.GetAnimationRootMotionRotation$1(0.0, animation.Duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1", this ); }

                var $t, $t1;
                if (startTime === endTime) {
                    return 0.0;
                }
                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.RotateTimeline, animation, this.rootMotionBoneIndex);
                var endRotation = { v : 0.0 };
                var startRotation = { v : 0.0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex2 = $t.Current;
                        var constraint2 = transformConstraintsItems[constraintIndex2];
                        this.ApplyConstraintToRotation(animation, constraint2, constraintIndex2, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint2, constraintIndex2, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;
                if (startTime > endTime) {
                    var loopRotation = { v : 0.0 };
                    var zeroPos = { v : 0.0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.Duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0.0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex = $t1.Current;
                            var constraint = transformConstraintsItems[constraintIndex];
                            this.ApplyConstraintToRotation(animation, constraint, constraintIndex, animation.Duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint, constraintIndex, 0.0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline != null) {
                    var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                    var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                    var constraintPos = new UnityEngine.Vector2();
                    if (useLastConstraintPos) {
                        constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                    } else {
                        var targetBone = constraint.Target;
                        constraintPos = new pc.Vec2( targetBone.X, targetBone.Y );
                    }
                    pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline != null) {
                    var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                    var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                    var constraintRotation;
                    if (useLastConstraintRotation) {
                        constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                    } else {
                        var targetBone = constraint.Target;
                        constraintRotation = targetBone.Rotation;
                    }
                    rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.Target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.X, targetBone.Y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.Target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.Rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = Bridge.getDefaultValue(Spine.Unity.SkeletonRootMotionBase.RootMotionInfo);
                var duration = animation.Duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0.0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(Spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0.0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                var i = 0;
                for (var j = constraints.Count; i < j; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.Target;
                        var constraintPos = new pc.Vec2( targetBone.X, targetBone.Y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.Rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }

                if (startTime > endTime) {
                    return Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.Duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) ).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0.0) )) );
                }
                if (startTime !== endTime) {
                    return Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                }
                return pc.Vec2.ZERO.clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.Parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (this.isActiveAndEnabled) {
                    var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    var totalScale = { v : new UnityEngine.Vector2() };
                    var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                    var skeletonRotationDelta = 0.0;
                    if (this.transformRotation) {
                        var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                        boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                        skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v.$clone());
                    }
                    var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                    this.ApplyRootMotion(skeletonTranslationDelta.$clone(), skeletonRotationDelta, parentBoneScale.v.$clone(), usesFixedUpdate);
                    if (usesFixedUpdate) {
                        this.PhysicsUpdate(usesFixedUpdate);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }

                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;
                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.$clone().clone().mul( addedWorldRotation.$clone() );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale2 = this.transform.lossyScale.$clone();
                            var rotationSign2 = ((lossyScale2.x * lossyScale2.y > 0.0) ? 1 : (-1));
                            this.rigidbody2DRotation += rotationSign2 * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale = this.transform.lossyScale.$clone();
                        var rotationSign = ((lossyScale.x * lossyScale.y > 0.0) ? 1 : (-1));
                        this.transform.Rotate(0.0, 0.0, rotationSign * skeletonRotationDelta);
                    }
                }
                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement.$clone(), this.tempSkeletonRotation, parentBoneScale.$clone());
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale.$clone());
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints", this ); }

                var $t;
                this.rootMotionBone.AX = this.rootMotionBone.X;
                this.rootMotionBone.AY = this.rootMotionBone.Y;
                this.rootMotionBone.AppliedRotation = this.rootMotionBone.Rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        constraint.Update();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.ScaleX;
                totalScale.y *= skeleton.ScaleY;
                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.Parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.ScaleX;
                    parentBoneScale.v.y *= scaleBone.ScaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                return totalScale.$clone().scale( this.AdditionalScale );
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );
                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );
                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;
                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta", this ); }

                var rotationSign = ((totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0.0) ? 1 : (-1));
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;
                this.ApplyTransformConstraints();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.X = displacementSkeletonSpace.x / skeleton.ScaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.Y = displacementSkeletonSpace.y / skeleton.ScaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = ((skeleton.ScaleX * skeleton.ScaleY > 0.0) ? 1 : (-1));
                                topLevelBone.Rotation = rotationSign * rotationSkeletonSpace;
                            }
                            continue;
                        }
                        var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                        var rootMotionBoneX = (useAppliedTransform ? this.rootMotionBone.AX : this.rootMotionBone.X);
                        var rootMotionBoneY = (useAppliedTransform ? this.rootMotionBone.AY : this.rootMotionBone.Y);
                        var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                        var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;
                        if (this.transformPositionX) {
                            topLevelBone.X = displacementSkeletonSpace.x / skeleton.ScaleX + offsetX;
                        }
                        if (this.transformPositionY) {
                            topLevelBone.Y = displacementSkeletonSpace.y / skeleton.ScaleY + offsetY;
                        }
                        if (this.transformRotation) {
                            var rootMotionBoneRotation = (useAppliedTransform ? this.rootMotionBone.AppliedRotation : this.rootMotionBone.Rotation);
                            var parentBoneRotationSign = ((parentBoneScale.x * parentBoneScale.y > 0.0) ? 1 : (-1));
                            var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;
                            var skeletonRotationSign = ((skeleton.ScaleX * skeleton.ScaleY > 0.0) ? 1 : (-1));
                            topLevelBone.Rotation = rotationSkeletonSpace * skeletonRotationSign + offsetRotation;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0.0, parentBoneScale.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement", this ); }

                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0.0;
                this.tempSkeletonRotation = 0.0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;
                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();
                    if (this.meshGenerator == null) {
                        this.meshGenerator = new Spine.Unity.MeshGenerator();
                        this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                        this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                        this.currentInstructions.Clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#OnDestroy", this ); }

                if (this.buffers != null) {
                    this.buffers.Dispose();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i].$clone(), updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }
                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);
                var mesh = smartMesh.mesh;
                if (this.meshGenerator.VertexCount <= 0) {
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }
                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);
                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            materialsMaskDisabled: null,
            materialsInsideMask: null,
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length !== 0 || this.materialsInsideMask.length !== 0 || this.materialsOutsideMask.length !== 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (!slotMaterialOverride.overrideDisabled && !System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                        if (slotObject != null) {
                            this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (!System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        var slotObject = this.skeletonRenderer.skeleton.FindSlot(slotMaterialOverride.slotName);
                        var currentMaterial = { };
                        if (slotObject != null && this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial) && !(!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material))) {
                            this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (!atlasMaterialOverride.overrideDisabled) {
                        this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };
                    if (this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial) && !(!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial))) {
                        this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }
                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }

                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    }
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }
                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }
                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    }
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;
                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var j = 0; j < attachmentCountB; j = (j + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[j], attachmentsB[j])) {
                            return true;
                        }
                    }
                    for (var i = 0; i < submeshCountB; i = (i + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i].$clone();
                        var submeshB = submeshInstructionsItemsB[i].$clone();
                        if (submeshA.rawVertexCount !== submeshB.rawVertexCount || submeshA.startSlot !== submeshB.startSlot || submeshA.endSlot !== submeshB.endSlot || submeshA.rawTriangleCount !== submeshB.rawTriangleCount || submeshA.rawFirstVertexIndex !== submeshB.rawFirstVertexIndex) {
                            return true;
                        }
                    }
                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(Spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear();
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var $t;
                var runningVertexCount = 0;
                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var j = 0; j < submeshCount; j = (j + 1) | 0) {
                    var instruction = (($t = instructionsItems[((startSubmesh + j) | 0)].$clone(), submeshesItems[j] = $t.$clone(), $t));
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[j].rawFirstVertexIndex = runningVertexCount;
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0;
                }
                this.rawVertexCount = runningVertexCount;
                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;
                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i = 0; i < attachmentCount; i = (i + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i) | 0)];
                    if (slot.Bone.Active) {
                        attachmentsItems[i] = slot.Attachment;
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;
                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);
                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }
                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;
                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }
                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;
                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + Bridge.Int.mul(i, sortingOrderIncrement)) | 0;
                        componentRenderers.add(spr);
                    }
                    srs.OnEnable();
                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }
                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        Bridge.ensureBaseProperty(this, "enabled").$UnityEngine$Component$enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }
                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }
                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);
                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;
                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;
                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (!(UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null))) {
                            var mr = currentRenderer.MeshRenderer;
                            mr.lightProbeUsage = lightProbeUsage;
                            mr.receiveShadows = receiveShadows;
                            mr.reflectionProbeUsage = reflectionProbeUsage;
                            mr.shadowCastingMode = shadowCastingMode;
                            mr.motionVectorGenerationMode = motionVectorGenerationMode;
                            mr.probeAnchor = probeAnchor;
                        }
                    }
                }
                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                if (!(UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null))) {
                    this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    this.skeletonRenderer.LateUpdateMesh();
                    this.ClearPartsRendererMeshes();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }
                var assignPropertyBlock = this.copyPropertyBlock && this.mainMeshRenderer.HasPropertyBlock();
                if (assignPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }
                var settings2 = Bridge.getDefaultValue(Spine.Unity.MeshGenerator.Settings);
                settings2.addNormals = this.skeletonRenderer.addNormals;
                settings2.calculateTangents = this.skeletonRenderer.calculateTangents;
                settings2.immutableTriangles = false;
                settings2.pmaVertexColors = this.skeletonRenderer.pmaVertexColors;
                settings2.tintBlack = this.skeletonRenderer.tintBlack;
                settings2.useClipping = true;
                settings2.zSpacing = this.skeletonRenderer.zSpacing;
                var settings = settings2.$clone();
                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;
                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                var si = 0;
                var start = 0;
                for (; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (!(UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) && (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction)) {
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();
                        if (assignPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));
                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex >= rendererCount) {
                            break;
                        }
                        currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    }
                }
                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnDisable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                this.canvasRenderer.cull = true;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                this.canvasRenderer.cull = false;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = (System.String.isNullOrEmpty(skinName) ? skeleton.Data.DefaultSkin : skeleton.Data.FindSkin(skinName));
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }
                    var slot = skeleton.FindSlot(slotName);
                    var attachment = ((slot != null) ? skin.GetAttachment(slot.Data.Index, attachmentName) : null);
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.Name]);
                        return null;
                    }
                    var box;
                    if (((box = Bridge.as(attachment, Spine.BoundingBoxAttachment))) != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.Name, box, slot, parent, isTrigger);
                    }
                    UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                    return null;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.Name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        var i = 0;
                        for (var j = verts.length; i < j; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.Vertices;
                    var floatCount = floats.length;
                    var bounds = Bridge.getDefaultValue(UnityEngine.Bounds);
                    bounds.center = new pc.Vec3( floats[0], floats[1], 0.0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0.0 ) );
                    }
                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );
                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent)));
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.ScaleX), Math.abs(skeleton.ScaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( (!(skeleton.ScaleY > 0.0)) ? 180 : 0, (!(skeleton.ScaleX > 0.0)) ? 180 : 0, 0.0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.ScaleX, skeleton.ScaleY, 1.0 );
                    }
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.positionScale = this.skeletonGraphic.MeshScale;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation)));
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : ((UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent)));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }
                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }
                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (!this.boneComponents.contains(bone)) {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (!this.constraintComponents.contains(constraint)) {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }
                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    var k = 0;
                    for (var n = ikConstraints.Count; k < n; k = (k + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[k].Target);
                    }
                    var transformConstraints = skeleton.TransformConstraints;
                    var j = 0;
                    for (var m = transformConstraints.Count; j < m; j = (j + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[j].Target);
                    }
                    var boneComponents = this.boneComponents;
                    var i = 0;
                    for (var l = boneComponents.Count; i < l; i = (i + 1) | 0) {
                        var b = boneComponents.getItem(i);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override);
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }
                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);
                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }
                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }
                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }
                var boneComponents = this.boneComponents;
                if (boneComponents != null) {
                    var i = 0;
                    for (var j = boneComponents.Count; i < j; i = (i + 1) | 0) {
                        boneComponents.getItem(i).transformLerpComplete = false;
                    }
                    this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                var i = 0;
                for (var j = this.constraintComponents.Count; i < j; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }
                var boneComponents = this.boneComponents;
                if (boneComponents != null) {
                    var i = 0;
                    for (var j = boneComponents.Count; i < j; i = (i + 1) | 0) {
                        boneComponents.getItem(i).DoUpdate(phase);
                    }
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }
                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }
                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );
                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBone(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.RootBone, this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);
                var childrenBones = bone.Children;
                var i = 0;
                for (var j = childrenBones.Count; i < j; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.Data.Name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }
                var goTransform = go.transform;
                goTransform.SetParent(parent);
                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.Data.Name;
                b.valid = true;
                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, b.bone.AppliedRotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.X * this.positionScale, b.bone.Y * this.positionScale, 0.0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.ScaleX, b.bone.ScaleY, 0.0 );
                }
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.Data.TransformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (this.valid) {
                    this.skeletonTransform = this.hierarchy.transform;
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (!(UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null))) {
                    this.hierarchy.RegisterBone(this);
                    this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }
                var skeleton = this.hierarchy.Skeleton;
                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.FindBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.Active) {
                    return;
                }
                var positionScale = this.hierarchy.PositionScale;
                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.ScaleX * skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.X * positionScale, this.bone.Y * positionScale, 0.0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.Data.TransformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, this.bone.Rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + this.bone.WorldRotationX * skeletonFlipRotation );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ScaleX, this.bone.ScaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.AX * positionScale, this.bone.AY * positionScale, 0.0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.Data.TransformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0.0, 0.0, this.bone.AppliedRotation );
                                } else {
                                    var euler2 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler2.x, euler2.y, euler2.z + this.bone.WorldRotationX * skeletonFlipRotation );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.AScaleX, this.bone.AScaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }
                } else {
                    if (this.mode !== Spine.Unity.SkeletonUtilityBone.Mode.Override || this.transformLerpComplete) {
                        return;
                    }
                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.X = pc.math.lerp(this.bone.X, clp.x, this.overrideAlpha);
                            this.bone.Y = pc.math.lerp(this.bone.Y, clp.y, this.overrideAlpha);
                        }
                        if (this.rotation) {
                            var angle2 = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle2;
                            this.bone.AppliedRotation = angle2;
                        }
                        if (this.scale) {
                            var cls2 = thisTransform.localScale.$clone();
                            this.bone.ScaleX = pc.math.lerp(this.bone.ScaleX, cls2.x, this.overrideAlpha);
                            this.bone.ScaleY = pc.math.lerp(this.bone.ScaleY, cls2.y, this.overrideAlpha);
                        }
                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }
                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.X = pc.math.lerp(this.bone.X, pos.x, this.overrideAlpha);
                            this.bone.Y = pc.math.lerp(this.bone.Y, pos.y, this.overrideAlpha);
                        }
                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.Rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.Rotation = angle;
                            this.bone.AppliedRotation = angle;
                        }
                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.ScaleX = pc.math.lerp(this.bone.ScaleX, cls.x, this.overrideAlpha);
                            this.bone.ScaleY = pc.math.lerp(this.bone.ScaleY, cls.y, this.overrideAlpha);
                        }
                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }
                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.Skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                }
                if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var i = new UnityEngine.Mesh.ctor();
                    i.MarkDynamic();
                    i.name = "Skeleton Mesh";
                    i.hideFlags = 20;
                    return i;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), (this.material == null) ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2,
                InLateUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                    return false;
                }
                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }
                if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                    trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                }
                if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                    trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                }
                if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                }
                if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                    trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                }
                if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                    trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimation#HandleComplete", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }
                if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }
                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }
                if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }
                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | Bridge.referenceEquals(e.Data.Name, this.m_EventName));
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                }
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | Bridge.referenceEquals(e.Data, this.m_TargetEvent));
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                }
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                    return false;
                }
                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#init", this ); }

                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#ctor", this ); }

                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#HandleEnd", this ); }

                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#SafeSubscribe", this ); }

                if (trackEntry == null) {
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            NowWaitFor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#NowWaitFor", this ); }

                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                    return false;
                }
                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineTrackEntryEnd#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*UICLose start.*/
    Bridge.define("UICLose", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            text: null
        },
        methods: {
            /*UICLose.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "UICLose#TriggerCTA", this ); }

                UnityEngine.Debug.Log$1("triggerCTA");
                Luna.Unity.Playable.InstallFullGame("https://play.google.com/store/apps/details?id=com.gamee.detective.mansion.pullpin.puzzle");
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*UICLose.TriggerCTA end.*/

            /*UICLose.OnShowed start.*/
            OnShowed: function () {
if ( TRACE ) { TRACE( "UICLose#OnShowed", this ); }

                var scale = this.text.localScale.$clone().sub( new pc.Vec3( 0.1, 0.1, 0.1 ) );
                DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.text, scale.$clone(), 0.4), DG.Tweening.Ease.Linear), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*UICLose.OnShowed end.*/


        }
    });
    /*UICLose end.*/

    /*UICWin start.*/
    Bridge.define("UICWin", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            items: null
        },
        methods: {
            /*UICWin.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "UICWin#TriggerCTA", this ); }

                UnityEngine.Debug.Log$1("triggerCTA");
                Luna.Unity.Playable.InstallFullGame("https://play.google.com/store/apps/details?id=com.gamee.detective.mansion.pullpin.puzzle");
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*UICWin.TriggerCTA end.*/

            /*UICWin.OnShowed start.*/
            OnShowed: function () {
if ( TRACE ) { TRACE( "UICWin#OnShowed", this ); }

                var $t;
                var defaultScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                var array = this.items;
                $t = Bridge.getEnumerator(array);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        item.localScale = item.localScale.$clone().sub( new pc.Vec3( 0.8, 0.8, 0.8 ) );
                        DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(item, defaultScale.$clone(), 0.1), DG.Tweening.Ease.Linear);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*UICWin.OnShowed end.*/


        }
    });
    /*UICWin end.*/

    /*ViewportHandler start.*/
    Bridge.define("ViewportHandler", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            wireColor: null,
            UnitsSize: 0,
            constraint: 0,
            camera: null,
            _width: 0,
            _height: 0,
            _bl: null,
            _bc: null,
            _br: null,
            _ml: null,
            _mc: null,
            _mr: null,
            _tl: null,
            _tc: null,
            _tr: null
        },
        props: {
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Width#get", this ); }

                    return this._width;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Height#get", this ); }

                    return this._height;
                }
            },
            BottomLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomLeft#get", this ); }

                    return this._bl.$clone();
                }
            },
            BottomCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomCenter#get", this ); }

                    return this._bc.$clone();
                }
            },
            BottomRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#BottomRight#get", this ); }

                    return this._br.$clone();
                }
            },
            MiddleLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleLeft#get", this ); }

                    return this._ml.$clone();
                }
            },
            MiddleCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleCenter#get", this ); }

                    return this._mc.$clone();
                }
            },
            MiddleRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#MiddleRight#get", this ); }

                    return this._mr.$clone();
                }
            },
            TopLeft: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopLeft#get", this ); }

                    return this._tl.$clone();
                }
            },
            TopCenter: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopCenter#get", this ); }

                    return this._tc.$clone();
                }
            },
            TopRight: {
                get: function () {
if ( TRACE ) { TRACE( "ViewportHandler#TopRight#get", this ); }

                    return this._tr.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ViewportHandler#init", this ); }

                this.wireColor = new UnityEngine.Color();
                this._bl = new UnityEngine.Vector3();
                this._bc = new UnityEngine.Vector3();
                this._br = new UnityEngine.Vector3();
                this._ml = new UnityEngine.Vector3();
                this._mc = new UnityEngine.Vector3();
                this._mr = new UnityEngine.Vector3();
                this._tl = new UnityEngine.Vector3();
                this._tc = new UnityEngine.Vector3();
                this._tr = new UnityEngine.Vector3();
                this.wireColor = new pc.Color( 1, 1, 1, 1 );
                this.UnitsSize = 1.0;
                this.constraint = ViewportHandler.Constraint.Portrait;
            }
        },
        methods: {
            /*ViewportHandler.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Awake", this ); }

                this.camera = this.GetComponent(UnityEngine.Camera);
                ViewportHandler.Instance = this;
                this.ComputeResolution();
            },
            /*ViewportHandler.Awake end.*/

            /*ViewportHandler.ComputeResolution start.*/
            ComputeResolution: function () {
if ( TRACE ) { TRACE( "ViewportHandler#ComputeResolution", this ); }

                if (this.constraint === ViewportHandler.Constraint.Landscape) {
                    this.camera.orthographicSize = 1.0 / this.camera.aspect * this.UnitsSize / 2.0;
                } else {
                    this.camera.orthographicSize = this.UnitsSize / 2.0;
                }
                this._height = 2.0 * this.camera.orthographicSize;
                this._width = this._height * this.camera.aspect;
                var cameraX = this.camera.transform.position.x;
                var cameraY = this.camera.transform.position.y;
                var leftX = cameraX - this._width / 2.0;
                var rightX = cameraX + this._width / 2.0;
                var topY = cameraY + this._height / 2.0;
                var bottomY = cameraY - this._height / 2.0;
                this._bl = new pc.Vec3( leftX, bottomY, 0.0 );
                this._bc = new pc.Vec3( cameraX, bottomY, 0.0 );
                this._br = new pc.Vec3( rightX, bottomY, 0.0 );
                this._ml = new pc.Vec3( leftX, cameraY, 0.0 );
                this._mc = new pc.Vec3( cameraX, cameraY, 0.0 );
                this._mr = new pc.Vec3( rightX, cameraY, 0.0 );
                this._tl = new pc.Vec3( leftX, topY, 0.0 );
                this._tc = new pc.Vec3( cameraX, topY, 0.0 );
                this._tr = new pc.Vec3( rightX, topY, 0.0 );
            },
            /*ViewportHandler.ComputeResolution end.*/

            /*ViewportHandler.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ViewportHandler#Update", this ); }
 },
            /*ViewportHandler.Update end.*/

            /*ViewportHandler.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "ViewportHandler#OnDrawGizmos", this ); }

                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).color = this.wireColor.$clone();
                var temp = pc.generateStubProxy( 'UnityEngine.Gizmos', true ).reportProperty( 'UnityEngine.Gizmos.matrix', null );
                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).matrix = new pc.Mat4().setTRS( this.transform.position, this.transform.rotation, new pc.Vec3( 1, 1, 1 ) );
                if (this.camera.orthographic) {
                    var spread = this.camera.farClipPlane - this.camera.nearClipPlane;
                    var center = (this.camera.farClipPlane + this.camera.nearClipPlane) * 0.5;
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawWireCube', null );
                } else {
                    pc.stubProxy.reportMethod( 'UnityEngine.Gizmos.DrawFrustum', null );
                }
                pc.generateStubProxy( 'UnityEngine.Gizmos', true ).matrix = temp.$clone();
            },
            /*ViewportHandler.OnDrawGizmos end.*/


        }
    });
    /*ViewportHandler end.*/

    /*ViewportHandler+Constraint start.*/
    Bridge.define("ViewportHandler.Constraint", {
        $kind: 1006,
        statics: {
            fields: {
                Landscape: 0,
                Portrait: 1
            }
        }
    });
    /*ViewportHandler+Constraint end.*/

    /*CameraFollower start.*/
    Bridge.define("CameraFollower", {
        inherits: function () {
if ( TRACE ) { TRACE( "CameraFollower#inherits", this ); }
 return [Singleton$1(CameraFollower)]; },
        fields: {
            viewportHandler: null
        },
        methods: {
            /*CameraFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CameraFollower#Awake", this ); }

                this.transform.position = new pc.Vec3( 0.0, 0.0, -10.0 );
                this.viewportHandler.UnitsSize = 10.0;
            },
            /*CameraFollower.Awake end.*/

            /*CameraFollower.OnLose start.*/
            OnLose: function () {
if ( TRACE ) { TRACE( "CameraFollower#OnLose", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    goal,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.viewportHandler.enabled = false;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(0.01);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.Camera.main.orthographicSize = 3.5;
                                        goal = new pc.Vec3( -1.4, -1.5, -10.0 );
                                        DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.transform, goal.$clone(), 0.5), DG.Tweening.Ease.Linear);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*CameraFollower.OnLose end.*/


        }
    });
    /*CameraFollower end.*/

    /*LevelManager start.*/
    Bridge.define("LevelManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "LevelManager#inherits", this ); }
 return [Singleton$1(LevelManager)]; },
        fields: {
            levelPrefab: null,
            isEndCard: false,
            isEndGame: false,
            currentLevel: null,
            loseCount: 0
        },
        props: {
            IsEndGame: {
                get: function () {
if ( TRACE ) { TRACE( "LevelManager#IsEndGame#get", this ); }

                    return this.isEndGame;
                }
            },
            IsEndCard: {
                get: function () {
if ( TRACE ) { TRACE( "LevelManager#IsEndCard#get", this ); }

                    return this.isEndCard;
                }
            },
            CurrentLevel: {
                get: function () {
if ( TRACE ) { TRACE( "LevelManager#CurrentLevel#get", this ); }

                    return this.currentLevel;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelManager#init", this ); }

                this.isEndGame = false;
            }
        },
        methods: {
            /*LevelManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "LevelManager#Start", this ); }

                this.loseCount = 0;
                this.CreateLevel();
            },
            /*LevelManager.Start end.*/

            /*LevelManager.CreateLevel start.*/
            CreateLevel: function () {
if ( TRACE ) { TRACE( "LevelManager#CreateLevel", this ); }

                if (UnityEngine.Object.op_Implicit(this.currentLevel) && UnityEngine.Object.op_Implicit(this.currentLevel.gameObject)) {
                    UnityEngine.Object.DestroyImmediate(this.currentLevel.gameObject);
                }
                this.currentLevel = UnityEngine.Object.Instantiate(Level, this.levelPrefab);
                this.currentLevel.SetUp();
                Singleton$1(SoundManager).Ins.StopAll();
                Singleton$1(SoundManager).Ins.PlaySound("Background", true);
                Singleton$1(SoundManager).Ins.InLava = false;
            },
            /*LevelManager.CreateLevel end.*/

            /*LevelManager.OnWin start.*/
            OnWin: function () {
if ( TRACE ) { TRACE( "LevelManager#OnWin", this ); }

                this.currentLevel.OnWin();
                this.isEndGame = true;
                this.StartCoroutine$1(this.DelayShowWin());
            },
            /*LevelManager.OnWin end.*/

            /*LevelManager.DelayShowWin start.*/
            DelayShowWin: function () {
if ( TRACE ) { TRACE( "LevelManager#DelayShowWin", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(2.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    Singleton$1(UIManager).Ins.ShowWin();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LevelManager.DelayShowWin end.*/

            /*LevelManager.OnLose start.*/
            OnLose: function () {
if ( TRACE ) { TRACE( "LevelManager#OnLose", this ); }

                if (this.loseCount < 1) {
                    this.loseCount = (this.loseCount + 1) | 0;
                    this.StartCoroutine$1(this.DelayReplay());
                    return;
                }
                this.isEndGame = true;
                this.currentLevel.OnLose();
                this.StartCoroutine$1(this.DelayLose());
                Singleton$1(SoundManager).Ins.StopAll();
                Singleton$1(SoundManager).Ins.PlaySound("Lose", false);
            },
            /*LevelManager.OnLose end.*/

            /*LevelManager.DelayReplay start.*/
            DelayReplay: function () {
if ( TRACE ) { TRACE( "LevelManager#DelayReplay", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.CreateLevel();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LevelManager.DelayReplay end.*/

            /*LevelManager.DelayLose start.*/
            DelayLose: function () {
if ( TRACE ) { TRACE( "LevelManager#DelayLose", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    this.StartCoroutine$1(Singleton$1(CameraFollower).Ins.OnLose());
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    Singleton$1(UIManager).Ins.ShowLose();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*LevelManager.DelayLose end.*/


        }
    });
    /*LevelManager end.*/

    /*SoundManager start.*/
    Bridge.define("SoundManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "SoundManager#inherits", this ); }
 return [Singleton$1(SoundManager)]; },
        fields: {
            Sounds: null,
            audioSources: null,
            inLava: false
        },
        props: {
            InLava: {
                get: function () {
if ( TRACE ) { TRACE( "SoundManager#InLava#get", this ); }

                    return this.inLava;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "SoundManager#InLava#set", this ); }

                    this.inLava = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "SoundManager#init", this ); }

                this.audioSources = new (System.Collections.Generic.List$1(UnityEngine.AudioSource)).ctor();
                this.inLava = false;
            }
        },
        methods: {
            /*SoundManager.PlaySound start.*/
            PlaySound: function (name, loop) {
if ( TRACE ) { TRACE( "SoundManager#PlaySound", this ); }

                var s = System.Array.find(Sound, this.Sounds, function (x) {
                        return Bridge.referenceEquals(x.name, name);
                    });
                if (s != null) {
                    var source = this.GetAvailableAudioSource();
                    source.clip = s.clip;
                    source.Play();
                    source.loop = loop;
                }
            },
            /*SoundManager.PlaySound end.*/

            /*SoundManager.GetAvailableAudioSource start.*/
            GetAvailableAudioSource: function () {
if ( TRACE ) { TRACE( "SoundManager#GetAvailableAudioSource", this ); }

                var availableSource = this.audioSources.Find(function (source) {
                    return !source.isPlaying;
                });
                if (UnityEngine.Component.op_Equality(availableSource, null)) {
                    availableSource = Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.AddComponent(UnityEngine.AudioSource);
                    this.audioSources.add(availableSource);
                }
                return availableSource;
            },
            /*SoundManager.GetAvailableAudioSource end.*/

            /*SoundManager.StopAll start.*/
            StopAll: function () {
if ( TRACE ) { TRACE( "SoundManager#StopAll", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.audioSources);
                try {
                    while ($t.moveNext()) {
                        var source = $t.Current;
                        source.Stop();
                        source.clip = null;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*SoundManager.StopAll end.*/

            /*SoundManager.SoundInLava start.*/
            SoundInLava: function () {
if ( TRACE ) { TRACE( "SoundManager#SoundInLava", this ); }

                if (!this.inLava) {
                    for (var i = 0; i < 5; i = (i + 1) | 0) {
                        this.PlaySound("InLava", false);
                    }
                    this.inLava = true;
                }
            },
            /*SoundManager.SoundInLava end.*/


        }
    });
    /*SoundManager end.*/

    /*Spine.CurveTimeline start.*/
    Bridge.define("Spine.CurveTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                LINEAR: 0,
                STEPPED: 0,
                BEZIER: 0,
                BEZIER_SIZE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#init", this ); }

                    this.LINEAR = 0;
                    this.STEPPED = 1;
                    this.BEZIER = 2;
                    this.BEZIER_SIZE = 18;
                }
            }
        },
        fields: {
            curves: null
        },
        ctors: {
            ctor: function (frameCount, bezierCount, propertyIds) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#ctor", this ); }

                if (propertyIds === void 0) { propertyIds = []; }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, propertyIds);
                this.curves = System.Array.init(((frameCount + Bridge.Int.mul(bezierCount, 18)) | 0), 0, System.Single);
                this.curves[((frameCount - 1) | 0)] = 1.0;
            }
        },
        methods: {
            /*Spine.CurveTimeline.SetLinear start.*/
            SetLinear: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetLinear", this ); }

                this.curves[frame] = 0.0;
            },
            /*Spine.CurveTimeline.SetLinear end.*/

            /*Spine.CurveTimeline.SetStepped start.*/
            SetStepped: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetStepped", this ); }

                this.curves[frame] = 1.0;
            },
            /*Spine.CurveTimeline.SetStepped end.*/

            /*Spine.CurveTimeline.GetCurveType start.*/
            GetCurveType: function (frame) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetCurveType", this ); }

                return Bridge.Int.clip32(this.curves[frame]);
            },
            /*Spine.CurveTimeline.GetCurveType end.*/

            /*Spine.CurveTimeline.Shrink start.*/
            Shrink: function (bezierCount) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#Shrink", this ); }

                var size = (this.FrameCount + Bridge.Int.mul(bezierCount, 18)) | 0;
                if (this.curves.length > size) {
                    var newCurves = System.Array.init(size, 0, System.Single);
                    System.Array.copy(this.curves, 0, newCurves, 0, size);
                    this.curves = newCurves;
                }
            },
            /*Spine.CurveTimeline.Shrink end.*/

            /*Spine.CurveTimeline.SetBezier start.*/
            SetBezier: function (bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#SetBezier", this ); }

                var curves = this.curves;
                var i = (this.FrameCount + Bridge.Int.mul(bezier, 18)) | 0;
                if (value === 0) {
                    curves[frame] = (2 + i) | 0;
                }
                var tmpx = (time1 - cx1 * 2.0 + cx2) * 0.03;
                var tmpy = (value1 - cy1 * 2.0 + cy2) * 0.03;
                var dddx = ((cx1 - cx2) * 3.0 - time1 + time2) * 0.006;
                var dddy = ((cy1 - cy2) * 3.0 - value1 + value2) * 0.006;
                var ddx = tmpx * 2.0 + dddx;
                var ddy = tmpy * 2.0 + dddy;
                var dx = (cx1 - time1) * 0.3 + tmpx + dddx * (0.166666672);
                var dy = (cy1 - value1) * 0.3 + tmpy + dddy * (0.166666672);
                var x = time1 + dx;
                var y = value1 + dy;
                for (var j = (i + 18) | 0; i < j; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dx += ddx;
                    dy += ddy;
                    ddx += dddx;
                    ddy += dddy;
                    x += dx;
                    y += dy;
                }
            },
            /*Spine.CurveTimeline.SetBezier end.*/

            /*Spine.CurveTimeline.GetBezierValue start.*/
            GetBezierValue: function (time, frameIndex, valueOffset, i) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline#GetBezierValue", this ); }

                var curves = this.curves;
                if (curves[i] > time) {
                    var x2 = this.frames[frameIndex];
                    var y3 = this.frames[((frameIndex + valueOffset) | 0)];
                    return y3 + (time - x2) / (curves[i] - x2) * (curves[((i + 1) | 0)] - y3);
                }
                var j = (i + 18) | 0;
                for (i = (i + 2) | 0; i < j; i = (i + 2) | 0) {
                    if (curves[i] >= time) {
                        var x = curves[((i - 2) | 0)];
                        var y = curves[((i - 1) | 0)];
                        return y + (time - x) / (curves[i] - x) * (curves[((i + 1) | 0)] - y);
                    }
                }
                frameIndex = (frameIndex + this.FrameEntries) | 0;
                var x3 = curves[((j - 2) | 0)];
                var y2 = curves[((j - 1) | 0)];
                return y2 + (time - x3) / (this.frames[frameIndex] - x3) * (this.frames[((frameIndex + valueOffset) | 0)] - y2);
            },
            /*Spine.CurveTimeline.GetBezierValue end.*/


        }
    });
    /*Spine.CurveTimeline end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    Bridge.define("Spine.AnimationStateData.AnimationPairComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.AnimationStateData.AnimationPair)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#init", this ); }

                    this.Instance = new Spine.AnimationStateData.AnimationPairComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2", this ); }

                return Bridge.referenceEquals(x.a1, y.a1) && Bridge.referenceEquals(x.a2, y.a2);
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$equals2 end.*/

            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2: function (obj) {
if ( TRACE ) { TRACE( "Spine.AnimationStateData.AnimationPairComparer#System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2", this ); }

                var h1 = Bridge.getHashCode(obj.a1);
                return ((((h1 << 5) + h1) | 0)) ^ Bridge.getHashCode(obj.a2);
            },
            /*Spine.AnimationStateData+AnimationPairComparer.System$Collections$Generic$IEqualityComparer$1$Spine$AnimationStateData$AnimationPair$getHashCode2 end.*/


        }
    });
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.AtlasRegion start.*/
    Bridge.define("Spine.AtlasRegion", {
        inherits: [Spine.TextureRegion],
        fields: {
            page: null,
            name: null,
            x: 0,
            y: 0,
            offsetX: 0,
            offsetY: 0,
            originalWidth: 0,
            originalHeight: 0,
            degrees: 0,
            rotate: false,
            index: 0,
            names: null,
            values: null
        },
        props: {
            packedWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedWidth#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedWidth#set", this ); }

                    this.width = value;
                }
            },
            packedHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedHeight#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#packedHeight#set", this ); }

                    this.height = value;
                }
            },
            OriginalWidth: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#OriginalWidth#get", this ); }

                    return this.originalWidth;
                }
            },
            OriginalHeight: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#OriginalHeight#get", this ); }

                    return this.originalHeight;
                }
            }
        },
        methods: {
            /*Spine.AtlasRegion.Clone start.*/
            Clone: function () {
if ( TRACE ) { TRACE( "Spine.AtlasRegion#Clone", this ); }

                return Bridge.as(Bridge.clone(this), Spine.AtlasRegion);
            },
            /*Spine.AtlasRegion.Clone end.*/


        }
    });
    /*Spine.AtlasRegion end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    Bridge.define("Spine.AtlasAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        fields: {
            atlasArray: null
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        ctors: {
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                if (atlasArray == null) {
                    throw new System.ArgumentNullException.$ctor3("atlas", "atlas array cannot be null.");
                }
                this.atlasArray = atlasArray;
            }
        },
        methods: {
            /*Spine.AtlasAttachmentLoader.LoadSequence start.*/
            LoadSequence: function (name, basePath, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#LoadSequence", this ); }

                var regions = sequence.Regions;
                var i = 0;
                for (var j = regions.length; i < j; i = (i + 1) | 0) {
                    var path = sequence.GetPath(basePath, i);
                    regions[i] = this.FindRegion(path);
                    if (regions[i] == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                }
            },
            /*Spine.AtlasAttachmentLoader.LoadSequence end.*/

            /*Spine.AtlasAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewRegionAttachment", this ); }

                var attachment = new Spine.RegionAttachment.$ctor1(name);
                if (sequence != null) {
                    this.LoadSequence(name, path, sequence);
                } else {
                    var region = this.FindRegion(path);
                    if (region == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                    attachment.Region = region;
                }
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewMeshAttachment", this ); }

                var attachment = new Spine.MeshAttachment.$ctor1(name);
                if (sequence != null) {
                    this.LoadSequence(name, path, sequence);
                } else {
                    var region = this.FindRegion(path);
                    if (region == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Region not found in atlas: {0} (region attachment: {1})", path, name));
                    }
                    attachment.Region = region;
                }
                return attachment;
            },
            /*Spine.AtlasAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPathAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewPointAttachment end.*/

            /*Spine.AtlasAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment.$ctor1(name);
            },
            /*Spine.AtlasAttachmentLoader.NewClippingAttachment end.*/

            /*Spine.AtlasAttachmentLoader.FindRegion start.*/
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.AtlasAttachmentLoader#FindRegion", this ); }

                for (var i = 0; i < this.atlasArray.length; i = (i + 1) | 0) {
                    var region = this.atlasArray[i].FindRegion(name);
                    if (region != null) {
                        return region;
                    }
                }
                return null;
            },
            /*Spine.AtlasAttachmentLoader.FindRegion end.*/


        }
    });
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.AttachmentTimeline start.*/
    Bridge.define("Spine.AttachmentTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachmentNames: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            AttachmentNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#AttachmentNames#get", this ); }

                    return this.attachmentNames;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, [10 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
                this.attachmentNames = System.Array.init(frameCount, null, System.String);
            }
        },
        methods: {
            /*Spine.AttachmentTimeline.SetFrame start.*/
            SetFrame: function (frame, time, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.attachmentNames[frame] = attachmentName;
            },
            /*Spine.AttachmentTimeline.SetFrame end.*/

            /*Spine.AttachmentTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        this.SetAttachment(skeleton, slot, slot.data.attachmentName);
                    }
                } else {
                    this.SetAttachment(skeleton, slot, this.attachmentNames[Spine.Timeline.Search(frames, time)]);
                }
            },
            /*Spine.AttachmentTimeline.Apply end.*/

            /*Spine.AttachmentTimeline.SetAttachment start.*/
            SetAttachment: function (skeleton, slot, attachmentName) {
if ( TRACE ) { TRACE( "Spine.AttachmentTimeline#SetAttachment", this ); }

                slot.Attachment = ((attachmentName == null) ? null : skeleton.GetAttachment(this.slotIndex, attachmentName));
            },
            /*Spine.AttachmentTimeline.SetAttachment end.*/


        }
    });
    /*Spine.AttachmentTimeline end.*/

    /*Spine.Bone start.*/
    Bridge.define("Spine.Bone", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                yDown: false
            }
        },
        fields: {
            data: null,
            skeleton: null,
            parent: null,
            children: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            shearX: 0,
            shearY: 0,
            ax: 0,
            ay: 0,
            arotation: 0,
            ascaleX: 0,
            ascaleY: 0,
            ashearX: 0,
            ashearY: 0,
            a: 0,
            b: 0,
            worldX: 0,
            c: 0,
            d: 0,
            worldY: 0,
            sorted: false,
            active: false
        },
        props: {
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Data#get", this ); }

                    return this.data;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Skeleton#get", this ); }

                    return this.skeleton;
                }
            },
            Parent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Parent#get", this ); }

                    return this.parent;
                }
            },
            Children: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Children#get", this ); }

                    return this.children;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Active#get", this ); }

                    return this.active;
                }
            },
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            ShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#get", this ); }

                    return this.shearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearX#set", this ); }

                    this.shearX = value;
                }
            },
            ShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#get", this ); }

                    return this.shearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#ShearY#set", this ); }

                    this.shearY = value;
                }
            },
            AppliedRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#get", this ); }

                    return this.arotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AppliedRotation#set", this ); }

                    this.arotation = value;
                }
            },
            AX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AX#get", this ); }

                    return this.ax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AX#set", this ); }

                    this.ax = value;
                }
            },
            AY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AY#get", this ); }

                    return this.ay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AY#set", this ); }

                    this.ay = value;
                }
            },
            AScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#get", this ); }

                    return this.ascaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleX#set", this ); }

                    this.ascaleX = value;
                }
            },
            AScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#get", this ); }

                    return this.ascaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AScaleY#set", this ); }

                    this.ascaleY = value;
                }
            },
            AShearX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#get", this ); }

                    return this.ashearX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearX#set", this ); }

                    this.ashearX = value;
                }
            },
            AShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#get", this ); }

                    return this.ashearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#AShearY#set", this ); }

                    this.ashearY = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#A#set", this ); }

                    this.a = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#B#set", this ); }

                    this.b = value;
                }
            },
            C: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#C#get", this ); }

                    return this.c;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#C#set", this ); }

                    this.c = value;
                }
            },
            D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#D#get", this ); }

                    return this.d;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#D#set", this ); }

                    this.d = value;
                }
            },
            WorldX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#get", this ); }

                    return this.worldX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldX#set", this ); }

                    this.worldX = value;
                }
            },
            WorldY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#get", this ); }

                    return this.worldY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldY#set", this ); }

                    this.worldY = value;
                }
            },
            WorldRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationX#get", this ); }

                    return Spine.MathUtils.Atan2(this.c, this.a) * (57.2957764);
                }
            },
            WorldRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldRotationY#get", this ); }

                    return Spine.MathUtils.Atan2(this.d, this.b) * (57.2957764);
                }
            },
            WorldScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleX#get", this ); }

                    return Math.sqrt(this.a * this.a + this.c * this.c);
                }
            },
            WorldScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldScaleY#get", this ); }

                    return Math.sqrt(this.b * this.b + this.d * this.d);
                }
            },
            WorldToLocalRotationX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationX#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a;
                    var pb = parent.b;
                    var pc = parent.c;
                    var pd = parent.d;
                    var a = this.a;
                    var c = this.c;
                    return Spine.MathUtils.Atan2(pa * c - pc * a, pd * a - pb * c) * (57.2957764);
                }
            },
            WorldToLocalRotationY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotationY#get", this ); }

                    var parent = this.parent;
                    if (parent == null) {
                        return this.arotation;
                    }
                    var pa = parent.a;
                    var pb = parent.b;
                    var pc = parent.c;
                    var pd = parent.d;
                    var b = this.b;
                    var d = this.d;
                    return Spine.MathUtils.Atan2(pa * d - pc * b, pd * b - pb * d) * (57.2957764);
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Bone#init", this ); }

                this.children = new (Spine.ExposedList$1(Spine.Bone)).ctor();
            },
            $ctor1: function (data, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#$ctor1", this ); }

                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.skeleton = skeleton;
                this.parent = parent;
                this.SetToSetupPose();
            },
            ctor: function (bone, skeleton, parent) {
if ( TRACE ) { TRACE( "Spine.Bone#ctor", this ); }

                this.$initialize();
                if (bone == null) {
                    throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.skeleton = skeleton;
                this.parent = parent;
                this.data = bone.data;
                this.x = bone.x;
                this.y = bone.y;
                this.rotation = bone.rotation;
                this.scaleX = bone.scaleX;
                this.scaleY = bone.scaleY;
                this.shearX = bone.shearX;
                this.shearY = bone.shearY;
            }
        },
        methods: {
            /*Spine.Bone.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Bone#Update", this ); }

                this.UpdateWorldTransform$1(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);
            },
            /*Spine.Bone.Update end.*/

            /*Spine.Bone.UpdateWorldTransform start.*/
            UpdateWorldTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform", this ); }

                this.UpdateWorldTransform$1(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
            },
            /*Spine.Bone.UpdateWorldTransform end.*/

            /*Spine.Bone.UpdateWorldTransform$1 start.*/
            UpdateWorldTransform$1: function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateWorldTransform$1", this ); }

                this.ax = x;
                this.ay = y;
                this.arotation = rotation;
                this.ascaleX = scaleX;
                this.ascaleY = scaleY;
                this.ashearX = shearX;
                this.ashearY = shearY;
                var parent = this.parent;
                if (parent == null) {
                    var rotationY3 = rotation + 90.0 + shearY;
                    var sx = this.skeleton.ScaleX;
                    var sy = this.skeleton.ScaleY;
                    this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX * sx;
                    this.b = Spine.MathUtils.CosDeg(rotationY3) * scaleY * sx;
                    this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX * sy;
                    this.d = Spine.MathUtils.SinDeg(rotationY3) * scaleY * sy;
                    this.worldX = x * sx + this.skeleton.x;
                    this.worldY = y * sy + this.skeleton.y;
                    return;
                }
                var pa = parent.a;
                var pb = parent.b;
                var pc = parent.c;
                var pd = parent.d;
                this.worldX = pa * x + pb * y + parent.worldX;
                this.worldY = pc * x + pd * y + parent.worldY;
                switch (this.data.transformMode) {
                    case Spine.TransformMode.Normal: 
                        {
                            var rotationY = rotation + 90.0 + shearY;
                            var la = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            var lb = Spine.MathUtils.CosDeg(rotationY) * scaleY;
                            var lc = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            var ld = Spine.MathUtils.SinDeg(rotationY) * scaleY;
                            this.a = pa * la + pb * lc;
                            this.b = pa * lb + pb * ld;
                            this.c = pc * la + pd * lc;
                            this.d = pc * lb + pd * ld;
                            return;
                        }
                    case Spine.TransformMode.OnlyTranslation: 
                        {
                            var rotationY2 = rotation + 90.0 + shearY;
                            this.a = Spine.MathUtils.CosDeg(rotation + shearX) * scaleX;
                            this.b = Spine.MathUtils.CosDeg(rotationY2) * scaleY;
                            this.c = Spine.MathUtils.SinDeg(rotation + shearX) * scaleX;
                            this.d = Spine.MathUtils.SinDeg(rotationY2) * scaleY;
                            break;
                        }
                    case Spine.TransformMode.NoRotationOrReflection: 
                        {
                            var s = pa * pa + pc * pc;
                            var prx;
                            if (s > 0.0001) {
                                s = Math.abs(pa * pd - pb * pc) / s;
                                pa /= this.skeleton.ScaleX;
                                pc /= this.skeleton.ScaleY;
                                pb = pc * s;
                                pd = pa * s;
                                prx = Spine.MathUtils.Atan2(pc, pa) * (57.2957764);
                            } else {
                                pa = 0.0;
                                pc = 0.0;
                                prx = 90.0 - Spine.MathUtils.Atan2(pd, pb) * (57.2957764);
                            }
                            var rx = rotation + shearX - prx;
                            var ry = rotation + shearY - prx + 90.0;
                            var la2 = Spine.MathUtils.CosDeg(rx) * scaleX;
                            var lb2 = Spine.MathUtils.CosDeg(ry) * scaleY;
                            var lc2 = Spine.MathUtils.SinDeg(rx) * scaleX;
                            var ld2 = Spine.MathUtils.SinDeg(ry) * scaleY;
                            this.a = pa * la2 - pb * lc2;
                            this.b = pa * lb2 - pb * ld2;
                            this.c = pc * la2 + pd * lc2;
                            this.d = pc * lb2 + pd * ld2;
                            break;
                        }
                    case Spine.TransformMode.NoScale: 
                    case Spine.TransformMode.NoScaleOrReflection: 
                        {
                            var cos = Spine.MathUtils.CosDeg(rotation);
                            var sin = Spine.MathUtils.SinDeg(rotation);
                            var za = (pa * cos + pb * sin) / this.skeleton.ScaleX;
                            var zc = (pc * cos + pd * sin) / this.skeleton.ScaleY;
                            var s2 = Math.sqrt(za * za + zc * zc);
                            if (s2 > 1E-05) {
                                s2 = 1.0 / s2;
                            }
                            za *= s2;
                            zc *= s2;
                            s2 = Math.sqrt(za * za + zc * zc);
                            if (this.data.transformMode === Spine.TransformMode.NoScale && pa * pd - pb * pc < 0.0 !== (this.skeleton.ScaleX < 0.0 !== this.skeleton.ScaleY < 0.0)) {
                                s2 = 0.0 - s2;
                            }
                            var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                            var zb = Spine.MathUtils.Cos(r) * s2;
                            var zd = Spine.MathUtils.Sin(r) * s2;
                            var la3 = Spine.MathUtils.CosDeg(shearX) * scaleX;
                            var lb3 = Spine.MathUtils.CosDeg(90.0 + shearY) * scaleY;
                            var lc3 = Spine.MathUtils.SinDeg(shearX) * scaleX;
                            var ld3 = Spine.MathUtils.SinDeg(90.0 + shearY) * scaleY;
                            this.a = za * la3 + zb * lc3;
                            this.b = za * lb3 + zb * ld3;
                            this.c = zc * la3 + zd * lc3;
                            this.d = zc * lb3 + zd * ld3;
                            break;
                        }
                }
                this.a *= this.skeleton.ScaleX;
                this.b *= this.skeleton.ScaleX;
                this.c *= this.skeleton.ScaleY;
                this.d *= this.skeleton.ScaleY;
            },
            /*Spine.Bone.UpdateWorldTransform$1 end.*/

            /*Spine.Bone.SetToSetupPose start.*/
            SetToSetupPose: function () {
if ( TRACE ) { TRACE( "Spine.Bone#SetToSetupPose", this ); }

                var data = this.data;
                this.x = data.x;
                this.y = data.y;
                this.rotation = data.rotation;
                this.scaleX = data.scaleX;
                this.scaleY = data.scaleY;
                this.shearX = data.shearX;
                this.shearY = data.shearY;
            },
            /*Spine.Bone.SetToSetupPose end.*/

            /*Spine.Bone.UpdateAppliedTransform start.*/
            UpdateAppliedTransform: function () {
if ( TRACE ) { TRACE( "Spine.Bone#UpdateAppliedTransform", this ); }

                var parent = this.parent;
                if (parent == null) {
                    this.ax = this.worldX - this.skeleton.x;
                    this.ay = this.worldY - this.skeleton.y;
                    this.arotation = Spine.MathUtils.Atan2(this.c, this.a) * (57.2957764);
                    this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
                    this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
                    this.ashearX = 0.0;
                    this.ashearY = Spine.MathUtils.Atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * (57.2957764);
                    return;
                }
                var pa = parent.a;
                var pb = parent.b;
                var pc = parent.c;
                var pd = parent.d;
                var pid = 1.0 / (pa * pd - pb * pc);
                var dx = this.worldX - parent.worldX;
                var dy = this.worldY - parent.worldY;
                this.ax = dx * pd * pid - dy * pb * pid;
                this.ay = dy * pa * pid - dx * pc * pid;
                var ia = pid * pd;
                var id = pid * pa;
                var ib = pid * pb;
                var ic = pid * pc;
                var ra = ia * this.a - ib * this.c;
                var rb = ia * this.b - ib * this.d;
                var rc = id * this.c - ic * this.a;
                var rd = id * this.d - ic * this.b;
                this.ashearX = 0.0;
                this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Spine.MathUtils.Atan2(ra * rb + rc * rd, det) * (57.2957764);
                    this.arotation = Spine.MathUtils.Atan2(rc, ra) * (57.2957764);
                } else {
                    this.ascaleX = 0.0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0.0;
                    this.arotation = 90.0 - Spine.MathUtils.Atan2(rd, rb) * (57.2957764);
                }
            },
            /*Spine.Bone.UpdateAppliedTransform end.*/

            /*Spine.Bone.WorldToLocal start.*/
            WorldToLocal: function (worldX, worldY, localX, localY) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocal", this ); }

                var a = this.a;
                var b = this.b;
                var c = this.c;
                var d = this.d;
                var det = a * d - b * c;
                var x = worldX - this.worldX;
                var y = worldY - this.worldY;
                localX.v = (x * d - y * b) / det;
                localY.v = (y * a - x * c) / det;
            },
            /*Spine.Bone.WorldToLocal end.*/

            /*Spine.Bone.LocalToWorld start.*/
            LocalToWorld: function (localX, localY, worldX, worldY) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorld", this ); }

                worldX.v = localX * this.a + localY * this.b + this.worldX;
                worldY.v = localX * this.c + localY * this.d + this.worldY;
            },
            /*Spine.Bone.LocalToWorld end.*/

            /*Spine.Bone.WorldToLocalRotation start.*/
            WorldToLocalRotation: function (worldRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#WorldToLocalRotation", this ); }

                var sin = Spine.MathUtils.SinDeg(worldRotation);
                var cos = Spine.MathUtils.CosDeg(worldRotation);
                return Spine.MathUtils.Atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * (57.2957764) + this.rotation - this.shearX;
            },
            /*Spine.Bone.WorldToLocalRotation end.*/

            /*Spine.Bone.LocalToWorldRotation start.*/
            LocalToWorldRotation: function (localRotation) {
if ( TRACE ) { TRACE( "Spine.Bone#LocalToWorldRotation", this ); }

                localRotation -= this.rotation - this.shearX;
                var sin = Spine.MathUtils.SinDeg(localRotation);
                var cos = Spine.MathUtils.CosDeg(localRotation);
                return Spine.MathUtils.Atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * (57.2957764);
            },
            /*Spine.Bone.LocalToWorldRotation end.*/

            /*Spine.Bone.RotateWorld start.*/
            RotateWorld: function (degrees) {
if ( TRACE ) { TRACE( "Spine.Bone#RotateWorld", this ); }

                var a = this.a;
                var b = this.b;
                var c = this.c;
                var d = this.d;
                var cos = Spine.MathUtils.CosDeg(degrees);
                var sin = Spine.MathUtils.SinDeg(degrees);
                this.a = cos * a - sin * c;
                this.b = cos * b - sin * d;
                this.c = sin * a + cos * c;
                this.d = sin * b + cos * d;
            },
            /*Spine.Bone.RotateWorld end.*/

            /*Spine.Bone.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Bone#toString", this ); }

                return this.data.name;
            },
            /*Spine.Bone.toString end.*/


        },
        overloads: {
            "UpdateWorldTransform(float, float, float, float, float, float, float)": "UpdateWorldTransform$1",
            "ToString()": "toString"
        }
    });
    /*Spine.Bone end.*/

    /*Spine.VertexAttachment start.*/
    Bridge.define("Spine.VertexAttachment", {
        inherits: [Spine.Attachment],
        statics: {
            fields: {
                nextID: 0,
                nextIdLock: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#init", this ); }

                    this.nextID = 0;
                    this.nextIdLock = { };
                }
            }
        },
        fields: {
            id: 0,
            timelineAttachment: null,
            bones: null,
            vertices: null,
            worldVerticesLength: 0
        },
        props: {
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Id#get", this ); }

                    return this.id;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#get", this ); }

                    return this.bones;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Bones#set", this ); }

                    this.bones = value;
                }
            },
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#get", this ); }

                    return this.vertices;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#Vertices#set", this ); }

                    this.vertices = value;
                }
            },
            WorldVerticesLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#get", this ); }

                    return this.worldVerticesLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#WorldVerticesLength#set", this ); }

                    this.worldVerticesLength = value;
                }
            },
            TimelineAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#TimelineAttachment#get", this ); }

                    return this.timelineAttachment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#TimelineAttachment#set", this ); }

                    this.timelineAttachment = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#$ctor1", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);
                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t)));
                }
                this.timelineAttachment = this;
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ctor", this ); }

                var $t;
                this.$initialize();
                Spine.Attachment.ctor.call(this, other);
                Spine.VertexAttachment.nextIdLock;
                {
                    this.id = Bridge.identity(Spine.VertexAttachment.nextID, (($t = (Spine.VertexAttachment.nextID + 1) | 0, Spine.VertexAttachment.nextID = $t, $t)));
                }
                this.timelineAttachment = other.timelineAttachment;
                if (other.bones != null) {
                    this.bones = System.Array.init(other.bones.length, 0, System.Int32);
                    System.Array.copy(other.bones, 0, this.bones, 0, this.bones.length);
                } else {
                    this.bones = null;
                }
                if (other.vertices != null) {
                    this.vertices = System.Array.init(other.vertices.length, 0, System.Single);
                    System.Array.copy(other.vertices, 0, this.vertices, 0, this.vertices.length);
                } else {
                    this.vertices = null;
                }
                this.worldVerticesLength = other.worldVerticesLength;
            }
        },
        methods: {
            /*Spine.VertexAttachment.ComputeWorldVertices$1 start.*/
            ComputeWorldVertices$1: function (slot, worldVertices) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices$1", this ); }

                this.ComputeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0);
            },
            /*Spine.VertexAttachment.ComputeWorldVertices$1 end.*/

            /*Spine.VertexAttachment.ComputeWorldVertices start.*/
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.VertexAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                count = (offset + Bridge.Int.mul((count >> 1), stride)) | 0;
                var deformArray = slot.deform;
                var vertices = this.vertices;
                var bones = this.bones;
                if (bones == null) {
                    if (deformArray.Count > 0) {
                        vertices = deformArray.Items;
                    }
                    var bone3 = slot.bone;
                    var x = bone3.worldX;
                    var y = bone3.worldY;
                    var a = bone3.a;
                    var b3 = bone3.b;
                    var c = bone3.c;
                    var d = bone3.d;
                    var vv = start;
                    for (var w3 = offset; w3 < count; w3 = (w3 + stride) | 0) {
                        var vx3 = vertices[vv];
                        var vy3 = vertices[((vv + 1) | 0)];
                        worldVertices[w3] = vx3 * a + vy3 * b3 + x;
                        worldVertices[((w3 + 1) | 0)] = vx3 * c + vy3 * d + y;
                        vv = (vv + 2) | 0;
                    }
                    return;
                }
                var v = 0;
                var skip = 0;
                for (var i = 0; i < start; i = (i + 2) | 0) {
                    var j = bones[v];
                    v = (v + (((j + 1) | 0))) | 0;
                    skip = (skip + j) | 0;
                }
                var skeletonBones = slot.bone.skeleton.bones.Items;
                if (deformArray.Count === 0) {
                    var w2 = offset;
                    var b2 = Bridge.Int.mul(skip, 3);
                    for (; w2 < count; w2 = (w2 + stride) | 0) {
                        var wx2 = 0.0;
                        var wy2 = 0.0;
                        var l = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                        l = (l + v) | 0;
                        while (v < l) {
                            var bone2 = skeletonBones[bones[v]];
                            var vx2 = vertices[b2];
                            var vy2 = vertices[((b2 + 1) | 0)];
                            var weight2 = vertices[((b2 + 2) | 0)];
                            wx2 += (vx2 * bone2.a + vy2 * bone2.b + bone2.worldX) * weight2;
                            wy2 += (vx2 * bone2.c + vy2 * bone2.d + bone2.worldY) * weight2;
                            v = (v + 1) | 0;
                            b2 = (b2 + 3) | 0;
                        }
                        worldVertices[w2] = wx2;
                        worldVertices[((w2 + 1) | 0)] = wy2;
                    }
                    return;
                }
                var deform = deformArray.Items;
                var w = offset;
                var b = Bridge.Int.mul(skip, 3);
                var f = skip << 1;
                for (; w < count; w = (w + stride) | 0) {
                    var wx = 0.0;
                    var wy = 0.0;
                    var k = bones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                    k = (k + v) | 0;
                    while (v < k) {
                        var bone = skeletonBones[bones[v]];
                        var vx = vertices[b] + deform[f];
                        var vy = vertices[((b + 1) | 0)] + deform[((f + 1) | 0)];
                        var weight = vertices[((b + 2) | 0)];
                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                        v = (v + 1) | 0;
                        b = (b + 3) | 0;
                        f = (f + 2) | 0;
                    }
                    worldVertices[w] = wx;
                    worldVertices[((w + 1) | 0)] = wy;
                }
            },
            /*Spine.VertexAttachment.ComputeWorldVertices end.*/


        },
        overloads: {
            "ComputeWorldVertices(Slot, float[])": "ComputeWorldVertices$1"
        }
    });
    /*Spine.VertexAttachment end.*/

    /*Spine.DrawOrderTimeline start.*/
    Bridge.define("Spine.DrawOrderTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                propertyIds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#init", this ); }

                    this.propertyIds = System.Array.init([Bridge.toString((13))], System.String);
                }
            }
        },
        fields: {
            drawOrders: null
        },
        props: {
            DrawOrders: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#DrawOrders#get", this ); }

                    return this.drawOrders;
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, Spine.DrawOrderTimeline.propertyIds);
                this.drawOrders = System.Array.init(frameCount, null, System.Array.type(System.Int32));
            }
        },
        methods: {
            /*Spine.DrawOrderTimeline.SetFrame start.*/
            SetFrame: function (frame, time, drawOrder) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.drawOrders[frame] = drawOrder;
            },
            /*Spine.DrawOrderTimeline.SetFrame end.*/

            /*Spine.DrawOrderTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DrawOrderTimeline#Apply", this ); }

                if (direction === Spine.MixDirection.Out) {
                    if (blend === Spine.MixBlend.Setup) {
                        System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                    }
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                    }
                    return;
                }
                var drawOrderToSetupIndex = this.drawOrders[Spine.Timeline.Search(frames, time)];
                if (drawOrderToSetupIndex == null) {
                    System.Array.copy(skeleton.slots.Items, 0, skeleton.drawOrder.Items, 0, skeleton.slots.Count);
                    return;
                }
                var slots = skeleton.slots.Items;
                var drawOrder = skeleton.drawOrder.Items;
                var i = 0;
                for (var j = drawOrderToSetupIndex.length; i < j; i = (i + 1) | 0) {
                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];
                }
            },
            /*Spine.DrawOrderTimeline.Apply end.*/


        }
    });
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.EventTimeline start.*/
    Bridge.define("Spine.EventTimeline", {
        inherits: [Spine.Timeline],
        statics: {
            fields: {
                propertyIds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#init", this ); }

                    this.propertyIds = System.Array.init([Bridge.toString((12))], System.String);
                }
            }
        },
        fields: {
            events: null
        },
        props: {
            Events: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Events#get", this ); }

                    return this.events;
                }
            }
        },
        ctors: {
            ctor: function (frameCount) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, Spine.EventTimeline.propertyIds);
                this.events = System.Array.init(frameCount, null, Spine.Event);
            }
        },
        methods: {
            /*Spine.EventTimeline.SetFrame start.*/
            SetFrame: function (frame, e) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#SetFrame", this ); }

                this.frames[frame] = e.time;
                this.events[frame] = e;
            },
            /*Spine.EventTimeline.SetFrame end.*/

            /*Spine.EventTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.EventTimeline#Apply", this ); }

                if (firedEvents == null) {
                    return;
                }
                var frames = this.frames;
                var frameCount = frames.length;
                if (lastTime > time) {
                    this.Apply(skeleton, lastTime, 2.14748365E+09, firedEvents, alpha, blend, direction);
                    lastTime = -1.0;
                } else if (lastTime >= frames[((frameCount - 1) | 0)]) {
                    return;
                }
                if (time < frames[0]) {
                    return;
                }
                var i;
                if (lastTime < frames[0]) {
                    i = 0;
                } else {
                    i = (Spine.Timeline.Search(frames, lastTime) + 1) | 0;
                    var frameTime = frames[i];
                    while (i > 0 && frames[((i - 1) | 0)] === frameTime) {
                        i = (i - 1) | 0;
                    }
                }
                for (; i < frameCount && time >= frames[i]; i = (i + 1) | 0) {
                    firedEvents.Add(this.events[i]);
                }
            },
            /*Spine.EventTimeline.Apply end.*/


        }
    });
    /*Spine.EventTimeline end.*/

    /*Spine.IkConstraint start.*/
    Bridge.define("Spine.IkConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            methods: {
                /*Spine.IkConstraint.Apply$1:static start.*/
                Apply$1: function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply$1", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        p, 
                        pa, 
                        pb, 
                        pc, 
                        pd, 
                        rotationIK, 
                        tx, 
                        ty, 
                        transformMode, 
                        transformMode2, 
                        s2, 
                        sa, 
                        sc, 
                        x, 
                        y, 
                        d, 
                        sx, 
                        sy, 
                        transformMode3, 
                        transformMode4, 
                        b, 
                        dd, 
                        s, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,5,6], $step);
                                switch ($step) {
                                    case 0: {
                                        if (bone == null) {
                                            throw new System.ArgumentNullException.$ctor3("bone", "bone cannot be null.");
                                        }
                                        p = bone.parent;
                                        pa = p.a;
                                        pb = p.b;
                                        pc = p.c;
                                        pd = p.d;
                                        rotationIK = 0.0 - bone.ashearX - bone.arotation;
                                        tx = 0.0;
                                        ty = 0.0;
                                        transformMode = bone.data.transformMode;
                                        transformMode2 = transformMode;
                                        if (transformMode2 !== Spine.TransformMode.NoRotationOrReflection) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 4;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        if (transformMode2 === Spine.TransformMode.OnlyTranslation) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                    }
                                    case 2: {
                                        tx = (targetX - bone.worldX) * Bridge.Int.sign(bone.skeleton.ScaleX);
                                        ty = (targetY - bone.worldY) * Bridge.Int.sign(bone.skeleton.ScaleY);
                                        $step = 6;
                                        continue;
                                    }
                                    case 3: {
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        s2 = Math.abs(pa * pd - pb * pc) / Math.max(0.0001, pa * pa + pc * pc);
                                        sa = pa / bone.skeleton.ScaleX;
                                        sc = pc / bone.skeleton.ScaleY;
                                        pb = (0.0 - sc) * s2 * bone.skeleton.ScaleX;
                                        pd = sa * s2 * bone.skeleton.ScaleY;
                                        rotationIK += Math.atan2(sc, sa) * (57.2957764);
                                        $step = 5;
                                        continue;
                                    }
                                    case 5: {
                                        x = targetX - p.worldX;
                                        y = targetY - p.worldY;
                                        d = pa * pd - pb * pc;
                                        if (Math.abs(d) <= 0.0001) {
                                            tx = 0.0;
                                            ty = 0.0;
                                        } else {
                                            tx = (x * pd - y * pb) / d - bone.ax;
                                            ty = (y * pa - x * pc) / d - bone.ay;
                                        }
                                        $step = 6;
                                        continue;
                                    }
                                    case 6: {
                                        rotationIK += Math.atan2(ty, tx) * (57.2957764);
                                        if (bone.ascaleX < 0.0) {
                                            rotationIK += 180.0;
                                        }
                                        if (rotationIK > 180.0) {
                                            rotationIK -= 360.0;
                                        } else if (rotationIK < -180.0) {
                                            rotationIK += 360.0;
                                        }
                                        sx = bone.ascaleX;
                                        sy = bone.ascaleY;
                                        if (compress || stretch) {
                                            transformMode3 = bone.data.transformMode;
                                            transformMode4 = transformMode3;
                                            if (transformMode4 === Spine.TransformMode.NoScale || transformMode4 === Spine.TransformMode.NoScaleOrReflection) {
                                                tx = targetX - bone.worldX;
                                                ty = targetY - bone.worldY;
                                            }
                                            b = bone.data.length * sx;
                                            dd = Math.sqrt(tx * tx + ty * ty);
                                            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {
                                                s = (dd / b - 1.0) * alpha + 1.0;
                                                sx *= s;
                                                if (uniform) {
                                                    sy *= s;
                                                }
                                            }
                                        }
                                        bone.UpdateWorldTransform$1(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply$1:static end.*/

                /*Spine.IkConstraint.Apply:static start.*/
                Apply: function (parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Apply", this ); }

                    var $step = 0,
                        $jumpFromFinally, 
                        px, 
                        py, 
                        psx, 
                        psy, 
                        sx, 
                        sy, 
                        csx, 
                        os2, 
                        s2, 
                        os3, 
                        cx, 
                        a, 
                        b, 
                        c, 
                        d, 
                        u, 
                        cy, 
                        cwx, 
                        cwy, 
                        pp, 
                        id, 
                        x, 
                        y, 
                        dx, 
                        dy, 
                        l1, 
                        l2, 
                        tx, 
                        ty, 
                        dd, 
                        td, 
                        sd, 
                        p, 
                        a2, 
                        a3, 
                        cos, 
                        aa, 
                        bb, 
                        ta, 
                        c2, 
                        c3, 
                        q, 
                        r2, 
                        r3, 
                        r, 
                        minAngle, 
                        minX, 
                        minDist, 
                        minY, 
                        maxAngle, 
                        maxX, 
                        maxDist, 
                        maxY, 
                        os, 
                        rotation, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1,2,3,4,6,7,8], $step);
                                switch ($step) {
                                    case 0: {
                                        if (parent == null) {
                                            throw new System.ArgumentNullException.$ctor3("parent", "parent cannot be null.");
                                        }
                                        if (child == null) {
                                            throw new System.ArgumentNullException.$ctor3("child", "child cannot be null.");
                                        }
                                        px = parent.ax;
                                        py = parent.ay;
                                        psx = parent.ascaleX;
                                        psy = parent.ascaleY;
                                        sx = psx;
                                        sy = psy;
                                        csx = child.ascaleX;
                                        if (psx < 0.0) {
                                            psx = 0.0 - psx;
                                            os2 = 180;
                                            s2 = -1;
                                        } else {
                                            os2 = 0;
                                            s2 = 1;
                                        }
                                        if (psy < 0.0) {
                                            psy = 0.0 - psy;
                                            s2 = (-s2) | 0;
                                        }
                                        if (csx < 0.0) {
                                            csx = 0.0 - csx;
                                            os3 = 180;
                                        } else {
                                            os3 = 0;
                                        }
                                        cx = child.ax;
                                        a = parent.a;
                                        b = parent.b;
                                        c = parent.c;
                                        d = parent.d;
                                        u = Math.abs(psx - psy) <= 0.0001;
                                        if (!u || stretch) {
                                            cy = 0.0;
                                            cwx = a * cx + parent.worldX;
                                            cwy = c * cx + parent.worldY;
                                        } else {
                                            cy = child.ay;
                                            cwx = a * cx + b * cy + parent.worldX;
                                            cwy = c * cx + d * cy + parent.worldY;
                                        }
                                        pp = parent.parent;
                                        a = pp.a;
                                        b = pp.b;
                                        c = pp.c;
                                        d = pp.d;
                                        id = a * d - b * c;
                                        x = cwx - pp.worldX;
                                        y = cwy - pp.worldY;
                                        id = ((Math.abs(id) <= 0.0001) ? 0.0 : (1.0 / id));
                                        dx = (x * d - y * b) * id - px;
                                        dy = (y * a - x * c) * id - py;
                                        l1 = Math.sqrt(dx * dx + dy * dy);
                                        l2 = child.data.length * csx;
                                        if (l1 < 0.0001) {
                                            Spine.IkConstraint.Apply$1(parent, targetX, targetY, false, stretch, false, alpha);
                                            child.UpdateWorldTransform$1(cx, cy, 0.0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                            return;
                                        }
                                        x = targetX - pp.worldX;
                                        y = targetY - pp.worldY;
                                        tx = (x * d - y * b) * id - px;
                                        ty = (y * a - x * c) * id - py;
                                        dd = tx * tx + ty * ty;
                                        if (softness !== 0.0) {
                                            softness *= psx * (csx + 1.0) * 0.5;
                                            td = Math.sqrt(dd);
                                            sd = td - l1 - l2 * psx + softness;
                                            if (sd > 0.0) {
                                                p = Math.min(1.0, sd / (softness * 2.0)) - 1.0;
                                                p = (sd - softness * (1.0 - p * p)) / td;
                                                tx -= p * tx;
                                                ty -= p * ty;
                                                dd = tx * tx + ty * ty;
                                            }
                                        }
                                        if (u) {
                                            $step = 1;
                                            continue;
                                        } else  {
                                            $step = 2;
                                            continue;
                                        }
                                    }
                                    case 1: {
                                        l2 *= psx;
                                        cos = (dd - l1 * l1 - l2 * l2) / (2.0 * l1 * l2);
                                        if (cos < -1.0) {
                                            cos = -1.0;
                                            a3 = 3.14159274 * bendDir;
                                        } else if (cos > 1.0) {
                                            cos = 1.0;
                                            a3 = 0.0;
                                            if (stretch) {
                                                a = (Math.sqrt(dd) / (l1 + l2) - 1.0) * alpha + 1.0;
                                                sx *= a;
                                                if (uniform) {
                                                    sy *= a;
                                                }
                                            }
                                        } else {
                                            a3 = Math.acos(cos) * bendDir;
                                        }
                                        a = l1 + l2 * cos;
                                        b = l2 * Math.sin(a3);
                                        a2 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                                        $step = 7;
                                        continue;
                                    }
                                    case 2: {
                                        a = psx * l2;
                                        b = psy * l2;
                                        aa = a * a;
                                        bb = b * b;
                                        ta = Math.atan2(ty, tx);
                                        c = bb * l1 * l1 + aa * dd - aa * bb;
                                        c2 = -2.0 * bb * l1;
                                        c3 = bb - aa;
                                        d = c2 * c2 - 4.0 * c3 * c;
                                        if (d >= 0.0) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 6;
                                        continue;
                                    }
                                    case 3: {
                                        q = Math.sqrt(d);
                                        if (c2 < 0.0) {
                                            q = 0.0 - q;
                                        }
                                        q = (0.0 - (c2 + q)) * 0.5;
                                        r2 = q / c3;
                                        r3 = c / q;
                                        r = ((Math.abs(r2) < Math.abs(r3)) ? r2 : r3);
                                        if (r * r <= dd) {
                                            $step = 4;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                    }
                                    case 4: {
                                        y = Math.sqrt(dd - r * r) * bendDir;
                                        a2 = ta - Math.atan2(y, r);
                                        a3 = Math.atan2(y / psy, (r - l1) / psx);
                                        $step = 8;
                                        continue;
                                    }

                                    case 6: {
                                        minAngle = 3.14159274;
                                        minX = l1 - a;
                                        minDist = minX * minX;
                                        minY = 0.0;
                                        maxAngle = 0.0;
                                        maxX = l1 + a;
                                        maxDist = maxX * maxX;
                                        maxY = 0.0;
                                        c = (0.0 - a) * l1 / (aa - bb);
                                        if (c >= -1.0 && c <= 1.0) {
                                            c = Math.acos(c);
                                            x = a * Math.cos(c) + l1;
                                            y = b * Math.sin(c);
                                            d = x * x + y * y;
                                            if (d < minDist) {
                                                minAngle = c;
                                                minDist = d;
                                                minX = x;
                                                minY = y;
                                            }
                                            if (d > maxDist) {
                                                maxAngle = c;
                                                maxDist = d;
                                                maxX = x;
                                                maxY = y;
                                            }
                                        }
                                        if (dd <= (minDist + maxDist) * 0.5) {
                                            a2 = ta - Math.atan2(minY * bendDir, minX);
                                            a3 = minAngle * bendDir;
                                        } else {
                                            a2 = ta - Math.atan2(maxY * bendDir, maxX);
                                            a3 = maxAngle * bendDir;
                                        }
                                        $step = 7;
                                        continue;
                                    }
                                    case 7: {
                                        $step = 8;
                                        continue;
                                    }
                                    case 8: {
                                        os = Math.atan2(cy, cx) * s2;
                                        rotation = parent.arotation;
                                        a2 = (a2 - os) * (57.2957764) + os2 - rotation;
                                        if (a2 > 180.0) {
                                            a2 -= 360.0;
                                        } else if (a2 < -180.0) {
                                            a2 += 360.0;
                                        }
                                        parent.UpdateWorldTransform$1(px, py, rotation + a2 * alpha, sx, sy, 0.0, 0.0);
                                        rotation = child.arotation;
                                        a3 = ((a3 + os) * (57.2957764) - child.ashearX) * s2 + os3 - rotation;
                                        if (a3 > 180.0) {
                                            a3 -= 360.0;
                                        } else if (a3 < -180.0) {
                                            a3 += 360.0;
                                        }
                                        child.UpdateWorldTransform$1(cx, cy, rotation + a3 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    return $asyncBody();
                },
                /*Spine.IkConstraint.Apply:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            mix: 0,
            softness: 0,
            active: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Mix#set", this ); }

                    this.mix = value;
                }
            },
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Softness#set", this ); }

                    this.softness = value;
                }
            },
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Compress#set", this ); }

                    this.compress = value;
                }
            },
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                this.mix = 1.0;
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.mix = data.mix;
                this.softness = data.softness;
                this.bendDirection = data.bendDirection;
                this.compress = data.compress;
                this.stretch = data.stretch;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.bones.Items)[data.target.index];
            },
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.IkConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.mix = constraint.mix;
                this.softness = constraint.softness;
                this.bendDirection = constraint.bendDirection;
                this.compress = constraint.compress;
                this.stretch = constraint.stretch;
            }
        },
        methods: {
            /*Spine.IkConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#Update", this ); }

                if (this.mix !== 0.0) {
                    var target = this.target;
                    var bones = this.bones.Items;
                    switch (this.bones.Count) {
                        case 1: 
                            Spine.IkConstraint.Apply$1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                            break;
                        case 2: 
                            Spine.IkConstraint.Apply(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);
                            break;
                    }
                }
            },
            /*Spine.IkConstraint.Update end.*/

            /*Spine.IkConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.IkConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    Bridge.define("Spine.IkConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            bendDirection: 0,
            compress: false,
            stretch: false,
            uniform: false,
            mix: 0,
            softness: 0
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            Mix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#get", this ); }

                    return this.mix;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Mix#set", this ); }

                    this.mix = value;
                }
            },
            Softness: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#get", this ); }

                    return this.softness;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Softness#set", this ); }

                    this.softness = value;
                }
            },
            BendDirection: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#get", this ); }

                    return this.bendDirection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#BendDirection#set", this ); }

                    this.bendDirection = value;
                }
            },
            Compress: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#get", this ); }

                    return this.compress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Compress#set", this ); }

                    this.compress = value;
                }
            },
            Stretch: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#get", this ); }

                    return this.stretch;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Stretch#set", this ); }

                    this.stretch = value;
                }
            },
            Uniform: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#get", this ); }

                    return this.uniform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#Uniform#set", this ); }

                    this.uniform = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
                this.bendDirection = 1;
                this.mix = 1.0;
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.IkConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.IkConstraintData end.*/

    /*Spine.PathConstraint start.*/
    Bridge.define("Spine.PathConstraint", {
        inherits: [Spine.IUpdatable],
        statics: {
            fields: {
                NONE: 0,
                BEFORE: 0,
                AFTER: 0,
                Epsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                    this.NONE = -1;
                    this.BEFORE = -2;
                    this.AFTER = -3;
                    this.Epsilon = 1E-05;
                }
            },
            methods: {
                /*Spine.PathConstraint.ArraysFill:static start.*/
                ArraysFill: function (a, fromIndex, toIndex, val) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ArraysFill", this ); }

                    for (var i = fromIndex; i < toIndex; i = (i + 1) | 0) {
                        a[i] = val;
                    }
                },
                /*Spine.PathConstraint.ArraysFill:static end.*/

                /*Spine.PathConstraint.AddBeforePosition:static start.*/
                AddBeforePosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddBeforePosition", this ); }

                    var x1 = temp[i];
                    var y1 = temp[((i + 1) | 0)];
                    var dx = temp[((i + 2) | 0)] - x1;
                    var dy = temp[((i + 3) | 0)] - y1;
                    var r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddBeforePosition:static end.*/

                /*Spine.PathConstraint.AddAfterPosition:static start.*/
                AddAfterPosition: function (p, temp, i, output, o) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddAfterPosition", this ); }

                    var x1 = temp[((i + 2) | 0)];
                    var y1 = temp[((i + 3) | 0)];
                    var dx = x1 - temp[i];
                    var dy = y1 - temp[((i + 1) | 0)];
                    var r = Spine.MathUtils.Atan2(dy, dx);
                    output[o] = x1 + p * Spine.MathUtils.Cos(r);
                    output[((o + 1) | 0)] = y1 + p * Spine.MathUtils.Sin(r);
                    output[((o + 2) | 0)] = r;
                },
                /*Spine.PathConstraint.AddAfterPosition:static end.*/

                /*Spine.PathConstraint.AddCurvePosition:static start.*/
                AddCurvePosition: function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#AddCurvePosition", this ); }

                    if (p < 1E-05 || isNaN(p)) {
                        output[o] = x1;
                        output[((o + 1) | 0)] = y1;
                        output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        return;
                    }
                    var tt = p * p;
                    var ttt = tt * p;
                    var u = 1.0 - p;
                    var uu = u * u;
                    var uuu = uu * u;
                    var ut = u * p;
                    var ut2 = ut * 3.0;
                    var uut3 = u * ut2;
                    var utt3 = ut2 * p;
                    var x3 = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;
                    var y3 = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                    output[o] = x3;
                    output[((o + 1) | 0)] = y3;
                    if (tangents) {
                        if (p < 0.001) {
                            output[((o + 2) | 0)] = Math.atan2(cy1 - y1, cx1 - x1);
                        } else {
                            output[((o + 2) | 0)] = Math.atan2(y3 - (y1 * uu + cy1 * ut * 2.0 + cy2 * tt), x3 - (x1 * uu + cx1 * ut * 2.0 + cx2 * tt));
                        }
                    }
                },
                /*Spine.PathConstraint.AddCurvePosition:static end.*/


            }
        },
        fields: {
            data: null,
            bones: null,
            target: null,
            position: 0,
            spacing: 0,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            active: false,
            spaces: null,
            positions: null,
            world: null,
            curves: null,
            lengths: null,
            segments: null
        },
        props: {
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Position#set", this ); }

                    this.position = value;
                }
            },
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#init", this ); }

                this.spaces = new (Spine.ExposedList$1(System.Single)).ctor();
                this.positions = new (Spine.ExposedList$1(System.Single)).ctor();
                this.world = new (Spine.ExposedList$1(System.Single)).ctor();
                this.curves = new (Spine.ExposedList$1(System.Single)).ctor();
                this.lengths = new (Spine.ExposedList$1(System.Single)).ctor();
                this.segments = System.Array.init(10, 0, System.Single);
            },
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(data.Bones.Count);
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.slots.Items)[data.target.index];
                this.position = data.position;
                this.spacing = data.spacing;
                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
            },
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.bones.Count);
                $t = Bridge.getEnumerator(constraint.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.slots.Items)[constraint.target.data.index];
                this.position = constraint.position;
                this.spacing = constraint.spacing;
                this.mixRotate = constraint.mixRotate;
                this.mixX = constraint.mixX;
                this.mixY = constraint.mixY;
            }
        },
        methods: {
            /*Spine.PathConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#Update", this ); }

                var attachment;
                if (!(((attachment = Bridge.as(this.target.Attachment, Spine.PathAttachment))) != null)) {
                    return;
                }
                var mixRotate = this.mixRotate;
                var mixX = this.mixX;
                var mixY = this.mixY;
                if (mixRotate === 0.0 && mixX === 0.0 && mixY === 0.0) {
                    return;
                }
                var data = this.data;
                var tangents = data.rotateMode === Spine.RotateMode.Tangent;
                var scale = data.rotateMode === Spine.RotateMode.ChainScale;
                var boneCount = this.bones.Count;
                var spacesCount = (tangents ? boneCount : (((boneCount + 1) | 0)));
                var bonesItems = this.bones.Items;
                var spaces = this.spaces.Resize(spacesCount).Items;
                var lengths = (scale ? this.lengths.Resize(boneCount).Items : null);
                var spacing = this.spacing;
                switch (data.spacingMode) {
                    case Spine.SpacingMode.Percent: 
                        if (scale) {
                            var j = 0;
                            for (var n = (spacesCount - 1) | 0; j < n; j = (j + 1) | 0) {
                                var bone2 = bonesItems[j];
                                var setupLength = bone2.data.length;
                                if (setupLength < 1E-05) {
                                    lengths[j] = 0.0;
                                    continue;
                                }
                                var x2 = setupLength * bone2.a;
                                var y2 = setupLength * bone2.c;
                                lengths[j] = Math.sqrt(x2 * x2 + y2 * y2);
                            }
                        }
                        Spine.PathConstraint.ArraysFill(spaces, 1, spacesCount, spacing);
                        break;
                    case Spine.SpacingMode.Proportional: 
                        {
                            var sum = 0.0;
                            var l = 0;
                            var n2 = (spacesCount - 1) | 0;
                            while (l < n2) {
                                var bone3 = bonesItems[l];
                                var setupLength2 = bone3.data.length;
                                if (setupLength2 < 1E-05) {
                                    if (scale) {
                                        lengths[l] = 0.0;
                                    }
                                    spaces[((l = (l + 1) | 0))] = spacing;
                                    continue;
                                }
                                var x3 = setupLength2 * bone3.a;
                                var y3 = setupLength2 * bone3.c;
                                var length3 = Math.sqrt(x3 * x3 + y3 * y3);
                                if (scale) {
                                    lengths[l] = length3;
                                }
                                spaces[((l = (l + 1) | 0))] = length3;
                                sum += length3;
                            }
                            if (sum > 0.0) {
                                sum = spacesCount / sum * spacing;
                                for (var k = 1; k < spacesCount; k = (k + 1) | 0) {
                                    spaces[k] *= sum;
                                }
                            }
                            break;
                        }
                    default: 
                        {
                            var lengthSpacing = data.spacingMode === Spine.SpacingMode.Length;
                            var m = 0;
                            var n3 = (spacesCount - 1) | 0;
                            while (m < n3) {
                                var bone4 = bonesItems[m];
                                var setupLength3 = bone4.data.length;
                                if (setupLength3 < 1E-05) {
                                    if (scale) {
                                        lengths[m] = 0.0;
                                    }
                                    spaces[((m = (m + 1) | 0))] = spacing;
                                    continue;
                                }
                                var x4 = setupLength3 * bone4.a;
                                var y4 = setupLength3 * bone4.c;
                                var length4 = Math.sqrt(x4 * x4 + y4 * y4);
                                if (scale) {
                                    lengths[m] = length4;
                                }
                                spaces[((m = (m + 1) | 0))] = (lengthSpacing ? (setupLength3 + spacing) : spacing) * length4 / setupLength3;
                            }
                            break;
                        }
                }
                var positions = this.ComputeWorldPositions(attachment, spacesCount, tangents);
                var boneX = positions[0];
                var boneY = positions[1];
                var offsetRotation = data.offsetRotation;
                var tip;
                if (offsetRotation === 0.0) {
                    tip = data.rotateMode === Spine.RotateMode.Chain;
                } else {
                    tip = false;
                    var p2 = this.target.bone;
                    offsetRotation *= ((p2.a * p2.d - p2.b * p2.c > 0.0) ? (0.0174532924) : (-0.0174532924));
                }
                var i = 0;
                var p = 3;
                while (i < boneCount) {
                    var bone = bonesItems[i];
                    bone.worldX += (boneX - bone.worldX) * mixX;
                    bone.worldY += (boneY - bone.worldY) * mixY;
                    var x = positions[p];
                    var y = positions[((p + 1) | 0)];
                    var dx = x - boneX;
                    var dy = y - boneY;
                    if (scale) {
                        var length2 = lengths[i];
                        if (length2 >= 1E-05) {
                            var s = (Math.sqrt(dx * dx + dy * dy) / length2 - 1.0) * mixRotate + 1.0;
                            bone.a *= s;
                            bone.c *= s;
                        }
                    }
                    boneX = x;
                    boneY = y;
                    if (mixRotate > 0.0) {
                        var a = bone.a;
                        var b = bone.b;
                        var c = bone.c;
                        var d = bone.d;
                        var r = (tangents ? positions[((p - 1) | 0)] : ((!(spaces[((i + 1) | 0)] < 1E-05)) ? Spine.MathUtils.Atan2(dy, dx) : positions[((p + 2) | 0)]));
                        r -= Spine.MathUtils.Atan2(c, a);
                        var cos;
                        var sin;
                        if (tip) {
                            cos = Spine.MathUtils.Cos(r);
                            sin = Spine.MathUtils.Sin(r);
                            var length = bone.data.length;
                            boneX += (length * (cos * a - sin * c) - dx) * mixRotate;
                            boneY += (length * (sin * a + cos * c) - dy) * mixRotate;
                        } else {
                            r += offsetRotation;
                        }
                        if (r > 3.14159274) {
                            r -= 6.28318548;
                        } else if (r < -3.14159274) {
                            r += 6.28318548;
                        }
                        r *= mixRotate;
                        cos = Spine.MathUtils.Cos(r);
                        sin = Spine.MathUtils.Sin(r);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b - sin * d;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b + cos * d;
                    }
                    bone.UpdateAppliedTransform();
                    i = (i + 1) | 0;
                    p = (p + 3) | 0;
                }
            },
            /*Spine.PathConstraint.Update end.*/

            /*Spine.PathConstraint.ComputeWorldPositions start.*/
            ComputeWorldPositions: function (path, spacesCount, tangents) {
if ( TRACE ) { TRACE( "Spine.PathConstraint#ComputeWorldPositions", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var target = this.target;
                var position = this.position;
                var spaces = this.spaces.Items;
                var output = this.positions.Resize(((Bridge.Int.mul(spacesCount, 3) + 2) | 0)).Items;
                var closed = path.Closed;
                var verticesLength = path.WorldVerticesLength;
                var curveCount = (Bridge.Int.div(verticesLength, 6)) | 0;
                var prevCurve = -1;
                var world;
                var pathLength;
                var multiplier;
                if (!path.ConstantSpeed) {
                    var lengths = path.Lengths;
                    curveCount = (curveCount - (closed ? 1 : 2)) | 0;
                    pathLength = lengths[curveCount];
                    if (this.data.positionMode === Spine.PositionMode.Percent) {
                        position *= pathLength;
                    }
                    switch (this.data.spacingMode) {
                        case Spine.SpacingMode.Percent: 
                            multiplier = pathLength;
                            break;
                        case Spine.SpacingMode.Proportional: 
                            multiplier = pathLength / spacesCount;
                            break;
                        default: 
                            multiplier = 1.0;
                            break;
                    }
                    world = this.world.Resize(8).Items;
                    var k = 0;
                    var o2 = 0;
                    var curve2 = 0;
                    for (; k < spacesCount; k = (k + 1) | 0, o2 = (o2 + 3) | 0) {
                        var space2 = spaces[k] * multiplier;
                        position += space2;
                        var p2 = position;
                        if (closed) {
                            p2 %= pathLength;
                            if (p2 < 0.0) {
                                p2 += pathLength;
                            }
                            curve2 = 0;
                        } else {
                            if (p2 < 0.0) {
                                if (prevCurve !== -2) {
                                    prevCurve = -2;
                                    path.ComputeWorldVertices(target, 2, 4, world, 0);
                                }
                                Spine.PathConstraint.AddBeforePosition(p2, world, 0, output, o2);
                                continue;
                            }
                            if (p2 > pathLength) {
                                if (prevCurve !== -3) {
                                    prevCurve = -3;
                                    path.ComputeWorldVertices(target, ((verticesLength - 6) | 0), 4, world, 0);
                                }
                                Spine.PathConstraint.AddAfterPosition(p2 - pathLength, world, 0, output, o2);
                                continue;
                            }
                        }
                        var length3;
                        while (true) {
                            length3 = lengths[curve2];
                            if (!(p2 > length3)) {
                                break;
                            }
                            curve2 = (curve2 + 1) | 0;
                        }
                        if (curve2 === 0) {
                            p2 /= length3;
                        } else {
                            var prev3 = lengths[((curve2 - 1) | 0)];
                            p2 = (p2 - prev3) / (length3 - prev3);
                        }
                        if (curve2 !== prevCurve) {
                            prevCurve = curve2;
                            if (closed && curve2 === curveCount) {
                                path.ComputeWorldVertices(target, ((verticesLength - 4) | 0), 4, world, 0);
                                path.ComputeWorldVertices(target, 0, 4, world, 4);
                            } else {
                                path.ComputeWorldVertices(target, ((Bridge.Int.mul(curve2, 6) + 2) | 0), 8, world, 0);
                            }
                        }
                        Spine.PathConstraint.AddCurvePosition(p2, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], output, o2, tangents || (k > 0 && space2 < 1E-05));
                    }
                    return output;
                }
                if (closed) {
                    verticesLength = (verticesLength + 2) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, ((verticesLength - 4) | 0), world, 0);
                    path.ComputeWorldVertices(target, 0, 2, world, ((verticesLength - 4) | 0));
                    world[((verticesLength - 2) | 0)] = world[0];
                    world[((verticesLength - 1) | 0)] = world[1];
                } else {
                    curveCount = (curveCount - 1) | 0;
                    verticesLength = (verticesLength - 4) | 0;
                    world = this.world.Resize(verticesLength).Items;
                    path.ComputeWorldVertices(target, 2, verticesLength, world, 0);
                }
                var curves = this.curves.Resize(curveCount).Items;
                pathLength = 0.0;
                var x1 = world[0];
                var y1 = world[1];
                var cx1 = 0.0;
                var cy1 = 0.0;
                var cx2 = 0.0;
                var cy2 = 0.0;
                var x2 = 0.0;
                var y2 = 0.0;
                var j = 0;
                var w = 2;
                while (j < curveCount) {
                    cx1 = world[w];
                    cy1 = world[((w + 1) | 0)];
                    cx2 = world[((w + 2) | 0)];
                    cy2 = world[((w + 3) | 0)];
                    x2 = world[((w + 4) | 0)];
                    y2 = world[((w + 5) | 0)];
                    var tmpx = (x1 - cx1 * 2.0 + cx2) * 0.1875;
                    var tmpy = (y1 - cy1 * 2.0 + cy2) * 0.1875;
                    var dddfx = ((cx1 - cx2) * 3.0 - x1 + x2) * (0.09375);
                    var dddfy = ((cy1 - cy2) * 3.0 - y1 + y2) * (0.09375);
                    var ddfx = tmpx * 2.0 + dddfx;
                    var ddfy = tmpy * 2.0 + dddfy;
                    var dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * (0.166666672);
                    var dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * (0.166666672);
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength = (($t = pathLength + Math.sqrt(dfx * dfx + dfy * dfy), curves[j] = $t, $t));
                    x1 = x2;
                    y1 = y2;
                    j = (j + 1) | 0;
                    w = (w + 6) | 0;
                }
                if (this.data.positionMode === Spine.PositionMode.Percent) {
                    position *= pathLength;
                }
                switch (this.data.spacingMode) {
                    case Spine.SpacingMode.Percent: 
                        multiplier = pathLength;
                        break;
                    case Spine.SpacingMode.Proportional: 
                        multiplier = pathLength / spacesCount;
                        break;
                    default: 
                        multiplier = 1.0;
                        break;
                }
                var segments = this.segments;
                var curveLength = 0.0;
                var i = 0;
                var o = 0;
                var curve = 0;
                var segment = 0;
                for (; i < spacesCount; i = (i + 1) | 0, o = (o + 3) | 0) {
                    var space = spaces[i] * multiplier;
                    position += space;
                    var p = position;
                    if (closed) {
                        p %= pathLength;
                        if (p < 0.0) {
                            p += pathLength;
                        }
                        curve = 0;
                    } else {
                        if (p < 0.0) {
                            Spine.PathConstraint.AddBeforePosition(p, world, 0, output, o);
                            continue;
                        }
                        if (p > pathLength) {
                            Spine.PathConstraint.AddAfterPosition(p - pathLength, world, ((verticesLength - 4) | 0), output, o);
                            continue;
                        }
                    }
                    var length2;
                    while (true) {
                        length2 = curves[curve];
                        if (!(p > length2)) {
                            break;
                        }
                        curve = (curve + 1) | 0;
                    }
                    if (curve === 0) {
                        p /= length2;
                    } else {
                        var prev2 = curves[((curve - 1) | 0)];
                        p = (p - prev2) / (length2 - prev2);
                    }
                    if (curve !== prevCurve) {
                        prevCurve = curve;
                        var ii = Bridge.Int.mul(curve, 6);
                        x1 = world[ii];
                        y1 = world[((ii + 1) | 0)];
                        cx1 = world[((ii + 2) | 0)];
                        cy1 = world[((ii + 3) | 0)];
                        cx2 = world[((ii + 4) | 0)];
                        cy2 = world[((ii + 5) | 0)];
                        x2 = world[((ii + 6) | 0)];
                        y2 = world[((ii + 7) | 0)];
                        var tmpx1 = (x1 - cx1 * 2.0 + cx2) * 0.03;
                        var tmpy1 = (y1 - cy1 * 2.0 + cy2) * 0.03;
                        var dddfx1 = ((cx1 - cx2) * 3.0 - x1 + x2) * 0.006;
                        var dddfy1 = ((cy1 - cy2) * 3.0 - y1 + y2) * 0.006;
                        var ddfx1 = tmpx1 * 2.0 + dddfx1;
                        var ddfy1 = tmpy1 * 2.0 + dddfy1;
                        var dfx1 = (cx1 - x1) * 0.3 + tmpx1 + dddfx1 * (0.166666672);
                        var dfy1 = (cy1 - y1) * 0.3 + tmpy1 + dddfy1 * (0.166666672);
                        curveLength = (($t1 = Math.sqrt(dfx1 * dfx1 + dfy1 * dfy1), segments[0] = $t1, $t1));
                        for (ii = 1; ii < 8; ii = (ii + 1) | 0) {
                            dfx1 += ddfx1;
                            dfy1 += ddfy1;
                            ddfx1 += dddfx1;
                            ddfy1 += dddfy1;
                            curveLength = (($t2 = curveLength + Math.sqrt(dfx1 * dfx1 + dfy1 * dfy1), segments[ii] = $t2, $t2));
                        }
                        dfx1 += ddfx1;
                        dfy1 += ddfy1;
                        curveLength = (($t3 = curveLength + Math.sqrt(dfx1 * dfx1 + dfy1 * dfy1), segments[8] = $t3, $t3));
                        dfx1 += ddfx1 + dddfx1;
                        dfy1 += ddfy1 + dddfy1;
                        curveLength = (($t4 = curveLength + Math.sqrt(dfx1 * dfx1 + dfy1 * dfy1), segments[9] = $t4, $t4));
                        segment = 0;
                    }
                    p *= curveLength;
                    var length;
                    while (true) {
                        length = segments[segment];
                        if (!(p > length)) {
                            break;
                        }
                        segment = (segment + 1) | 0;
                    }
                    if (segment === 0) {
                        p /= length;
                    } else {
                        var prev = segments[((segment - 1) | 0)];
                        p = segment + (p - prev) / (length - prev);
                    }
                    Spine.PathConstraint.AddCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, output, o, tangents || (i > 0 && space < 1E-05));
                }
                return output;
            },
            /*Spine.PathConstraint.ComputeWorldPositions end.*/

            /*Spine.PathConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.PathConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    Bridge.define("Spine.PathConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            positionMode: 0,
            spacingMode: 0,
            rotateMode: 0,
            offsetRotation: 0,
            position: 0,
            spacing: 0,
            mixRotate: 0,
            mixX: 0,
            mixY: 0
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            PositionMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#get", this ); }

                    return this.positionMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#PositionMode#set", this ); }

                    this.positionMode = value;
                }
            },
            SpacingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#get", this ); }

                    return this.spacingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#SpacingMode#set", this ); }

                    this.spacingMode = value;
                }
            },
            RotateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#get", this ); }

                    return this.rotateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMode#set", this ); }

                    this.rotateMode = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            Position: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#get", this ); }

                    return this.position;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Position#set", this ); }

                    this.position = value;
                }
            },
            Spacing: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#get", this ); }

                    return this.spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#Spacing#set", this ); }

                    this.spacing = value;
                }
            },
            RotateMix: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#RotateMix#set", this ); }

                    this.mixRotate = value;
                }
            },
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#MixY#set", this ); }

                    this.mixY = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.PathConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.PathConstraintData end.*/

    /*Spine.PointAttachment start.*/
    Bridge.define("Spine.PointAttachment", {
        inherits: [Spine.Attachment],
        fields: {
            x: 0,
            y: 0,
            rotation: 0
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, other);
                this.x = other.x;
                this.y = other.y;
                this.rotation = other.rotation;
            }
        },
        methods: {
            /*Spine.PointAttachment.ComputeWorldPosition start.*/
            ComputeWorldPosition: function (bone, ox, oy) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldPosition", this ); }

                bone.LocalToWorld(this.x, this.y, ox, oy);
            },
            /*Spine.PointAttachment.ComputeWorldPosition end.*/

            /*Spine.PointAttachment.ComputeWorldRotation start.*/
            ComputeWorldRotation: function (bone) {
if ( TRACE ) { TRACE( "Spine.PointAttachment#ComputeWorldRotation", this ); }

                var cos = Spine.MathUtils.CosDeg(this.rotation);
                var sin = Spine.MathUtils.SinDeg(this.rotation);
                var ix = cos * bone.a + sin * bone.b;
                var iy = cos * bone.c + sin * bone.d;
                return Spine.MathUtils.Atan2(iy, ix) * (57.2957764);
            },
            /*Spine.PointAttachment.ComputeWorldRotation end.*/

            /*Spine.PointAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PointAttachment#Copy", this ); }

                return new Spine.PointAttachment.ctor(this);
            },
            /*Spine.PointAttachment.Copy end.*/


        }
    });
    /*Spine.PointAttachment end.*/

    /*Spine.Pow start.*/
    Bridge.define("Spine.Pow", {
        inherits: [Spine.IInterpolation],
        fields: {
            Power: 0
        },
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.Pow#ctor", this ); }

                this.$initialize();
                Spine.IInterpolation.ctor.call(this);
                this.Power = power;
            }
        },
        methods: {
            /*Spine.Pow.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Pow#Apply$1", this ); }

                if (a <= 0.5) {
                    return Math.pow(a * 2.0, this.Power) / 2.0;
                }
                return Math.pow((a - 1.0) * 2.0, this.Power) / ((this.Power % 2.0 === 0.0) ? (-2) : 2) + 1.0;
            },
            /*Spine.Pow.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.Pow end.*/

    /*Spine.RegionAttachment start.*/
    Bridge.define("Spine.RegionAttachment", {
        inherits: [Spine.Attachment,Spine.IHasTextureRegion],
        statics: {
            fields: {
                BLX: 0,
                BLY: 0,
                ULX: 0,
                ULY: 0,
                URX: 0,
                URY: 0,
                BRX: 0,
                BRY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                    this.BLX = 0;
                    this.BLY = 1;
                    this.ULX = 2;
                    this.ULY = 3;
                    this.URX = 4;
                    this.URY = 5;
                    this.BRX = 6;
                    this.BRY = 7;
                }
            }
        },
        fields: {
            region: null,
            x: 0,
            y: 0,
            rotation: 0,
            scaleX: 0,
            scaleY: 0,
            width: 0,
            height: 0,
            offset: null,
            uvs: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            sequence: null,
            Path: null
        },
        props: {
            X: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#get", this ); }

                    return this.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#X#set", this ); }

                    this.x = value;
                }
            },
            Y: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#get", this ); }

                    return this.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Y#set", this ); }

                    this.y = value;
                }
            },
            Rotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#get", this ); }

                    return this.rotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Rotation#set", this ); }

                    this.rotation = value;
                }
            },
            ScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#get", this ); }

                    return this.scaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleX#set", this ); }

                    this.scaleX = value;
                }
            },
            ScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#get", this ); }

                    return this.scaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ScaleY#set", this ); }

                    this.scaleY = value;
                }
            },
            Width: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#get", this ); }

                    return this.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Width#set", this ); }

                    this.width = value;
                }
            },
            Height: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#get", this ); }

                    return this.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Height#set", this ); }

                    this.height = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            Region: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Region#get", this ); }

                    return this.region;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Region#set", this ); }

                    this.region = value;
                }
            },
            Offset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Offset#get", this ); }

                    return this.offset;
                }
            },
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UVs#get", this ); }

                    return this.uvs;
                }
            },
            Sequence: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Sequence#get", this ); }

                    return this.sequence;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Sequence#set", this ); }

                    this.sequence = value;
                }
            }
        },
        alias: [
            "R", "Spine$IHasTextureRegion$R",
            "G", "Spine$IHasTextureRegion$G",
            "B", "Spine$IHasTextureRegion$B",
            "A", "Spine$IHasTextureRegion$A",
            "Path", "Spine$IHasTextureRegion$Path",
            "Region", "Spine$IHasTextureRegion$Region",
            "Sequence", "Spine$IHasTextureRegion$Sequence",
            "UpdateRegion", "Spine$IHasTextureRegion$UpdateRegion"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#init", this ); }

                this.scaleX = 1.0;
                this.scaleY = 1.0;
                this.offset = System.Array.init(8, 0, System.Single);
                this.uvs = System.Array.init(8, 0, System.Single);
                this.r = 1.0;
                this.g = 1.0;
                this.b = 1.0;
                this.a = 1.0;
            },
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.Attachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ctor", this ); }

                this.$initialize();
                Spine.Attachment.ctor.call(this, other);
                this.region = other.region;
                this.Path = other.Path;
                this.x = other.x;
                this.y = other.y;
                this.scaleX = other.scaleX;
                this.scaleY = other.scaleY;
                this.rotation = other.rotation;
                this.width = other.width;
                this.height = other.height;
                System.Array.copy(other.uvs, 0, this.uvs, 0, 8);
                System.Array.copy(other.offset, 0, this.offset, 0, 8);
                this.r = other.r;
                this.g = other.g;
                this.b = other.b;
                this.a = other.a;
                this.sequence = ((other.sequence == null) ? null : new Spine.Sequence.ctor(other.sequence));
            }
        },
        methods: {
            /*Spine.RegionAttachment.UpdateRegion start.*/
            UpdateRegion: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#UpdateRegion", this ); }

                var uvs = this.uvs;
                if (this.region == null) {
                    uvs[0] = 0.0;
                    uvs[1] = 0.0;
                    uvs[2] = 0.0;
                    uvs[3] = 1.0;
                    uvs[4] = 1.0;
                    uvs[5] = 1.0;
                    uvs[6] = 1.0;
                    uvs[7] = 0.0;
                    return;
                }
                var width = this.Width;
                var height = this.Height;
                var localX2 = width / 2.0;
                var localY2 = height / 2.0;
                var localX = 0.0 - localX2;
                var localY = 0.0 - localY2;
                var rotated = false;
                if (Bridge.is(this.region, Spine.AtlasRegion)) {
                    var region = Bridge.cast(this.region, Spine.AtlasRegion);
                    localX += region.offsetX / region.originalWidth * width;
                    localY += region.offsetY / region.originalHeight * height;
                    if (region.degrees === 90) {
                        rotated = true;
                        localX2 -= (region.originalWidth - region.offsetX - region.packedHeight) / region.originalWidth * width;
                        localY2 -= (region.originalHeight - region.offsetY - region.packedWidth) / region.originalHeight * height;
                    } else {
                        localX2 -= (region.originalWidth - region.offsetX - region.packedWidth) / region.originalWidth * width;
                        localY2 -= (region.originalHeight - region.offsetY - region.packedHeight) / region.originalHeight * height;
                    }
                }
                var scaleX = this.ScaleX;
                var scaleY = this.ScaleY;
                localX *= scaleX;
                localY *= scaleY;
                localX2 *= scaleX;
                localY2 *= scaleY;
                var rotation = this.Rotation;
                var cos = Spine.MathUtils.CosDeg(this.rotation);
                var sin = Spine.MathUtils.SinDeg(this.rotation);
                var x = this.X;
                var y = this.Y;
                var localXCos = localX * cos + x;
                var localXSin = localX * sin;
                var localYCos = localY * cos + y;
                var localYSin = localY * sin;
                var localX2Cos = localX2 * cos + x;
                var localX2Sin = localX2 * sin;
                var localY2Cos = localY2 * cos + y;
                var localY2Sin = localY2 * sin;
                var offset = this.offset;
                offset[0] = localXCos - localYSin;
                offset[1] = localYCos + localXSin;
                offset[2] = localXCos - localY2Sin;
                offset[3] = localY2Cos + localXSin;
                offset[4] = localX2Cos - localY2Sin;
                offset[5] = localY2Cos + localX2Sin;
                offset[6] = localX2Cos - localYSin;
                offset[7] = localYCos + localX2Sin;
                if (rotated) {
                    uvs[0] = this.region.u2;
                    uvs[1] = this.region.v;
                    uvs[2] = this.region.u2;
                    uvs[3] = this.region.v2;
                    uvs[4] = this.region.u;
                    uvs[5] = this.region.v2;
                    uvs[6] = this.region.u;
                    uvs[7] = this.region.v;
                } else {
                    uvs[0] = this.region.u2;
                    uvs[1] = this.region.v2;
                    uvs[2] = this.region.u;
                    uvs[3] = this.region.v2;
                    uvs[4] = this.region.u;
                    uvs[5] = this.region.v;
                    uvs[6] = this.region.u2;
                    uvs[7] = this.region.v;
                }
            },
            /*Spine.RegionAttachment.UpdateRegion end.*/

            /*Spine.RegionAttachment.ComputeWorldVertices start.*/
            ComputeWorldVertices: function (slot, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                if (this.sequence != null) {
                    this.sequence.Apply(slot, this);
                }
                var vertexOffset = this.offset;
                var bone = slot.Bone;
                var bwx = bone.worldX;
                var bwy = bone.worldY;
                var a = bone.a;
                var b = bone.b;
                var c = bone.c;
                var d = bone.d;
                var offsetX = vertexOffset[6];
                var offsetY = vertexOffset[7];
                worldVertices[offset] = offsetX * a + offsetY * b + bwx;
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;
                offsetX = vertexOffset[0];
                offsetY = vertexOffset[1];
                worldVertices[offset] = offsetX * a + offsetY * b + bwx;
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;
                offsetX = vertexOffset[2];
                offsetY = vertexOffset[3];
                worldVertices[offset] = offsetX * a + offsetY * b + bwx;
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
                offset = (offset + stride) | 0;
                offsetX = vertexOffset[4];
                offsetY = vertexOffset[5];
                worldVertices[offset] = offsetX * a + offsetY * b + bwx;
                worldVertices[((offset + 1) | 0)] = offsetX * c + offsetY * d + bwy;
            },
            /*Spine.RegionAttachment.ComputeWorldVertices end.*/

            /*Spine.RegionAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.RegionAttachment#Copy", this ); }

                return new Spine.RegionAttachment.ctor(this);
            },
            /*Spine.RegionAttachment.Copy end.*/


        }
    });
    /*Spine.RegionAttachment end.*/

    /*Spine.SequenceTimeline start.*/
    Bridge.define("Spine.SequenceTimeline", {
        inherits: [Spine.Timeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                MODE: 0,
                DELAY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#init", this ); }

                    this.ENTRIES = 3;
                    this.MODE = 1;
                    this.DELAY = 2;
                }
            }
        },
        fields: {
            slotIndex: 0,
            attachment: null
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#FrameEntries#get", this ); }

                    return 3;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#Attachment#get", this ); }

                    return Bridge.cast(this.attachment, Spine.Attachment);
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, slotIndex, attachment) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#ctor", this ); }

                this.$initialize();
                Spine.Timeline.ctor.call(this, frameCount, [19 + "|" + slotIndex + "|" + Bridge.cast(attachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Sequence.Id]);
                this.slotIndex = slotIndex;
                this.attachment = Bridge.cast(attachment, Spine.IHasTextureRegion);
            }
        },
        methods: {
            /*Spine.SequenceTimeline.SetFrame start.*/
            SetFrame: function (frame, time, mode, index, delay) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 3);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = mode | (index << 4);
                this.frames[((frame + 2) | 0)] = delay;
            },
            /*Spine.SequenceTimeline.SetFrame end.*/

            /*Spine.SequenceTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.SequenceTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var slotAttachment = slot.attachment;
                var vertexAttachment;
                if (!Bridge.referenceEquals(slotAttachment, this.attachment) && (!(((vertexAttachment = Bridge.as(slotAttachment, Spine.VertexAttachment))) != null) || !Bridge.referenceEquals(vertexAttachment.TimelineAttachment, this.attachment))) {
                    return;
                }
                var sequence = Bridge.cast(slotAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Sequence;
                if (sequence == null) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    if (blend === Spine.MixBlend.Setup || blend === Spine.MixBlend.First) {
                        slot.SequenceIndex = -1;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 3);
                var before = frames[i];
                var modeAndIndex = Bridge.Int.clip32(frames[((i + 1) | 0)]);
                var delay = frames[((i + 2) | 0)];
                var index = modeAndIndex >> 4;
                var count = sequence.Regions.length;
                var mode = modeAndIndex & 15;
                if (mode !== 0) {
                    index = (index + (Bridge.Int.clip32((time - before) / delay + 1E-05))) | 0;
                    switch (mode) {
                        case Spine.SequenceMode.Once: 
                            index = Math.min(((count - 1) | 0), index);
                            break;
                        case Spine.SequenceMode.Loop: 
                            index = index % count;
                            break;
                        case Spine.SequenceMode.Pingpong: 
                            {
                                var j = ((count << 1) - 2) | 0;
                                index = ((j !== 0) ? (index % j) : 0);
                                if (index >= count) {
                                    index = (j - index) | 0;
                                }
                                break;
                            }
                        case Spine.SequenceMode.OnceReverse: 
                            index = Math.max(((((count - 1) | 0) - index) | 0), 0);
                            break;
                        case Spine.SequenceMode.LoopReverse: 
                            index = (((count - 1) | 0) - index % count) | 0;
                            break;
                        case Spine.SequenceMode.PingpongReverse: 
                            {
                                var k = ((count << 1) - 2) | 0;
                                index = ((k !== 0) ? ((((((index + count) | 0) - 1) | 0)) % k) : 0);
                                if (index >= count) {
                                    index = (k - index) | 0;
                                }
                                break;
                            }
                    }
                }
                slot.SequenceIndex = index;
            },
            /*Spine.SequenceTimeline.Apply end.*/


        }
    });
    /*Spine.SequenceTimeline end.*/

    /*Spine.SkeletonBinary start.*/
    Bridge.define("Spine.SkeletonBinary", {
        inherits: [Spine.SkeletonLoader],
        statics: {
            fields: {
                BONE_ROTATE: 0,
                BONE_TRANSLATE: 0,
                BONE_TRANSLATEX: 0,
                BONE_TRANSLATEY: 0,
                BONE_SCALE: 0,
                BONE_SCALEX: 0,
                BONE_SCALEY: 0,
                BONE_SHEAR: 0,
                BONE_SHEARX: 0,
                BONE_SHEARY: 0,
                SLOT_ATTACHMENT: 0,
                SLOT_RGBA: 0,
                SLOT_RGB: 0,
                SLOT_RGBA2: 0,
                SLOT_RGB2: 0,
                SLOT_ALPHA: 0,
                ATTACHMENT_DEFORM: 0,
                ATTACHMENT_SEQUENCE: 0,
                PATH_POSITION: 0,
                PATH_SPACING: 0,
                PATH_MIX: 0,
                CURVE_LINEAR: 0,
                CURVE_STEPPED: 0,
                CURVE_BEZIER: 0,
                TransformModeValues: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#init", this ); }

                    this.BONE_ROTATE = 0;
                    this.BONE_TRANSLATE = 1;
                    this.BONE_TRANSLATEX = 2;
                    this.BONE_TRANSLATEY = 3;
                    this.BONE_SCALE = 4;
                    this.BONE_SCALEX = 5;
                    this.BONE_SCALEY = 6;
                    this.BONE_SHEAR = 7;
                    this.BONE_SHEARX = 8;
                    this.BONE_SHEARY = 9;
                    this.SLOT_ATTACHMENT = 0;
                    this.SLOT_RGBA = 1;
                    this.SLOT_RGB = 2;
                    this.SLOT_RGBA2 = 3;
                    this.SLOT_RGB2 = 4;
                    this.SLOT_ALPHA = 5;
                    this.ATTACHMENT_DEFORM = 0;
                    this.ATTACHMENT_SEQUENCE = 1;
                    this.PATH_POSITION = 0;
                    this.PATH_SPACING = 1;
                    this.PATH_MIX = 2;
                    this.CURVE_LINEAR = 0;
                    this.CURVE_STEPPED = 1;
                    this.CURVE_BEZIER = 2;
                    this.TransformModeValues = System.Array.init([Spine.TransformMode.Normal, Spine.TransformMode.OnlyTranslation, Spine.TransformMode.NoRotationOrReflection, Spine.TransformMode.NoScale, Spine.TransformMode.NoScaleOrReflection], Spine.TransformMode);
                }
            },
            methods: {
                /*Spine.SkeletonBinary.GetVersionString:static start.*/
                GetVersionString: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#GetVersionString", this ); }

                    if (file == null) {
                        throw new System.ArgumentNullException.$ctor1("file");
                    }
                    var input = new Spine.SkeletonBinary.SkeletonInput(file);
                    return input.GetVersionString();
                },
                /*Spine.SkeletonBinary.GetVersionString:static end.*/


            }
        },
        ctors: {
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#$ctor1", this ); }

                this.$initialize();
                Spine.SkeletonLoader.$ctor1.call(this, attachmentLoader);
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                Spine.SkeletonLoader.ctor.call(this, atlasArray);
            }
        },
        methods: {
            /*Spine.SkeletonBinary.ReadSkeletonData start.*/
            ReadSkeletonData: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData", this ); }

                var input = new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1);
                try {
                    var skeletonData = this.ReadSkeletonData$1(input);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(input)) {
                        input.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonBinary.ReadSkeletonData end.*/

            /*Spine.SkeletonBinary.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (file) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkeletonData$1", this ); }

                if (file == null) {
                    throw new System.ArgumentNullException.$ctor1("file");
                }
                var scale = this.scale;
                var skeletonData = new Spine.SkeletonData();
                var input = new Spine.SkeletonBinary.SkeletonInput(file);
                var hash = input.ReadLong();
                skeletonData.hash = ((hash.equals(System.Int64(0))) ? null : Bridge.toString(hash));
                skeletonData.version = input.ReadString();
                if (skeletonData.version.length === 0) {
                    skeletonData.version = null;
                }
                if (skeletonData.version.length > 13) {
                    return null;
                }
                skeletonData.x = input.ReadFloat();
                skeletonData.y = input.ReadFloat();
                skeletonData.width = input.ReadFloat();
                skeletonData.height = input.ReadFloat();
                var nonessential = input.ReadBoolean();
                if (nonessential) {
                    skeletonData.fps = input.ReadFloat();
                    skeletonData.imagesPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.imagesPath)) {
                        skeletonData.imagesPath = null;
                    }
                    skeletonData.audioPath = input.ReadString();
                    if (System.String.isNullOrEmpty(skeletonData.audioPath)) {
                        skeletonData.audioPath = null;
                    }
                }
                var n2;
                var o = ((input.strings = System.Array.init((n2 = input.ReadInt$1(true)), null, System.String)));
                for (var i5 = 0; i5 < n2; i5 = (i5 + 1) | 0) {
                    o[i5] = input.ReadString();
                }
                var bones = skeletonData.bones.Resize((n2 = input.ReadInt$1(true))).Items;
                for (var i4 = 0; i4 < n2; i4 = (i4 + 1) | 0) {
                    var name = input.ReadString();
                    var parent = ((i4 === 0) ? null : bones[input.ReadInt$1(true)]);
                    var data = new Spine.BoneData(i4, name, parent);
                    data.rotation = input.ReadFloat();
                    data.x = input.ReadFloat() * scale;
                    data.y = input.ReadFloat() * scale;
                    data.scaleX = input.ReadFloat();
                    data.scaleY = input.ReadFloat();
                    data.shearX = input.ReadFloat();
                    data.shearY = input.ReadFloat();
                    data.Length = input.ReadFloat() * scale;
                    data.transformMode = Spine.SkeletonBinary.TransformModeValues[input.ReadInt$1(true)];
                    data.skinRequired = input.ReadBoolean();
                    if (nonessential) {
                        input.ReadInt();
                    }
                    bones[i4] = data;
                }
                var slots = skeletonData.slots.Resize((n2 = input.ReadInt$1(true))).Items;
                for (var i3 = 0; i3 < n2; i3 = (i3 + 1) | 0) {
                    var slotName = input.ReadString();
                    var boneData = bones[input.ReadInt$1(true)];
                    var slotData = new Spine.SlotData(i3, slotName, boneData);
                    var color = input.ReadInt();
                    slotData.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                    slotData.g = ((color & 16711680) >> 16) / 255.0;
                    slotData.b = ((color & 65280) >> 8) / 255.0;
                    slotData.a = (color & 255) / 255.0;
                    var darkColor = input.ReadInt();
                    if (darkColor !== -1) {
                        slotData.hasSecondColor = true;
                        slotData.r2 = ((darkColor & 16711680) >> 16) / 255.0;
                        slotData.g2 = ((darkColor & 65280) >> 8) / 255.0;
                        slotData.b2 = (darkColor & 255) / 255.0;
                    }
                    slotData.attachmentName = input.ReadStringRef();
                    slotData.blendMode = input.ReadInt$1(true);
                    slots[i3] = slotData;
                }
                var items = skeletonData.ikConstraints.Resize((n2 = input.ReadInt$1(true))).Items;
                o = items;
                for (var i2 = 0; i2 < n2; i2 = (i2 + 1) | 0) {
                    var data2 = new Spine.IkConstraintData(input.ReadString());
                    data2.order = input.ReadInt$1(true);
                    data2.skinRequired = input.ReadBoolean();
                    var nn;
                    var constraintBones = data2.bones.Resize((nn = input.ReadInt$1(true))).Items;
                    for (var ii = 0; ii < nn; ii = (ii + 1) | 0) {
                        constraintBones[ii] = bones[input.ReadInt$1(true)];
                    }
                    data2.target = bones[input.ReadInt$1(true)];
                    data2.mix = input.ReadFloat();
                    data2.softness = input.ReadFloat() * scale;
                    data2.bendDirection = input.ReadSByte();
                    data2.compress = input.ReadBoolean();
                    data2.stretch = input.ReadBoolean();
                    data2.uniform = input.ReadBoolean();
                    o[i2] = data2;
                }
                items = skeletonData.transformConstraints.Resize((n2 = input.ReadInt$1(true))).Items;
                o = items;
                for (var n = 0; n < n2; n = (n + 1) | 0) {
                    var data3 = new Spine.TransformConstraintData(input.ReadString());
                    data3.order = input.ReadInt$1(true);
                    data3.skinRequired = input.ReadBoolean();
                    var nn2;
                    var constraintBones2 = data3.bones.Resize((nn2 = input.ReadInt$1(true))).Items;
                    for (var ii2 = 0; ii2 < nn2; ii2 = (ii2 + 1) | 0) {
                        constraintBones2[ii2] = bones[input.ReadInt$1(true)];
                    }
                    data3.target = bones[input.ReadInt$1(true)];
                    data3.local = input.ReadBoolean();
                    data3.relative = input.ReadBoolean();
                    data3.offsetRotation = input.ReadFloat();
                    data3.offsetX = input.ReadFloat() * scale;
                    data3.offsetY = input.ReadFloat() * scale;
                    data3.offsetScaleX = input.ReadFloat();
                    data3.offsetScaleY = input.ReadFloat();
                    data3.offsetShearY = input.ReadFloat();
                    data3.mixRotate = input.ReadFloat();
                    data3.mixX = input.ReadFloat();
                    data3.mixY = input.ReadFloat();
                    data3.mixScaleX = input.ReadFloat();
                    data3.mixScaleY = input.ReadFloat();
                    data3.mixShearY = input.ReadFloat();
                    o[n] = data3;
                }
                items = skeletonData.pathConstraints.Resize((n2 = input.ReadInt$1(true))).Items;
                o = items;
                for (var m = 0; m < n2; m = (m + 1) | 0) {
                    var data4 = new Spine.PathConstraintData(input.ReadString());
                    data4.order = input.ReadInt$1(true);
                    data4.skinRequired = input.ReadBoolean();
                    var nn3;
                    items = data4.bones.Resize((nn3 = input.ReadInt$1(true))).Items;
                    var constraintBones3 = items;
                    for (var ii3 = 0; ii3 < nn3; ii3 = (ii3 + 1) | 0) {
                        constraintBones3[ii3] = bones[input.ReadInt$1(true)];
                    }
                    data4.target = slots[input.ReadInt$1(true)];
                    data4.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.PositionMode), input.ReadInt$1(true)), Spine.PositionMode), System.Int32));
                    data4.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.SpacingMode), input.ReadInt$1(true)), Spine.SpacingMode), System.Int32));
                    data4.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Array.get(System.Enum.getValues(Spine.RotateMode), input.ReadInt$1(true)), Spine.RotateMode), System.Int32));
                    data4.offsetRotation = input.ReadFloat();
                    data4.position = input.ReadFloat();
                    if (data4.positionMode === Spine.PositionMode.Fixed) {
                        data4.position *= scale;
                    }
                    data4.spacing = input.ReadFloat();
                    if (data4.spacingMode === Spine.SpacingMode.Length || data4.spacingMode === Spine.SpacingMode.Fixed) {
                        data4.spacing *= scale;
                    }
                    data4.mixRotate = input.ReadFloat();
                    data4.mixX = input.ReadFloat();
                    data4.mixY = input.ReadFloat();
                    o[m] = data4;
                }
                var defaultSkin = this.ReadSkin(input, skeletonData, true, nonessential);
                if (defaultSkin != null) {
                    skeletonData.defaultSkin = defaultSkin;
                    skeletonData.skins.Add(defaultSkin);
                }
                var l = skeletonData.skins.Count;
                items = skeletonData.skins.Resize((n2 = (l + input.ReadInt$1(true)) | 0)).Items;
                o = items;
                for (; l < n2; l = (l + 1) | 0) {
                    o[l] = this.ReadSkin(input, skeletonData, false, nonessential);
                }
                n2 = this.linkedMeshes.Count;
                for (var k = 0; k < n2; k = (k + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(k);
                    var skin = ((linkedMesh.skin == null) ? skeletonData.DefaultSkin : skeletonData.FindSkin(linkedMesh.skin));
                    if (skin == null) {
                        throw new System.Exception("Skin not found: " + (linkedMesh.skin || ""));
                    }
                    var parent2 = skin.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent2 == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.TimelineAttachment = (linkedMesh.inheritTimelines ? Bridge.cast(parent2, Spine.VertexAttachment) : linkedMesh.mesh);
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent2, Spine.MeshAttachment);
                    if (linkedMesh.mesh.Sequence == null) {
                        linkedMesh.mesh.UpdateRegion();
                    }
                }
                this.linkedMeshes.clear();
                items = skeletonData.events.Resize((n2 = input.ReadInt$1(true))).Items;
                o = items;
                for (var j = 0; j < n2; j = (j + 1) | 0) {
                    var data5 = new Spine.EventData(input.ReadStringRef());
                    data5.Int = input.ReadInt$1(false);
                    data5.Float = input.ReadFloat();
                    data5.String = input.ReadString();
                    data5.AudioPath = input.ReadString();
                    if (data5.AudioPath != null) {
                        data5.Volume = input.ReadFloat();
                        data5.Balance = input.ReadFloat();
                    }
                    o[j] = data5;
                }
                items = skeletonData.animations.Resize((n2 = input.ReadInt$1(true))).Items;
                o = items;
                for (var i = 0; i < n2; i = (i + 1) | 0) {
                    o[i] = this.ReadAnimation(input.ReadString(), input, skeletonData);
                }
                return skeletonData;
            },
            /*Spine.SkeletonBinary.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonBinary.ReadSkin start.*/
            ReadSkin: function (input, skeletonData, defaultSkin, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSkin", this ); }

                var slotCount;
                var skin;
                if (defaultSkin) {
                    slotCount = input.ReadInt$1(true);
                    if (slotCount === 0) {
                        return null;
                    }
                    skin = new Spine.Skin("default");
                } else {
                    skin = new Spine.Skin(input.ReadStringRef());
                    var items = skin.bones.Resize(input.ReadInt$1(true)).Items;
                    var bones = items;
                    var bonesItems = skeletonData.bones.Items;
                    var m = 0;
                    for (var n4 = skin.bones.Count; m < n4; m = (m + 1) | 0) {
                        bones[m] = bonesItems[input.ReadInt$1(true)];
                    }
                    var ikConstraintsItems = skeletonData.ikConstraints.Items;
                    var l = 0;
                    for (var n3 = input.ReadInt$1(true); l < n3; l = (l + 1) | 0) {
                        skin.constraints.Add(ikConstraintsItems[input.ReadInt$1(true)]);
                    }
                    var transformConstraintsItems = skeletonData.transformConstraints.Items;
                    var k = 0;
                    for (var n2 = input.ReadInt$1(true); k < n2; k = (k + 1) | 0) {
                        skin.constraints.Add(transformConstraintsItems[input.ReadInt$1(true)]);
                    }
                    var pathConstraintsItems = skeletonData.pathConstraints.Items;
                    var j = 0;
                    for (var n = input.ReadInt$1(true); j < n; j = (j + 1) | 0) {
                        skin.constraints.Add(pathConstraintsItems[input.ReadInt$1(true)]);
                    }
                    skin.constraints.TrimExcess();
                    slotCount = input.ReadInt$1(true);
                }
                for (var i = 0; i < slotCount; i = (i + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    var ii = 0;
                    for (var nn = input.ReadInt$1(true); ii < nn; ii = (ii + 1) | 0) {
                        var name = input.ReadStringRef();
                        var attachment = this.ReadAttachment(input, skeletonData, skin, slotIndex, name, nonessential);
                        if (attachment != null) {
                            skin.SetAttachment(slotIndex, name, attachment);
                        }
                    }
                }
                return skin;
            },
            /*Spine.SkeletonBinary.ReadSkin end.*/

            /*Spine.SkeletonBinary.ReadAttachment start.*/
            ReadAttachment: function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAttachment", this ); }

                var $t;
                var scale = this.scale;
                var name = input.ReadStringRef();
                if (name == null) {
                    name = attachmentName;
                }
                switch (input.ReadByte()) {
                    case 0: 
                        {
                            var path = input.ReadStringRef();
                            var rotation = input.ReadFloat();
                            var x = input.ReadFloat();
                            var y = input.ReadFloat();
                            var scaleX = input.ReadFloat();
                            var scaleY = input.ReadFloat();
                            var width = input.ReadFloat();
                            var height = input.ReadFloat();
                            var color = input.ReadInt();
                            var sequence = this.ReadSequence(input);
                            if (path == null) {
                                path = name;
                            }
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path, sequence);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = x * scale;
                            region.y = y * scale;
                            region.scaleX = scaleX;
                            region.scaleY = scaleY;
                            region.rotation = rotation;
                            region.width = width * scale;
                            region.height = height * scale;
                            region.r = ((System.Int64(color).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            region.g = ((color & 16711680) >> 16) / 255.0;
                            region.b = ((color & 65280) >> 8) / 255.0;
                            region.a = (color & 255) / 255.0;
                            region.sequence = sequence;
                            if (sequence == null) {
                                region.UpdateRegion();
                            }
                            return region;
                        }
                    case 1: 
                        {
                            var vertexCount2 = input.ReadInt$1(true);
                            var vertices = this.ReadVertices(input, vertexCount2);
                            if (nonessential) {
                                input.ReadInt();
                            }
                            var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                            if (box == null) {
                                return null;
                            }
                            box.worldVerticesLength = vertexCount2 << 1;
                            box.vertices = vertices.vertices;
                            box.bones = vertices.bones;
                            return box;
                        }
                    case 2: 
                        {
                            var path2 = input.ReadStringRef();
                            var color2 = input.ReadInt();
                            var vertexCount3 = input.ReadInt$1(true);
                            var uvs = this.ReadFloatArray(input, vertexCount3 << 1, 1.0);
                            var triangles = this.ReadShortArray(input);
                            var vertices3 = this.ReadVertices(input, vertexCount3);
                            var hullLength = input.ReadInt$1(true);
                            var sequence2 = this.ReadSequence(input);
                            var edges = null;
                            var width2 = 0.0;
                            var height2 = 0.0;
                            if (nonessential) {
                                edges = this.ReadShortArray(input);
                                width2 = input.ReadFloat();
                                height2 = input.ReadFloat();
                            }
                            if (path2 == null) {
                                path2 = name;
                            }
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path2, sequence2);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path2;
                            mesh.r = ((System.Int64(color2).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh.g = ((color2 & 16711680) >> 16) / 255.0;
                            mesh.b = ((color2 & 65280) >> 8) / 255.0;
                            mesh.a = (color2 & 255) / 255.0;
                            mesh.bones = vertices3.bones;
                            mesh.vertices = vertices3.vertices;
                            mesh.WorldVerticesLength = vertexCount3 << 1;
                            mesh.triangles = triangles;
                            mesh.regionUVs = uvs;
                            if (sequence2 == null) {
                                mesh.UpdateRegion();
                            }
                            mesh.HullLength = hullLength << 1;
                            mesh.Sequence = sequence2;
                            if (nonessential) {
                                mesh.Edges = edges;
                                mesh.Width = width2 * scale;
                                mesh.Height = height2 * scale;
                            }
                            return mesh;
                        }
                    case 3: 
                        {
                            var path3 = input.ReadStringRef();
                            var color3 = input.ReadInt();
                            var skinName = input.ReadStringRef();
                            var parent = input.ReadStringRef();
                            var inheritTimelines = input.ReadBoolean();
                            var sequence3 = this.ReadSequence(input);
                            var width3 = 0.0;
                            var height3 = 0.0;
                            if (nonessential) {
                                width3 = input.ReadFloat();
                                height3 = input.ReadFloat();
                            }
                            if (path3 == null) {
                                path3 = name;
                            }
                            var mesh2 = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path3, sequence3);
                            if (mesh2 == null) {
                                return null;
                            }
                            mesh2.Path = path3;
                            mesh2.r = ((System.Int64(color3).and(System.Int64(4278190080))).shr(24)) / 255.0;
                            mesh2.g = ((color3 & 16711680) >> 16) / 255.0;
                            mesh2.b = ((color3 & 65280) >> 8) / 255.0;
                            mesh2.a = (color3 & 255) / 255.0;
                            mesh2.Sequence = sequence3;
                            if (nonessential) {
                                mesh2.Width = width3 * scale;
                                mesh2.Height = height3 * scale;
                            }
                            this.linkedMeshes.add(new Spine.SkeletonLoader.LinkedMesh(mesh2, skinName, slotIndex, parent, inheritTimelines));
                            return mesh2;
                        }
                    case 4: 
                        {
                            var closed = input.ReadBoolean();
                            var constantSpeed = input.ReadBoolean();
                            var vertexCount4 = input.ReadInt$1(true);
                            var vertices4 = this.ReadVertices(input, vertexCount4);
                            var lengths = System.Array.init(((Bridge.Int.div(vertexCount4, 3)) | 0), 0, System.Single);
                            var i = 0;
                            for (var j = lengths.length; i < j; i = (i + 1) | 0) {
                                lengths[i] = input.ReadFloat() * scale;
                            }
                            if (nonessential) {
                                input.ReadInt();
                            }
                            var path4 = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (path4 == null) {
                                return null;
                            }
                            path4.closed = closed;
                            path4.constantSpeed = constantSpeed;
                            path4.worldVerticesLength = vertexCount4 << 1;
                            path4.vertices = vertices4.vertices;
                            path4.bones = vertices4.bones;
                            path4.lengths = lengths;
                            return path4;
                        }
                    case 5: 
                        {
                            var rotation2 = input.ReadFloat();
                            var x2 = input.ReadFloat();
                            var y2 = input.ReadFloat();
                            if (nonessential) {
                                input.ReadInt();
                            }
                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = x2 * scale;
                            point.y = y2 * scale;
                            point.rotation = rotation2;
                            return point;
                        }
                    case 6: 
                        {
                            var endSlotIndex = input.ReadInt$1(true);
                            var vertexCount = input.ReadInt$1(true);
                            var vertices2 = this.ReadVertices(input, vertexCount);
                            if (nonessential) {
                                input.ReadInt();
                            }
                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }
                            clip.EndSlot = ($t = skeletonData.slots.Items)[endSlotIndex];
                            clip.worldVerticesLength = vertexCount << 1;
                            clip.vertices = vertices2.vertices;
                            clip.bones = vertices2.bones;
                            return clip;
                        }
                    default: 
                        return null;
                }
            },
            /*Spine.SkeletonBinary.ReadAttachment end.*/

            /*Spine.SkeletonBinary.ReadSequence start.*/
            ReadSequence: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadSequence", this ); }

                if (!input.ReadBoolean()) {
                    return null;
                }
                var sequence = new Spine.Sequence.$ctor1(input.ReadInt$1(true));
                sequence.Start = input.ReadInt$1(true);
                sequence.Digits = input.ReadInt$1(true);
                sequence.SetupIndex = input.ReadInt$1(true);
                return sequence;
            },
            /*Spine.SkeletonBinary.ReadSequence end.*/

            /*Spine.SkeletonBinary.ReadVertices start.*/
            ReadVertices: function (input, vertexCount) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadVertices", this ); }

                var scale = this.scale;
                var verticesLength = vertexCount << 1;
                var vertices = new Spine.SkeletonBinary.Vertices();
                if (!input.ReadBoolean()) {
                    vertices.vertices = this.ReadFloatArray(input, verticesLength, scale);
                    return vertices;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bonesArray = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    var boneCount = input.ReadInt$1(true);
                    bonesArray.Add(boneCount);
                    for (var ii = 0; ii < boneCount; ii = (ii + 1) | 0) {
                        bonesArray.Add(input.ReadInt$1(true));
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat() * scale);
                        weights.Add(input.ReadFloat());
                    }
                }
                vertices.vertices = weights.ToArray();
                vertices.bones = bonesArray.ToArray();
                return vertices;
            },
            /*Spine.SkeletonBinary.ReadVertices end.*/

            /*Spine.SkeletonBinary.ReadFloatArray start.*/
            ReadFloatArray: function (input, n, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadFloatArray", this ); }

                var array = System.Array.init(n, 0, System.Single);
                if (scale === 1.0) {
                    for (var j = 0; j < n; j = (j + 1) | 0) {
                        array[j] = input.ReadFloat();
                    }
                } else {
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        array[i] = input.ReadFloat() * scale;
                    }
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadFloatArray end.*/

            /*Spine.SkeletonBinary.ReadShortArray start.*/
            ReadShortArray: function (input) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadShortArray", this ); }

                var j = input.ReadInt$1(true);
                var array = System.Array.init(j, 0, System.Int32);
                for (var i = 0; i < j; i = (i + 1) | 0) {
                    array[i] = (input.ReadByte() << 8) | input.ReadByte();
                }
                return array;
            },
            /*Spine.SkeletonBinary.ReadShortArray end.*/

            /*Spine.SkeletonBinary.ReadAnimation start.*/
            ReadAnimation: function (name, input, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadAnimation", this ); }

                var $t, $t1, $t2;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).$ctor3(input.ReadInt$1(true));
                var scale = this.scale;
                var i = 0;
                for (var n2 = input.ReadInt$1(true); i < n2; i = (i + 1) | 0) {
                    var slotIndex = input.ReadInt$1(true);
                    var ii3 = 0;
                    for (var nn = input.ReadInt$1(true); ii3 < nn; ii3 = (ii3 + 1) | 0) {
                        var timelineType = input.ReadByte();
                        var frameCount = input.ReadInt$1(true);
                        var frameLast = (frameCount - 1) | 0;
                        switch (timelineType) {
                            case 0: 
                                {
                                    var timeline = new Spine.AttachmentTimeline(frameCount, slotIndex);
                                    for (var frame = 0; frame < frameCount; frame = (frame + 1) | 0) {
                                        timeline.SetFrame(frame, input.ReadFloat(), input.ReadStringRef());
                                    }
                                    timelines.Add(timeline);
                                    break;
                                }
                            case 1: 
                                {
                                    var timeline2 = new Spine.RGBATimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time = input.ReadFloat();
                                    var r = input.Read() / 255.0;
                                    var g = input.Read() / 255.0;
                                    var b = input.Read() / 255.0;
                                    var a = input.Read() / 255.0;
                                    var frame2 = 0;
                                    var bezier = 0;
                                    while (true) {
                                        timeline2.SetFrame(frame2, time, r, g, b, a);
                                        if (frame2 === frameLast) {
                                            break;
                                        }
                                        var time13 = input.ReadFloat();
                                        var r5 = input.Read() / 255.0;
                                        var g5 = input.Read() / 255.0;
                                        var b5 = input.Read() / 255.0;
                                        var a4 = input.Read() / 255.0;
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline2.SetStepped(frame2);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame2, 0, time, time13, r, r5, 1.0);
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame2, 1, time, time13, g, g5, 1.0);
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame2, 2, time, time13, b, b5, 1.0);
                                                this.SetBezier(input, timeline2, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame2, 3, time, time13, a, a4, 1.0);
                                                break;
                                        }
                                        time = time13;
                                        r = r5;
                                        g = g5;
                                        b = b5;
                                        a = a4;
                                        frame2 = (frame2 + 1) | 0;
                                    }
                                    timelines.Add(timeline2);
                                    break;
                                }
                            case 2: 
                                {
                                    var timeline3 = new Spine.RGBTimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time2 = input.ReadFloat();
                                    var r2 = input.Read() / 255.0;
                                    var g2 = input.Read() / 255.0;
                                    var b2 = input.Read() / 255.0;
                                    var frame3 = 0;
                                    var bezier2 = 0;
                                    while (true) {
                                        timeline3.SetFrame(frame3, time2, r2, g2, b2);
                                        if (frame3 === frameLast) {
                                            break;
                                        }
                                        var time14 = input.ReadFloat();
                                        var r6 = input.Read() / 255.0;
                                        var g6 = input.Read() / 255.0;
                                        var b6 = input.Read() / 255.0;
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline3.SetStepped(frame3);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 0, time2, time14, r2, r6, 1.0);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 1, time2, time14, g2, g6, 1.0);
                                                this.SetBezier(input, timeline3, Bridge.identity(bezier2, ((bezier2 = (bezier2 + 1) | 0))), frame3, 2, time2, time14, b2, b6, 1.0);
                                                break;
                                        }
                                        time2 = time14;
                                        r2 = r6;
                                        g2 = g6;
                                        b2 = b6;
                                        frame3 = (frame3 + 1) | 0;
                                    }
                                    timelines.Add(timeline3);
                                    break;
                                }
                            case 3: 
                                {
                                    var timeline5 = new Spine.RGBA2Timeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time3 = input.ReadFloat();
                                    var r3 = input.Read() / 255.0;
                                    var g3 = input.Read() / 255.0;
                                    var b3 = input.Read() / 255.0;
                                    var a2 = input.Read() / 255.0;
                                    var r7 = input.Read() / 255.0;
                                    var g7 = input.Read() / 255.0;
                                    var b7 = input.Read() / 255.0;
                                    var frame4 = 0;
                                    var bezier3 = 0;
                                    while (true) {
                                        timeline5.SetFrame(frame4, time3, r3, g3, b3, a2, r7, g7, b7);
                                        if (frame4 === frameLast) {
                                            break;
                                        }
                                        var time15 = input.ReadFloat();
                                        var nr = input.Read() / 255.0;
                                        var ng = input.Read() / 255.0;
                                        var nb = input.Read() / 255.0;
                                        var na = input.Read() / 255.0;
                                        var nr3 = input.Read() / 255.0;
                                        var ng3 = input.Read() / 255.0;
                                        var nb3 = input.Read() / 255.0;
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline5.SetStepped(frame4);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 0, time3, time15, r3, nr, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 1, time3, time15, g3, ng, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 2, time3, time15, b3, nb, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 3, time3, time15, a2, na, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 4, time3, time15, r7, nr3, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 5, time3, time15, g7, ng3, 1.0);
                                                this.SetBezier(input, timeline5, Bridge.identity(bezier3, ((bezier3 = (bezier3 + 1) | 0))), frame4, 6, time3, time15, b7, nb3, 1.0);
                                                break;
                                        }
                                        time3 = time15;
                                        r3 = nr;
                                        g3 = ng;
                                        b3 = nb;
                                        a2 = na;
                                        r7 = nr3;
                                        g7 = ng3;
                                        b7 = nb3;
                                        frame4 = (frame4 + 1) | 0;
                                    }
                                    timelines.Add(timeline5);
                                    break;
                                }
                            case 4: 
                                {
                                    var timeline6 = new Spine.RGB2Timeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time5 = input.ReadFloat();
                                    var r4 = input.Read() / 255.0;
                                    var g4 = input.Read() / 255.0;
                                    var b4 = input.Read() / 255.0;
                                    var r8 = input.Read() / 255.0;
                                    var g8 = input.Read() / 255.0;
                                    var b8 = input.Read() / 255.0;
                                    var frame5 = 0;
                                    var bezier4 = 0;
                                    while (true) {
                                        timeline6.SetFrame(frame5, time5, r4, g4, b4, r8, g8, b8);
                                        if (frame5 === frameLast) {
                                            break;
                                        }
                                        var time16 = input.ReadFloat();
                                        var nr2 = input.Read() / 255.0;
                                        var ng2 = input.Read() / 255.0;
                                        var nb2 = input.Read() / 255.0;
                                        var nr4 = input.Read() / 255.0;
                                        var ng4 = input.Read() / 255.0;
                                        var nb4 = input.Read() / 255.0;
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline6.SetStepped(frame5);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 0, time5, time16, r4, nr2, 1.0);
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 1, time5, time16, g4, ng2, 1.0);
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 2, time5, time16, b4, nb2, 1.0);
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 3, time5, time16, r8, nr4, 1.0);
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 4, time5, time16, g8, ng4, 1.0);
                                                this.SetBezier(input, timeline6, Bridge.identity(bezier4, ((bezier4 = (bezier4 + 1) | 0))), frame5, 5, time5, time16, b8, nb4, 1.0);
                                                break;
                                        }
                                        time5 = time16;
                                        r4 = nr2;
                                        g4 = ng2;
                                        b4 = nb2;
                                        r8 = nr4;
                                        g8 = ng4;
                                        b8 = nb4;
                                        frame5 = (frame5 + 1) | 0;
                                    }
                                    timelines.Add(timeline6);
                                    break;
                                }
                            case 5: 
                                {
                                    var timeline7 = new Spine.AlphaTimeline(frameCount, input.ReadInt$1(true), slotIndex);
                                    var time6 = input.ReadFloat();
                                    var a3 = input.Read() / 255.0;
                                    var frame6 = 0;
                                    var bezier5 = 0;
                                    while (true) {
                                        timeline7.SetFrame(frame6, time6, a3);
                                        if (frame6 === frameLast) {
                                            break;
                                        }
                                        var time17 = input.ReadFloat();
                                        var a5 = input.Read() / 255.0;
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline7.SetStepped(frame6);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline7, Bridge.identity(bezier5, ((bezier5 = (bezier5 + 1) | 0))), frame6, 0, time6, time17, a3, a5, 1.0);
                                                break;
                                        }
                                        time6 = time17;
                                        a3 = a5;
                                        frame6 = (frame6 + 1) | 0;
                                    }
                                    timelines.Add(timeline7);
                                    break;
                                }
                        }
                    }
                }
                var j = 0;
                for (var n3 = input.ReadInt$1(true); j < n3; j = (j + 1) | 0) {
                    var boneIndex = input.ReadInt$1(true);
                    var ii4 = 0;
                    for (var nn2 = input.ReadInt$1(true); ii4 < nn2; ii4 = (ii4 + 1) | 0) {
                        var type = input.ReadByte();
                        var frameCount2 = input.ReadInt$1(true);
                        var bezierCount = input.ReadInt$1(true);
                        switch (type) {
                            case 0: 
                                timelines.Add(this.ReadTimeline(input, new Spine.RotateTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 1: 
                                timelines.Add(this.ReadTimeline$1(input, new Spine.TranslateTimeline(frameCount2, bezierCount, boneIndex), scale));
                                break;
                            case 2: 
                                timelines.Add(this.ReadTimeline(input, new Spine.TranslateXTimeline(frameCount2, bezierCount, boneIndex), scale));
                                break;
                            case 3: 
                                timelines.Add(this.ReadTimeline(input, new Spine.TranslateYTimeline(frameCount2, bezierCount, boneIndex), scale));
                                break;
                            case 4: 
                                timelines.Add(this.ReadTimeline$1(input, new Spine.ScaleTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 5: 
                                timelines.Add(this.ReadTimeline(input, new Spine.ScaleXTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 6: 
                                timelines.Add(this.ReadTimeline(input, new Spine.ScaleYTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 7: 
                                timelines.Add(this.ReadTimeline$1(input, new Spine.ShearTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 8: 
                                timelines.Add(this.ReadTimeline(input, new Spine.ShearXTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                            case 9: 
                                timelines.Add(this.ReadTimeline(input, new Spine.ShearYTimeline(frameCount2, bezierCount, boneIndex), 1.0));
                                break;
                        }
                    }
                }
                var k = 0;
                for (var n4 = input.ReadInt$1(true); k < n4; k = (k + 1) | 0) {
                    var index = input.ReadInt$1(true);
                    var frameCount3 = input.ReadInt$1(true);
                    var frameLast2 = (frameCount3 - 1) | 0;
                    var timeline8 = new Spine.IkConstraintTimeline(frameCount3, input.ReadInt$1(true), index);
                    var time7 = input.ReadFloat();
                    var mix = input.ReadFloat();
                    var softness = input.ReadFloat() * scale;
                    var frame7 = 0;
                    var bezier6 = 0;
                    while (true) {
                        timeline8.SetFrame(frame7, time7, mix, softness, input.ReadSByte(), input.ReadBoolean(), input.ReadBoolean());
                        if (frame7 === frameLast2) {
                            break;
                        }
                        var time18 = input.ReadFloat();
                        var mix2 = input.ReadFloat();
                        var softness2 = input.ReadFloat() * scale;
                        switch (input.ReadByte()) {
                            case 1: 
                                timeline8.SetStepped(frame7);
                                break;
                            case 2: 
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame7, 0, time7, time18, mix, mix2, 1.0);
                                this.SetBezier(input, timeline8, Bridge.identity(bezier6, ((bezier6 = (bezier6 + 1) | 0))), frame7, 1, time7, time18, softness, softness2, scale);
                                break;
                        }
                        time7 = time18;
                        mix = mix2;
                        softness = softness2;
                        frame7 = (frame7 + 1) | 0;
                    }
                    timelines.Add(timeline8);
                }
                var l = 0;
                for (var n5 = input.ReadInt$1(true); l < n5; l = (l + 1) | 0) {
                    var index2 = input.ReadInt$1(true);
                    var frameCount4 = input.ReadInt$1(true);
                    var frameLast3 = (frameCount4 - 1) | 0;
                    var timeline10 = new Spine.TransformConstraintTimeline(frameCount4, input.ReadInt$1(true), index2);
                    var time9 = input.ReadFloat();
                    var mixRotate = input.ReadFloat();
                    var mixX = input.ReadFloat();
                    var mixY = input.ReadFloat();
                    var mixScaleX = input.ReadFloat();
                    var mixScaleY = input.ReadFloat();
                    var mixShearY = input.ReadFloat();
                    var frame8 = 0;
                    var bezier7 = 0;
                    while (true) {
                        timeline10.SetFrame(frame8, time9, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);
                        if (frame8 === frameLast3) {
                            break;
                        }
                        var time19 = input.ReadFloat();
                        var mixRotate3 = input.ReadFloat();
                        var mixX3 = input.ReadFloat();
                        var mixY3 = input.ReadFloat();
                        var mixScaleX2 = input.ReadFloat();
                        var mixScaleY2 = input.ReadFloat();
                        var mixShearY2 = input.ReadFloat();
                        switch (input.ReadByte()) {
                            case 1: 
                                timeline10.SetStepped(frame8);
                                break;
                            case 2: 
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 0, time9, time19, mixRotate, mixRotate3, 1.0);
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 1, time9, time19, mixX, mixX3, 1.0);
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 2, time9, time19, mixY, mixY3, 1.0);
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 3, time9, time19, mixScaleX, mixScaleX2, 1.0);
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 4, time9, time19, mixScaleY, mixScaleY2, 1.0);
                                this.SetBezier(input, timeline10, Bridge.identity(bezier7, ((bezier7 = (bezier7 + 1) | 0))), frame8, 5, time9, time19, mixShearY, mixShearY2, 1.0);
                                break;
                        }
                        time9 = time19;
                        mixRotate = mixRotate3;
                        mixX = mixX3;
                        mixY = mixY3;
                        mixScaleX = mixScaleX2;
                        mixScaleY = mixScaleY2;
                        mixShearY = mixShearY2;
                        frame8 = (frame8 + 1) | 0;
                    }
                    timelines.Add(timeline10);
                }
                var m = 0;
                for (var n6 = input.ReadInt$1(true); m < n6; m = (m + 1) | 0) {
                    var index3 = input.ReadInt$1(true);
                    var data = ($t = skeletonData.pathConstraints.Items)[index3];
                    var ii7 = 0;
                    for (var nn3 = input.ReadInt$1(true); ii7 < nn3; ii7 = (ii7 + 1) | 0) {
                        switch (input.ReadByte()) {
                            case 0: 
                                timelines.Add(this.ReadTimeline(input, new Spine.PathConstraintPositionTimeline(input.ReadInt$1(true), input.ReadInt$1(true), index3), (data.positionMode === Spine.PositionMode.Fixed) ? scale : 1.0));
                                break;
                            case 1: 
                                timelines.Add(this.ReadTimeline(input, new Spine.PathConstraintSpacingTimeline(input.ReadInt$1(true), input.ReadInt$1(true), index3), (data.spacingMode === Spine.SpacingMode.Length || data.spacingMode === Spine.SpacingMode.Fixed) ? scale : 1.0));
                                break;
                            case 2: 
                                {
                                    var timeline11 = new Spine.PathConstraintMixTimeline(input.ReadInt$1(true), input.ReadInt$1(true), index3);
                                    var time10 = input.ReadFloat();
                                    var mixRotate2 = input.ReadFloat();
                                    var mixX2 = input.ReadFloat();
                                    var mixY2 = input.ReadFloat();
                                    var frame9 = 0;
                                    var bezier8 = 0;
                                    var frameLast4 = (timeline11.FrameCount - 1) | 0;
                                    while (true) {
                                        timeline11.SetFrame(frame9, time10, mixRotate2, mixX2, mixY2);
                                        if (frame9 === frameLast4) {
                                            break;
                                        }
                                        var time20 = input.ReadFloat();
                                        var mixRotate4 = input.ReadFloat();
                                        var mixX4 = input.ReadFloat();
                                        var mixY4 = input.ReadFloat();
                                        switch (input.ReadByte()) {
                                            case 1: 
                                                timeline11.SetStepped(frame9);
                                                break;
                                            case 2: 
                                                this.SetBezier(input, timeline11, Bridge.identity(bezier8, ((bezier8 = (bezier8 + 1) | 0))), frame9, 0, time10, time20, mixRotate2, mixRotate4, 1.0);
                                                this.SetBezier(input, timeline11, Bridge.identity(bezier8, ((bezier8 = (bezier8 + 1) | 0))), frame9, 1, time10, time20, mixX2, mixX4, 1.0);
                                                this.SetBezier(input, timeline11, Bridge.identity(bezier8, ((bezier8 = (bezier8 + 1) | 0))), frame9, 2, time10, time20, mixY2, mixY4, 1.0);
                                                break;
                                        }
                                        time10 = time20;
                                        mixRotate2 = mixRotate4;
                                        mixX2 = mixX4;
                                        mixY2 = mixY4;
                                        frame9 = (frame9 + 1) | 0;
                                    }
                                    timelines.Add(timeline11);
                                    break;
                                }
                        }
                    }
                }
                var n = 0;
                for (var n7 = input.ReadInt$1(true); n < n7; n = (n + 1) | 0) {
                    var skin = ($t1 = skeletonData.skins.Items)[input.ReadInt$1(true)];
                    var ii6 = 0;
                    for (var nn4 = input.ReadInt$1(true); ii6 < nn4; ii6 = (ii6 + 1) | 0) {
                        var slotIndex3 = input.ReadInt$1(true);
                        var iii = 0;
                        for (var nnn = input.ReadInt$1(true); iii < nnn; iii = (iii + 1) | 0) {
                            var attachmentName = input.ReadStringRef();
                            var attachment = skin.GetAttachment(slotIndex3, attachmentName);
                            if (attachment == null) {
                                throw new System.Runtime.Serialization.SerializationException.$ctor1("Timeline attachment not found: " + (attachmentName || ""));
                            }
                            var timelineType2 = input.ReadByte();
                            var frameCount5 = input.ReadInt$1(true);
                            var frameLast5 = (frameCount5 - 1) | 0;
                            switch (timelineType2) {
                                case 0: 
                                    {
                                        var vertexAttachment = Bridge.cast(attachment, Spine.VertexAttachment);
                                        var weighted = vertexAttachment.Bones != null;
                                        var vertices = vertexAttachment.Vertices;
                                        var deformLength = (weighted ? (((Bridge.Int.div(vertices.length, 3)) | 0) << 1) : vertices.length);
                                        var timeline12 = new Spine.DeformTimeline(frameCount5, input.ReadInt$1(true), slotIndex3, vertexAttachment);
                                        var time11 = input.ReadFloat();
                                        var frame10 = 0;
                                        var bezier9 = 0;
                                        while (true) {
                                            var end = input.ReadInt$1(true);
                                            var deform;
                                            if (end === 0) {
                                                deform = (weighted ? System.Array.init(deformLength, 0, System.Single) : vertices);
                                            } else {
                                                deform = System.Array.init(deformLength, 0, System.Single);
                                                var start = input.ReadInt$1(true);
                                                end = (end + start) | 0;
                                                if (scale === 1.0) {
                                                    for (var v3 = start; v3 < end; v3 = (v3 + 1) | 0) {
                                                        deform[v3] = input.ReadFloat();
                                                    }
                                                } else {
                                                    for (var v2 = start; v2 < end; v2 = (v2 + 1) | 0) {
                                                        deform[v2] = input.ReadFloat() * scale;
                                                    }
                                                }
                                                if (!weighted) {
                                                    var v = 0;
                                                    for (var vn = deform.length; v < vn; v = (v + 1) | 0) {
                                                        deform[v] += vertices[v];
                                                    }
                                                }
                                            }
                                            timeline12.SetFrame(frame10, time11, deform);
                                            if (frame10 === frameLast5) {
                                                break;
                                            }
                                            var time21 = input.ReadFloat();
                                            switch (input.ReadByte()) {
                                                case 1: 
                                                    timeline12.SetStepped(frame10);
                                                    break;
                                                case 2: 
                                                    this.SetBezier(input, timeline12, Bridge.identity(bezier9, ((bezier9 = (bezier9 + 1) | 0))), frame10, 0, time11, time21, 0.0, 1.0, 1.0);
                                                    break;
                                            }
                                            time11 = time21;
                                            frame10 = (frame10 + 1) | 0;
                                        }
                                        timelines.Add(timeline12);
                                        break;
                                    }
                                case 1: 
                                    {
                                        var timeline13 = new Spine.SequenceTimeline(frameCount5, slotIndex3, attachment);
                                        for (var frame11 = 0; frame11 < frameCount5; frame11 = (frame11 + 1) | 0) {
                                            var time12 = input.ReadFloat();
                                            var modeAndIndex = input.ReadInt();
                                            timeline13.SetFrame(frame11, time12, modeAndIndex & 15, modeAndIndex >> 4, input.ReadFloat());
                                        }
                                        timelines.Add(timeline13);
                                        break;
                                    }
                            }
                        }
                    }
                }
                var drawOrderCount = input.ReadInt$1(true);
                if (drawOrderCount > 0) {
                    var timeline4 = new Spine.DrawOrderTimeline(drawOrderCount);
                    var slotCount = skeletonData.slots.Count;
                    for (var i2 = 0; i2 < drawOrderCount; i2 = (i2 + 1) | 0) {
                        var time4 = input.ReadFloat();
                        var offsetCount = input.ReadInt$1(true);
                        var drawOrder = System.Array.init(slotCount, 0, System.Int32);
                        for (var ii = (slotCount - 1) | 0; ii >= 0; ii = (ii - 1) | 0) {
                            drawOrder[ii] = -1;
                        }
                        var unchanged = System.Array.init(((slotCount - offsetCount) | 0), 0, System.Int32);
                        var originalIndex = 0;
                        var unchangedIndex = 0;
                        for (var ii2 = 0; ii2 < offsetCount; ii2 = (ii2 + 1) | 0) {
                            var slotIndex2 = input.ReadInt$1(true);
                            while (originalIndex !== slotIndex2) {
                                unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                            }
                            drawOrder[((originalIndex + input.ReadInt$1(true)) | 0)] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        while (originalIndex < slotCount) {
                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                        }
                        for (var ii5 = (slotCount - 1) | 0; ii5 >= 0; ii5 = (ii5 - 1) | 0) {
                            if (drawOrder[ii5] === -1) {
                                drawOrder[ii5] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                            }
                        }
                        timeline4.SetFrame(i2, time4, drawOrder);
                    }
                    timelines.Add(timeline4);
                }
                var eventCount = input.ReadInt$1(true);
                if (eventCount > 0) {
                    var timeline9 = new Spine.EventTimeline(eventCount);
                    for (var i3 = 0; i3 < eventCount; i3 = (i3 + 1) | 0) {
                        var time8 = input.ReadFloat();
                        var eventData = ($t2 = skeletonData.events.Items)[input.ReadInt$1(true)];
                        var e = new Spine.Event(time8, eventData);
                        e.intValue = input.ReadInt$1(false);
                        e.floatValue = input.ReadFloat();
                        e.stringValue = (input.ReadBoolean() ? input.ReadString() : eventData.String);
                        if (e.Data.AudioPath != null) {
                            e.volume = input.ReadFloat();
                            e.balance = input.ReadFloat();
                        }
                        timeline9.SetFrame(i3, e);
                    }
                    timelines.Add(timeline9);
                }
                var duration = 0.0;
                var items = timelines.Items;
                var i4 = 0;
                for (var n8 = timelines.Count; i4 < n8; i4 = (i4 + 1) | 0) {
                    duration = Math.max(duration, items[i4].Duration);
                }
                return new Spine.Animation(name, timelines, duration);
            },
            /*Spine.SkeletonBinary.ReadAnimation end.*/

            /*Spine.SkeletonBinary.ReadTimeline start.*/
            ReadTimeline: function (input, timeline, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadTimeline", this ); }

                var time = input.ReadFloat();
                var value = input.ReadFloat() * scale;
                var frame = 0;
                var bezier = 0;
                var frameLast = (timeline.FrameCount - 1) | 0;
                while (true) {
                    timeline.SetFrame(frame, time, value);
                    if (frame === frameLast) {
                        break;
                    }
                    var time2 = input.ReadFloat();
                    var value2 = input.ReadFloat() * scale;
                    switch (input.ReadByte()) {
                        case 1: 
                            timeline.SetStepped(frame);
                            break;
                        case 2: 
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 0, time, time2, value, value2, scale);
                            break;
                    }
                    time = time2;
                    value = value2;
                    frame = (frame + 1) | 0;
                }
                return timeline;
            },
            /*Spine.SkeletonBinary.ReadTimeline end.*/

            /*Spine.SkeletonBinary.ReadTimeline$1 start.*/
            ReadTimeline$1: function (input, timeline, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#ReadTimeline$1", this ); }

                var time = input.ReadFloat();
                var value1 = input.ReadFloat() * scale;
                var value2 = input.ReadFloat() * scale;
                var frame = 0;
                var bezier = 0;
                var frameLast = (timeline.FrameCount - 1) | 0;
                while (true) {
                    timeline.SetFrame(frame, time, value1, value2);
                    if (frame === frameLast) {
                        break;
                    }
                    var time2 = input.ReadFloat();
                    var nvalue1 = input.ReadFloat() * scale;
                    var nvalue2 = input.ReadFloat() * scale;
                    switch (input.ReadByte()) {
                        case 1: 
                            timeline.SetStepped(frame);
                            break;
                        case 2: 
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 0, time, time2, value1, nvalue1, scale);
                            this.SetBezier(input, timeline, Bridge.identity(bezier, ((bezier = (bezier + 1) | 0))), frame, 1, time, time2, value2, nvalue2, scale);
                            break;
                    }
                    time = time2;
                    value1 = nvalue1;
                    value2 = nvalue2;
                    frame = (frame + 1) | 0;
                }
                return timeline;
            },
            /*Spine.SkeletonBinary.ReadTimeline$1 end.*/

            /*Spine.SkeletonBinary.SetBezier start.*/
            SetBezier: function (input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonBinary#SetBezier", this ); }

                timeline.SetBezier(bezier, frame, value, time1, value1, input.ReadFloat(), input.ReadFloat() * scale, input.ReadFloat(), input.ReadFloat() * scale, time2, value2);
            },
            /*Spine.SkeletonBinary.SetBezier end.*/


        },
        overloads: {
            "ReadSkeletonData(Stream)": "ReadSkeletonData$1",
            "ReadTimeline(SkeletonInput, CurveTimeline2, float)": "ReadTimeline$1"
        }
    });
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonJson start.*/
    Bridge.define("Spine.SkeletonJson", {
        inherits: [Spine.SkeletonLoader],
        statics: {
            methods: {
                /*Spine.SkeletonJson.ReadSequence:static start.*/
                ReadSequence: function (sequenceJson) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSequence", this ); }

                    var map;
                    if (!(((map = Bridge.as(sequenceJson, System.Collections.Generic.Dictionary$2(System.String,System.Object)))) != null)) {
                        return null;
                    }
                    var sequence = new Spine.Sequence.$ctor1(Spine.SkeletonJson.GetInt(map, "count"));
                    sequence.start = Spine.SkeletonJson.GetInt$1(map, "start", 1);
                    sequence.digits = Spine.SkeletonJson.GetInt$1(map, "digits", 0);
                    sequence.setupIndex = Spine.SkeletonJson.GetInt$1(map, "setup", 0);
                    return sequence;
                },
                /*Spine.SkeletonJson.ReadSequence:static end.*/

                /*Spine.SkeletonJson.ReadTimeline:static start.*/
                ReadTimeline: function (keyMapEnumerator, timeline, defaultValue, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadTimeline", this ); }

                    var keyMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    var time = Spine.SkeletonJson.GetFloat(keyMap, "time", 0.0);
                    var value = Spine.SkeletonJson.GetFloat(keyMap, "value", defaultValue) * scale;
                    var frame = 0;
                    var bezier = 0;
                    while (true) {
                        timeline.SetFrame(frame, time, value);
                        if (!keyMapEnumerator.v.moveNext()) {
                            break;
                        }
                        var nextMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                        var time2 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0.0);
                        var value2 = Spine.SkeletonJson.GetFloat(nextMap, "value", defaultValue) * scale;
                        if (keyMap.containsKey("curve")) {
                            var curve = keyMap.getItem("curve");
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);
                        }
                        time = time2;
                        value = value2;
                        keyMap = nextMap;
                        frame = (frame + 1) | 0;
                    }
                    timeline.Shrink(bezier);
                    return timeline;
                },
                /*Spine.SkeletonJson.ReadTimeline:static end.*/

                /*Spine.SkeletonJson.ReadTimeline$1:static start.*/
                ReadTimeline$1: function (keyMapEnumerator, timeline, name1, name2, defaultValue, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadTimeline$1", this ); }

                    var keyMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    var time = Spine.SkeletonJson.GetFloat(keyMap, "time", 0.0);
                    var value1 = Spine.SkeletonJson.GetFloat(keyMap, name1, defaultValue) * scale;
                    var value2 = Spine.SkeletonJson.GetFloat(keyMap, name2, defaultValue) * scale;
                    var frame = 0;
                    var bezier = 0;
                    while (true) {
                        timeline.SetFrame(frame, time, value1, value2);
                        if (!keyMapEnumerator.v.moveNext()) {
                            break;
                        }
                        var nextMap = Bridge.cast(keyMapEnumerator.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                        var time2 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0.0);
                        var nvalue1 = Spine.SkeletonJson.GetFloat(nextMap, name1, defaultValue) * scale;
                        var nvalue2 = Spine.SkeletonJson.GetFloat(nextMap, name2, defaultValue) * scale;
                        if (keyMap.containsKey("curve")) {
                            var curve = keyMap.getItem("curve");
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);
                            bezier = Spine.SkeletonJson.ReadCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);
                        }
                        time = time2;
                        value1 = nvalue1;
                        value2 = nvalue2;
                        keyMap = nextMap;
                        frame = (frame + 1) | 0;
                    }
                    timeline.Shrink(bezier);
                    return timeline;
                },
                /*Spine.SkeletonJson.ReadTimeline$1:static end.*/

                /*Spine.SkeletonJson.ReadCurve:static start.*/
                ReadCurve: function (curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadCurve", this ); }

                    var curveString;
                    if (((curveString = Bridge.as(curve, System.String))) != null) {
                        if (Bridge.referenceEquals(curveString, "stepped")) {
                            timeline.SetStepped(frame);
                        }
                        return bezier;
                    }
                    var curveValues = Bridge.cast(curve, System.Collections.Generic.List$1(System.Object));
                    var i = value << 2;
                    var cx1 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(i), System.Single), System.Single));
                    var cy1 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 1) | 0)), System.Single), System.Single)) * scale;
                    var cx2 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 2) | 0)), System.Single), System.Single));
                    var cy2 = System.Nullable.getValue(Bridge.cast(Bridge.unbox(curveValues.getItem(((i + 3) | 0)), System.Single), System.Single)) * scale;
                    Spine.SkeletonJson.SetBezier(timeline, frame, value, bezier, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
                    return ((bezier + 1) | 0);
                },
                /*Spine.SkeletonJson.ReadCurve:static end.*/

                /*Spine.SkeletonJson.SetBezier:static start.*/
                SetBezier: function (timeline, frame, value, bezier, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#SetBezier", this ); }

                    timeline.SetBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);
                },
                /*Spine.SkeletonJson.SetBezier:static end.*/

                /*Spine.SkeletonJson.GetFloatArray:static start.*/
                GetFloatArray: function (map, name, scale) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloatArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Single);
                    if (scale === 1.0) {
                        var j = 0;
                        for (var l = list.Count; j < l; j = (j + 1) | 0) {
                            values[j] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(j), System.Single), System.Single));
                        }
                    } else {
                        var i = 0;
                        for (var k = list.Count; i < k; i = (i + 1) | 0) {
                            values[i] = System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single)) * scale;
                        }
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetFloatArray:static end.*/

                /*Spine.SkeletonJson.GetIntArray:static start.*/
                GetIntArray: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetIntArray", this ); }

                    var list = Bridge.cast(map.getItem(name), System.Collections.Generic.List$1(System.Object));
                    var values = System.Array.init(list.Count, 0, System.Int32);
                    var i = 0;
                    for (var j = list.Count; i < j; i = (i + 1) | 0) {
                        values[i] = Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(list.getItem(i), System.Single), System.Single)));
                    }
                    return values;
                },
                /*Spine.SkeletonJson.GetIntArray:static end.*/

                /*Spine.SkeletonJson.GetFloat:static start.*/
                GetFloat: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetFloat", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single));
                },
                /*Spine.SkeletonJson.GetFloat:static end.*/

                /*Spine.SkeletonJson.GetInt$1:static start.*/
                GetInt$1: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt$1", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt$1:static end.*/

                /*Spine.SkeletonJson.GetInt:static start.*/
                GetInt: function (map, name) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetInt", this ); }

                    if (!map.containsKey(name)) {
                        throw new System.ArgumentException.$ctor1("Named value not found: " + (name || ""));
                    }
                    return Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Single), System.Single)));
                },
                /*Spine.SkeletonJson.GetInt:static end.*/

                /*Spine.SkeletonJson.GetBoolean:static start.*/
                GetBoolean: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetBoolean", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return System.Nullable.getValue(Bridge.cast(Bridge.unbox(map.getItem(name), System.Boolean), System.Boolean));
                },
                /*Spine.SkeletonJson.GetBoolean:static end.*/

                /*Spine.SkeletonJson.GetString:static start.*/
                GetString: function (map, name, defaultValue) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#GetString", this ); }

                    if (!map.containsKey(name)) {
                        return defaultValue;
                    }
                    return Bridge.cast(map.getItem(name), System.String);
                },
                /*Spine.SkeletonJson.GetString:static end.*/

                /*Spine.SkeletonJson.ToColor:static start.*/
                ToColor: function (hexString, colorIndex, expectedLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ToColor", this ); }

                    if (expectedLength === void 0) { expectedLength = 8; }
                    if (hexString.length < expectedLength) {
                        throw new System.ArgumentException.$ctor3("Color hexadecimal length must be " + expectedLength + ", received: " + (hexString || ""), "hexString");
                    }
                    return System.Convert.toNumberInBase(hexString.substr(Bridge.Int.mul(colorIndex, 2), 2), 16, 9) / 255.0;
                },
                /*Spine.SkeletonJson.ToColor:static end.*/


            }
        },
        ctors: {
            $ctor1: function (attachmentLoader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#$ctor1", this ); }

                this.$initialize();
                Spine.SkeletonLoader.$ctor1.call(this, attachmentLoader);
            },
            ctor: function (atlasArray) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ctor", this ); }

                if (atlasArray === void 0) { atlasArray = []; }

                this.$initialize();
                Spine.SkeletonLoader.ctor.call(this, atlasArray);
            }
        },
        methods: {
            /*Spine.SkeletonJson.ReadSkeletonData start.*/
            ReadSkeletonData: function (path) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData", this ); }

                var reader = new System.IO.StreamReader.$ctor1(new System.IO.FileStream.$ctor2(path, 3, System.IO.FileAccess.Read, 1));
                try {
                    var skeletonData = this.ReadSkeletonData$1(reader);
                    skeletonData.name = System.IO.Path.GetFileNameWithoutExtension(path);
                    return skeletonData;
                }
                finally {
                    if (Bridge.hasValue(reader)) {
                        reader.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.SkeletonJson.ReadSkeletonData end.*/

            /*Spine.SkeletonJson.ReadSkeletonData$1 start.*/
            ReadSkeletonData$1: function (reader) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadSkeletonData$1", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16;
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }
                var scale = this.scale;
                var skeletonData = new Spine.SkeletonData();
                var root;
                if (!(((root = Bridge.as(Spine.Json.Deserialize(reader), System.Collections.Generic.Dictionary$2(System.String,System.Object)))) != null)) {
                    throw new System.Exception("Invalid JSON.");
                }
                if (root.containsKey("skeleton")) {
                    var skeletonMap = Bridge.cast(root.getItem("skeleton"), System.Collections.Generic.Dictionary$2(System.String,System.Object));
                    skeletonData.hash = Bridge.cast(skeletonMap.getItem("hash"), System.String);
                    skeletonData.version = Bridge.cast(skeletonMap.getItem("spine"), System.String);
                    skeletonData.x = Spine.SkeletonJson.GetFloat(skeletonMap, "x", 0.0);
                    skeletonData.y = Spine.SkeletonJson.GetFloat(skeletonMap, "y", 0.0);
                    skeletonData.width = Spine.SkeletonJson.GetFloat(skeletonMap, "width", 0.0);
                    skeletonData.height = Spine.SkeletonJson.GetFloat(skeletonMap, "height", 0.0);
                    skeletonData.fps = Spine.SkeletonJson.GetFloat(skeletonMap, "fps", 30.0);
                    skeletonData.imagesPath = Spine.SkeletonJson.GetString(skeletonMap, "images", null);
                    skeletonData.audioPath = Spine.SkeletonJson.GetString(skeletonMap, "audio", null);
                }
                if (root.containsKey("bones")) {
                    $t = Bridge.getEnumerator(Bridge.cast(root.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var boneMap = Bridge.cast($t.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var parent2 = null;
                            if (boneMap.containsKey("parent")) {
                                parent2 = skeletonData.FindBone(Bridge.cast(boneMap.getItem("parent"), System.String));
                                if (parent2 == null) {
                                    throw new System.Exception(System.String.concat("Parent bone not found: ", boneMap.getItem("parent")));
                                }
                            }
                            var data2 = new Spine.BoneData(skeletonData.Bones.Count, Bridge.cast(boneMap.getItem("name"), System.String), parent2);
                            data2.length = Spine.SkeletonJson.GetFloat(boneMap, "length", 0.0) * scale;
                            data2.x = Spine.SkeletonJson.GetFloat(boneMap, "x", 0.0) * scale;
                            data2.y = Spine.SkeletonJson.GetFloat(boneMap, "y", 0.0) * scale;
                            data2.rotation = Spine.SkeletonJson.GetFloat(boneMap, "rotation", 0.0);
                            data2.scaleX = Spine.SkeletonJson.GetFloat(boneMap, "scaleX", 1.0);
                            data2.scaleY = Spine.SkeletonJson.GetFloat(boneMap, "scaleY", 1.0);
                            data2.shearX = Spine.SkeletonJson.GetFloat(boneMap, "shearX", 0.0);
                            data2.shearY = Spine.SkeletonJson.GetFloat(boneMap, "shearY", 0.0);
                            var tm = Spine.SkeletonJson.GetString(boneMap, "transform", System.Enum.toString(Spine.TransformMode, Spine.TransformMode.Normal));
                            data2.transformMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TransformMode, tm, true), Spine.TransformMode), System.Int32));
                            data2.skinRequired = Spine.SkeletonJson.GetBoolean(boneMap, "skin", false);
                            skeletonData.bones.Add(data2);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("slots")) {
                    $t1 = Bridge.getEnumerator(Bridge.cast(root.getItem("slots"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t1.moveNext()) {
                            var slotMap = Bridge.cast($t1.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var slotName = Bridge.cast(slotMap.getItem("name"), System.String);
                            var boneName = Bridge.cast(slotMap.getItem("bone"), System.String);
                            var boneData = skeletonData.FindBone(boneName);
                            if (boneData == null) {
                                throw new System.Exception("Slot bone not found: " + (boneName || ""));
                            }
                            var data3 = new Spine.SlotData(skeletonData.Slots.Count, slotName, boneData);
                            if (slotMap.containsKey("color")) {
                                var color = Bridge.cast(slotMap.getItem("color"), System.String);
                                data3.r = Spine.SkeletonJson.ToColor(color, 0);
                                data3.g = Spine.SkeletonJson.ToColor(color, 1);
                                data3.b = Spine.SkeletonJson.ToColor(color, 2);
                                data3.a = Spine.SkeletonJson.ToColor(color, 3);
                            }
                            if (slotMap.containsKey("dark")) {
                                var color2 = Bridge.cast(slotMap.getItem("dark"), System.String);
                                data3.r2 = Spine.SkeletonJson.ToColor(color2, 0, 6);
                                data3.g2 = Spine.SkeletonJson.ToColor(color2, 1, 6);
                                data3.b2 = Spine.SkeletonJson.ToColor(color2, 2, 6);
                                data3.hasSecondColor = true;
                            }
                            data3.attachmentName = Spine.SkeletonJson.GetString(slotMap, "attachment", null);
                            if (slotMap.containsKey("blend")) {
                                data3.blendMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.BlendMode, Bridge.cast(slotMap.getItem("blend"), System.String), true), Spine.BlendMode), System.Int32));
                            } else {
                                data3.blendMode = Spine.BlendMode.Normal;
                            }
                            skeletonData.slots.Add(data3);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("ik")) {
                    $t2 = Bridge.getEnumerator(Bridge.cast(root.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t2.moveNext()) {
                            var constraintMap = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data4 = new Spine.IkConstraintData(Bridge.cast(constraintMap.getItem("name"), System.String));
                            data4.order = Spine.SkeletonJson.GetInt$1(constraintMap, "order", 0);
                            data4.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap, "skin", false);
                            if (constraintMap.containsKey("bones")) {
                                $t3 = Bridge.getEnumerator(Bridge.cast(constraintMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t3.moveNext()) {
                                        var boneName4 = Bridge.cast($t3.Current, System.String);
                                        var bone4 = skeletonData.FindBone(boneName4);
                                        if (bone4 == null) {
                                            throw new System.Exception("IK bone not found: " + (boneName4 || ""));
                                        }
                                        data4.bones.Add(bone4);
                                    }
                                } finally {
                                    if (Bridge.is($t3, System.IDisposable)) {
                                        $t3.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            var targetName3 = Bridge.cast(constraintMap.getItem("target"), System.String);
                            data4.target = skeletonData.FindBone(targetName3);
                            if (data4.target == null) {
                                throw new System.Exception("IK target bone not found: " + (targetName3 || ""));
                            }
                            data4.mix = Spine.SkeletonJson.GetFloat(constraintMap, "mix", 1.0);
                            data4.softness = Spine.SkeletonJson.GetFloat(constraintMap, "softness", 0.0) * scale;
                            data4.bendDirection = (Spine.SkeletonJson.GetBoolean(constraintMap, "bendPositive", true) ? 1 : (-1));
                            data4.compress = Spine.SkeletonJson.GetBoolean(constraintMap, "compress", false);
                            data4.stretch = Spine.SkeletonJson.GetBoolean(constraintMap, "stretch", false);
                            data4.uniform = Spine.SkeletonJson.GetBoolean(constraintMap, "uniform", false);
                            skeletonData.ikConstraints.Add(data4);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("transform")) {
                    $t4 = Bridge.getEnumerator(Bridge.cast(root.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t4.moveNext()) {
                            var constraintMap3 = Bridge.cast($t4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data6 = new Spine.TransformConstraintData(Bridge.cast(constraintMap3.getItem("name"), System.String));
                            data6.order = Spine.SkeletonJson.GetInt$1(constraintMap3, "order", 0);
                            data6.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap3, "skin", false);
                            if (constraintMap3.containsKey("bones")) {
                                $t5 = Bridge.getEnumerator(Bridge.cast(constraintMap3.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t5.moveNext()) {
                                        var boneName3 = Bridge.cast($t5.Current, System.String);
                                        var bone3 = skeletonData.FindBone(boneName3);
                                        if (bone3 == null) {
                                            throw new System.Exception("Transform constraint bone not found: " + (boneName3 || ""));
                                        }
                                        data6.bones.Add(bone3);
                                    }
                                } finally {
                                    if (Bridge.is($t5, System.IDisposable)) {
                                        $t5.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            var targetName2 = Bridge.cast(constraintMap3.getItem("target"), System.String);
                            data6.target = skeletonData.FindBone(targetName2);
                            if (data6.target == null) {
                                throw new System.Exception("Transform constraint target bone not found: " + (targetName2 || ""));
                            }
                            data6.local = Spine.SkeletonJson.GetBoolean(constraintMap3, "local", false);
                            data6.relative = Spine.SkeletonJson.GetBoolean(constraintMap3, "relative", false);
                            data6.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap3, "rotation", 0.0);
                            data6.offsetX = Spine.SkeletonJson.GetFloat(constraintMap3, "x", 0.0) * scale;
                            data6.offsetY = Spine.SkeletonJson.GetFloat(constraintMap3, "y", 0.0) * scale;
                            data6.offsetScaleX = Spine.SkeletonJson.GetFloat(constraintMap3, "scaleX", 0.0);
                            data6.offsetScaleY = Spine.SkeletonJson.GetFloat(constraintMap3, "scaleY", 0.0);
                            data6.offsetShearY = Spine.SkeletonJson.GetFloat(constraintMap3, "shearY", 0.0);
                            data6.mixRotate = Spine.SkeletonJson.GetFloat(constraintMap3, "mixRotate", 1.0);
                            data6.mixX = Spine.SkeletonJson.GetFloat(constraintMap3, "mixX", 1.0);
                            data6.mixY = Spine.SkeletonJson.GetFloat(constraintMap3, "mixY", data6.mixX);
                            data6.mixScaleX = Spine.SkeletonJson.GetFloat(constraintMap3, "mixScaleX", 1.0);
                            data6.mixScaleY = Spine.SkeletonJson.GetFloat(constraintMap3, "mixScaleY", data6.mixScaleX);
                            data6.mixShearY = Spine.SkeletonJson.GetFloat(constraintMap3, "mixShearY", 1.0);
                            skeletonData.transformConstraints.Add(data6);
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("path")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(root.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var constraintMap2 = Bridge.cast($t6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data5 = new Spine.PathConstraintData(Bridge.cast(constraintMap2.getItem("name"), System.String));
                            data5.order = Spine.SkeletonJson.GetInt$1(constraintMap2, "order", 0);
                            data5.skinRequired = Spine.SkeletonJson.GetBoolean(constraintMap2, "skin", false);
                            if (constraintMap2.containsKey("bones")) {
                                $t7 = Bridge.getEnumerator(Bridge.cast(constraintMap2.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t7.moveNext()) {
                                        var boneName2 = Bridge.cast($t7.Current, System.String);
                                        var bone2 = skeletonData.FindBone(boneName2);
                                        if (bone2 == null) {
                                            throw new System.Exception("Path bone not found: " + (boneName2 || ""));
                                        }
                                        data5.bones.Add(bone2);
                                    }
                                } finally {
                                    if (Bridge.is($t7, System.IDisposable)) {
                                        $t7.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            var targetName = Bridge.cast(constraintMap2.getItem("target"), System.String);
                            data5.target = skeletonData.FindSlot(targetName);
                            if (data5.target == null) {
                                throw new System.Exception("Path target slot not found: " + (targetName || ""));
                            }
                            data5.positionMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.PositionMode, Spine.SkeletonJson.GetString(constraintMap2, "positionMode", "percent"), true), Spine.PositionMode), System.Int32));
                            data5.spacingMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SpacingMode, Spine.SkeletonJson.GetString(constraintMap2, "spacingMode", "length"), true), Spine.SpacingMode), System.Int32));
                            data5.rotateMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.RotateMode, Spine.SkeletonJson.GetString(constraintMap2, "rotateMode", "tangent"), true), Spine.RotateMode), System.Int32));
                            data5.offsetRotation = Spine.SkeletonJson.GetFloat(constraintMap2, "rotation", 0.0);
                            data5.position = Spine.SkeletonJson.GetFloat(constraintMap2, "position", 0.0);
                            if (data5.positionMode === Spine.PositionMode.Fixed) {
                                data5.position *= scale;
                            }
                            data5.spacing = Spine.SkeletonJson.GetFloat(constraintMap2, "spacing", 0.0);
                            if (data5.spacingMode === Spine.SpacingMode.Length || data5.spacingMode === Spine.SpacingMode.Fixed) {
                                data5.spacing *= scale;
                            }
                            data5.mixRotate = Spine.SkeletonJson.GetFloat(constraintMap2, "mixRotate", 1.0);
                            data5.mixX = Spine.SkeletonJson.GetFloat(constraintMap2, "mixX", 1.0);
                            data5.mixY = Spine.SkeletonJson.GetFloat(constraintMap2, "mixY", data5.mixX);
                            skeletonData.pathConstraints.Add(data5);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("skins")) {
                    $t8 = Bridge.getEnumerator(Bridge.cast(root.getItem("skins"), System.Collections.Generic.List$1(System.Object)));
                    try {
                        while ($t8.moveNext()) {
                            var skinMap = Bridge.cast($t8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var skin2 = new Spine.Skin(Bridge.cast(skinMap.getItem("name"), System.String));
                            if (skinMap.containsKey("bones")) {
                                $t9 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("bones"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t9.moveNext()) {
                                        var entryName4 = Bridge.cast($t9.Current, System.String);
                                        var bone = skeletonData.FindBone(entryName4);
                                        if (bone == null) {
                                            throw new System.Exception("Skin bone not found: " + (entryName4 || ""));
                                        }
                                        skin2.bones.Add(bone);
                                    }
                                } finally {
                                    if (Bridge.is($t9, System.IDisposable)) {
                                        $t9.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skin2.bones.TrimExcess();
                            if (skinMap.containsKey("ik")) {
                                $t10 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("ik"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t10.moveNext()) {
                                        var entryName3 = Bridge.cast($t10.Current, System.String);
                                        var constraint3 = skeletonData.FindIkConstraint(entryName3);
                                        if (constraint3 == null) {
                                            throw new System.Exception("Skin IK constraint not found: " + (entryName3 || ""));
                                        }
                                        skin2.constraints.Add(constraint3);
                                    }
                                } finally {
                                    if (Bridge.is($t10, System.IDisposable)) {
                                        $t10.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("transform")) {
                                $t11 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("transform"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t11.moveNext()) {
                                        var entryName2 = Bridge.cast($t11.Current, System.String);
                                        var constraint2 = skeletonData.FindTransformConstraint(entryName2);
                                        if (constraint2 == null) {
                                            throw new System.Exception("Skin transform constraint not found: " + (entryName2 || ""));
                                        }
                                        skin2.constraints.Add(constraint2);
                                    }
                                } finally {
                                    if (Bridge.is($t11, System.IDisposable)) {
                                        $t11.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            if (skinMap.containsKey("path")) {
                                $t12 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("path"), System.Collections.Generic.List$1(System.Object)));
                                try {
                                    while ($t12.moveNext()) {
                                        var entryName = Bridge.cast($t12.Current, System.String);
                                        var constraint = skeletonData.FindPathConstraint(entryName);
                                        if (constraint == null) {
                                            throw new System.Exception("Skin path constraint not found: " + (entryName || ""));
                                        }
                                        skin2.constraints.Add(constraint);
                                    }
                                } finally {
                                    if (Bridge.is($t12, System.IDisposable)) {
                                        $t12.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skin2.constraints.TrimExcess();
                            if (skinMap.containsKey("attachments")) {
                                $t13 = Bridge.getEnumerator(Bridge.cast(skinMap.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                try {
                                    while ($t13.moveNext()) {
                                        var slotEntry = $t13.Current;
                                        var slotIndex = this.FindSlotIndex(skeletonData, slotEntry.key);
                                        $t14 = Bridge.getEnumerator(Bridge.cast(slotEntry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                        try {
                                            while ($t14.moveNext()) {
                                                var entry3 = $t14.Current;
                                                try {
                                                    var attachment = this.ReadAttachment(Bridge.cast(entry3.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), skin2, slotIndex, entry3.key, skeletonData);
                                                    if (attachment != null) {
                                                        skin2.SetAttachment(slotIndex, entry3.key, attachment);
                                                    }
                                                } catch (e2) {
                                                    e2 = System.Exception.create(e2);
                                                    throw new System.Exception(System.String.concat("Error reading attachment: " + (entry3.key || "") + ", skin: ", skin2), e2);
                                                }
                                            }
                                        } finally {
                                            if (Bridge.is($t14, System.IDisposable)) {
                                                $t14.System$IDisposable$Dispose();
                                            }
                                        }
                                    }
                                } finally {
                                    if (Bridge.is($t13, System.IDisposable)) {
                                        $t13.System$IDisposable$Dispose();
                                    }
                                }
                            }
                            skeletonData.skins.Add(skin2);
                            if (Bridge.referenceEquals(skin2.name, "default")) {
                                skeletonData.defaultSkin = skin2;
                            }
                        }
                    } finally {
                        if (Bridge.is($t8, System.IDisposable)) {
                            $t8.System$IDisposable$Dispose();
                        }
                    }
                }
                var i = 0;
                for (var j = this.linkedMeshes.Count; i < j; i = (i + 1) | 0) {
                    var linkedMesh = this.linkedMeshes.getItem(i);
                    var skin = ((linkedMesh.skin == null) ? skeletonData.defaultSkin : skeletonData.FindSkin(linkedMesh.skin));
                    if (skin == null) {
                        throw new System.Exception("Slot not found: " + (linkedMesh.skin || ""));
                    }
                    var parent = skin.GetAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent == null) {
                        throw new System.Exception("Parent mesh not found: " + (linkedMesh.parent || ""));
                    }
                    linkedMesh.mesh.TimelineAttachment = (linkedMesh.inheritTimelines ? Bridge.cast(parent, Spine.VertexAttachment) : linkedMesh.mesh);
                    linkedMesh.mesh.ParentMesh = Bridge.cast(parent, Spine.MeshAttachment);
                    if (linkedMesh.mesh.Region != null) {
                        linkedMesh.mesh.UpdateRegion();
                    }
                }
                this.linkedMeshes.clear();
                if (root.containsKey("events")) {
                    $t15 = Bridge.getEnumerator(Bridge.cast(root.getItem("events"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t15.moveNext()) {
                            var entry2 = $t15.Current;
                            var entryMap = Bridge.cast(entry2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var data = new Spine.EventData(entry2.key);
                            data.Int = Spine.SkeletonJson.GetInt$1(entryMap, "int", 0);
                            data.Float = Spine.SkeletonJson.GetFloat(entryMap, "float", 0.0);
                            data.String = Spine.SkeletonJson.GetString(entryMap, "string", "");
                            data.AudioPath = Spine.SkeletonJson.GetString(entryMap, "audio", null);
                            if (data.AudioPath != null) {
                                data.Volume = Spine.SkeletonJson.GetFloat(entryMap, "volume", 1.0);
                                data.Balance = Spine.SkeletonJson.GetFloat(entryMap, "balance", 0.0);
                            }
                            skeletonData.events.Add(data);
                        }
                    } finally {
                        if (Bridge.is($t15, System.IDisposable)) {
                            $t15.System$IDisposable$Dispose();
                        }
                    }
                }
                if (root.containsKey("animations")) {
                    $t16 = Bridge.getEnumerator(Bridge.cast(root.getItem("animations"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t16.moveNext()) {
                            var entry = $t16.Current;
                            try {
                                this.ReadAnimation(Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)), entry.key, skeletonData);
                            } catch (e) {
                                e = System.Exception.create(e);
                                throw new System.Exception("Error reading animation: " + (entry.key || "") + "\n" + (e.Message || ""), e);
                            }
                        }
                    } finally {
                        if (Bridge.is($t16, System.IDisposable)) {
                            $t16.System$IDisposable$Dispose();
                        }
                    }
                }
                skeletonData.bones.TrimExcess();
                skeletonData.slots.TrimExcess();
                skeletonData.skins.TrimExcess();
                skeletonData.events.TrimExcess();
                skeletonData.animations.TrimExcess();
                skeletonData.ikConstraints.TrimExcess();
                return skeletonData;
            },
            /*Spine.SkeletonJson.ReadSkeletonData$1 end.*/

            /*Spine.SkeletonJson.ReadAttachment start.*/
            ReadAttachment: function (map, skin, slotIndex, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAttachment", this ); }

                var scale = this.scale;
                name = Spine.SkeletonJson.GetString(map, "name", name);
                var typeName = Spine.SkeletonJson.GetString(map, "type", "region");
                switch (System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.AttachmentType, typeName, true), Spine.AttachmentType), System.Int32))) {
                    case Spine.AttachmentType.Region: 
                        {
                            var path = Spine.SkeletonJson.GetString(map, "path", name);
                            var sequenceJson = { };
                            map.tryGetValue("sequence", sequenceJson);
                            var sequence = Spine.SkeletonJson.ReadSequence(sequenceJson.v);
                            var region = this.attachmentLoader.Spine$AttachmentLoader$NewRegionAttachment(skin, name, path, sequence);
                            if (region == null) {
                                return null;
                            }
                            region.Path = path;
                            region.x = Spine.SkeletonJson.GetFloat(map, "x", 0.0) * scale;
                            region.y = Spine.SkeletonJson.GetFloat(map, "y", 0.0) * scale;
                            region.scaleX = Spine.SkeletonJson.GetFloat(map, "scaleX", 1.0);
                            region.scaleY = Spine.SkeletonJson.GetFloat(map, "scaleY", 1.0);
                            region.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0.0);
                            region.width = Spine.SkeletonJson.GetFloat(map, "width", 32.0) * scale;
                            region.height = Spine.SkeletonJson.GetFloat(map, "height", 32.0) * scale;
                            region.sequence = sequence;
                            if (map.containsKey("color")) {
                                var color = Bridge.cast(map.getItem("color"), System.String);
                                region.r = Spine.SkeletonJson.ToColor(color, 0);
                                region.g = Spine.SkeletonJson.ToColor(color, 1);
                                region.b = Spine.SkeletonJson.ToColor(color, 2);
                                region.a = Spine.SkeletonJson.ToColor(color, 3);
                            }
                            if (region.Region != null) {
                                region.UpdateRegion();
                            }
                            return region;
                        }
                    case Spine.AttachmentType.Boundingbox: 
                        {
                            var box = this.attachmentLoader.Spine$AttachmentLoader$NewBoundingBoxAttachment(skin, name);
                            if (box == null) {
                                return null;
                            }
                            this.ReadVertices(map, box, Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0) << 1);
                            return box;
                        }
                    case Spine.AttachmentType.Mesh: 
                    case Spine.AttachmentType.Linkedmesh: 
                        {
                            var path2 = Spine.SkeletonJson.GetString(map, "path", name);
                            var sequenceJson2 = { };
                            map.tryGetValue("sequence", sequenceJson2);
                            var sequence2 = Spine.SkeletonJson.ReadSequence(sequenceJson2.v);
                            var mesh = this.attachmentLoader.Spine$AttachmentLoader$NewMeshAttachment(skin, name, path2, sequence2);
                            if (mesh == null) {
                                return null;
                            }
                            mesh.Path = path2;
                            if (map.containsKey("color")) {
                                var color2 = Bridge.cast(map.getItem("color"), System.String);
                                mesh.r = Spine.SkeletonJson.ToColor(color2, 0);
                                mesh.g = Spine.SkeletonJson.ToColor(color2, 1);
                                mesh.b = Spine.SkeletonJson.ToColor(color2, 2);
                                mesh.a = Spine.SkeletonJson.ToColor(color2, 3);
                            }
                            mesh.Width = Spine.SkeletonJson.GetFloat(map, "width", 0.0) * scale;
                            mesh.Height = Spine.SkeletonJson.GetFloat(map, "height", 0.0) * scale;
                            mesh.Sequence = sequence2;
                            var parent = Spine.SkeletonJson.GetString(map, "parent", null);
                            if (parent != null) {
                                this.linkedMeshes.add(new Spine.SkeletonLoader.LinkedMesh(mesh, Spine.SkeletonJson.GetString(map, "skin", null), slotIndex, parent, Spine.SkeletonJson.GetBoolean(map, "timelines", true)));
                                return mesh;
                            }
                            var uvs = Spine.SkeletonJson.GetFloatArray(map, "uvs", 1.0);
                            this.ReadVertices(map, mesh, uvs.length);
                            mesh.triangles = Spine.SkeletonJson.GetIntArray(map, "triangles");
                            mesh.regionUVs = uvs;
                            if (mesh.Region != null) {
                                mesh.UpdateRegion();
                            }
                            if (map.containsKey("hull")) {
                                mesh.HullLength = Spine.SkeletonJson.GetInt$1(map, "hull", 0) << 1;
                            }
                            if (map.containsKey("edges")) {
                                mesh.Edges = Spine.SkeletonJson.GetIntArray(map, "edges");
                            }
                            return mesh;
                        }
                    case Spine.AttachmentType.Path: 
                        {
                            var pathAttachment = this.attachmentLoader.Spine$AttachmentLoader$NewPathAttachment(skin, name);
                            if (pathAttachment == null) {
                                return null;
                            }
                            pathAttachment.closed = Spine.SkeletonJson.GetBoolean(map, "closed", false);
                            pathAttachment.constantSpeed = Spine.SkeletonJson.GetBoolean(map, "constantSpeed", true);
                            var vertexCount = Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0);
                            this.ReadVertices(map, pathAttachment, vertexCount << 1);
                            pathAttachment.lengths = Spine.SkeletonJson.GetFloatArray(map, "lengths", scale);
                            return pathAttachment;
                        }
                    case Spine.AttachmentType.Point: 
                        {
                            var point = this.attachmentLoader.Spine$AttachmentLoader$NewPointAttachment(skin, name);
                            if (point == null) {
                                return null;
                            }
                            point.x = Spine.SkeletonJson.GetFloat(map, "x", 0.0) * scale;
                            point.y = Spine.SkeletonJson.GetFloat(map, "y", 0.0) * scale;
                            point.rotation = Spine.SkeletonJson.GetFloat(map, "rotation", 0.0);
                            return point;
                        }
                    case Spine.AttachmentType.Clipping: 
                        {
                            var clip = this.attachmentLoader.Spine$AttachmentLoader$NewClippingAttachment(skin, name);
                            if (clip == null) {
                                return null;
                            }
                            var end = Spine.SkeletonJson.GetString(map, "end", null);
                            if (end != null) {
                                var slot = skeletonData.FindSlot(end);
                                if (slot == null) {
                                    throw new System.Exception("Clipping end slot not found: " + (end || ""));
                                }
                                clip.EndSlot = slot;
                            }
                            this.ReadVertices(map, clip, Spine.SkeletonJson.GetInt$1(map, "vertexCount", 0) << 1);
                            return clip;
                        }
                    default: 
                        return null;
                }
            },
            /*Spine.SkeletonJson.ReadAttachment end.*/

            /*Spine.SkeletonJson.ReadVertices start.*/
            ReadVertices: function (map, attachment, verticesLength) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadVertices", this ); }

                attachment.WorldVerticesLength = verticesLength;
                var vertices = Spine.SkeletonJson.GetFloatArray(map, "vertices", 1.0);
                var scale = this.Scale;
                if (verticesLength === vertices.length) {
                    if (scale !== 1.0) {
                        for (var j = 0; j < vertices.length; j = (j + 1) | 0) {
                            vertices[j] *= scale;
                        }
                    }
                    attachment.vertices = vertices;
                    return;
                }
                var weights = new (Spine.ExposedList$1(System.Single)).$ctor3(Bridge.Int.mul(Bridge.Int.mul(verticesLength, 3), 3));
                var bones = new (Spine.ExposedList$1(System.Int32)).$ctor3(Bridge.Int.mul(verticesLength, 3));
                var i = 0;
                var k = vertices.length;
                while (i < k) {
                    var boneCount = Bridge.Int.clip32(vertices[Bridge.identity(i, ((i = (i + 1) | 0)))]);
                    bones.Add(boneCount);
                    for (var nn = (i + (boneCount << 2)) | 0; i < nn; i = (i + 4) | 0) {
                        bones.Add(Bridge.Int.clip32(vertices[i]));
                        weights.Add(vertices[((i + 1) | 0)] * this.Scale);
                        weights.Add(vertices[((i + 2) | 0)] * this.Scale);
                        weights.Add(vertices[((i + 3) | 0)]);
                    }
                }
                attachment.bones = bones.ToArray();
                attachment.vertices = weights.ToArray();
            },
            /*Spine.SkeletonJson.ReadVertices end.*/

            /*Spine.SkeletonJson.FindSlotIndex start.*/
            FindSlotIndex: function (skeletonData, slotName) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#FindSlotIndex", this ); }

                var slots = skeletonData.slots.Items;
                var i = 0;
                for (var j = skeletonData.slots.Count; i < j; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(slots[i].name, slotName)) {
                        return i;
                    }
                }
                throw new System.Exception("Slot not found: " + (slotName || ""));
            },
            /*Spine.SkeletonJson.FindSlotIndex end.*/

            /*Spine.SkeletonJson.ReadAnimation start.*/
            ReadAnimation: function (map, name, skeletonData) {
if ( TRACE ) { TRACE( "Spine.SkeletonJson#ReadAnimation", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16;
                var scale = this.scale;
                var timelines = new (Spine.ExposedList$1(Spine.Timeline)).ctor();
                if (map.containsKey("slots")) {
                    $t = Bridge.getEnumerator(Bridge.cast(map.getItem("slots"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            var slotName = entry.key;
                            var slotIndex2 = this.FindSlotIndex(skeletonData, slotName);
                            var timelineMap3 = Bridge.cast(entry.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t1 = Bridge.getEnumerator(timelineMap3);
                            try {
                                while ($t1.moveNext()) {
                                    var timelineEntry2 = $t1.Current;
                                    var values6 = Bridge.cast(timelineEntry2.value, System.Collections.Generic.List$1(System.Object));
                                    var frames4 = values6.Count;
                                    if (frames4 === 0) {
                                        continue;
                                    }
                                    var timelineName3 = timelineEntry2.key;
                                    switch (timelineName3) {
                                        case "attachment": 
                                            {
                                                var timeline14 = new Spine.AttachmentTimeline(frames4, slotIndex2);
                                                var frame8 = 0;
                                                $t2 = Bridge.getEnumerator(values6);
                                                try {
                                                    while ($t2.moveNext()) {
                                                        var keyMap5 = Bridge.cast($t2.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                        timeline14.SetFrame(Bridge.identity(frame8, ((frame8 = (frame8 + 1) | 0))), Spine.SkeletonJson.GetFloat(keyMap5, "time", 0.0), Spine.SkeletonJson.GetString(keyMap5, "name", null));
                                                    }
                                                } finally {
                                                    if (Bridge.is($t2, System.IDisposable)) {
                                                        $t2.System$IDisposable$Dispose();
                                                    }
                                                }
                                                timelines.Add(timeline14);
                                                break;
                                            }
                                        case "rgba": 
                                            {
                                                var timeline15 = new Spine.RGBATimeline(frames4, frames4 << 2, slotIndex2);
                                                var keyMapEnumerator7 = values6.GetEnumerator();
                                                keyMapEnumerator7.moveNext();
                                                var keyMap7 = Bridge.cast(keyMapEnumerator7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time6 = Spine.SkeletonJson.GetFloat(keyMap7, "time", 0.0);
                                                var color2 = Bridge.cast(keyMap7.getItem("color"), System.String);
                                                var r2 = Spine.SkeletonJson.ToColor(color2, 0);
                                                var g2 = Spine.SkeletonJson.ToColor(color2, 1);
                                                var b2 = Spine.SkeletonJson.ToColor(color2, 2);
                                                var a = Spine.SkeletonJson.ToColor(color2, 3);
                                                var frame10 = 0;
                                                var bezier5 = 0;
                                                while (true) {
                                                    timeline15.SetFrame(frame10, time6, r2, g2, b2, a);
                                                    if (!keyMapEnumerator7.moveNext()) {
                                                        break;
                                                    }
                                                    var nextMap5 = Bridge.cast(keyMapEnumerator7.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var time13 = Spine.SkeletonJson.GetFloat(nextMap5, "time", 0.0);
                                                    color2 = Bridge.cast(nextMap5.getItem("color"), System.String);
                                                    var nr = Spine.SkeletonJson.ToColor(color2, 0);
                                                    var ng = Spine.SkeletonJson.ToColor(color2, 1);
                                                    var nb = Spine.SkeletonJson.ToColor(color2, 2);
                                                    var na = Spine.SkeletonJson.ToColor(color2, 3);
                                                    if (keyMap7.containsKey("curve")) {
                                                        var curve5 = keyMap7.getItem("curve");
                                                        bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline15, bezier5, frame10, 0, time6, time13, r2, nr, 1.0);
                                                        bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline15, bezier5, frame10, 1, time6, time13, g2, ng, 1.0);
                                                        bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline15, bezier5, frame10, 2, time6, time13, b2, nb, 1.0);
                                                        bezier5 = Spine.SkeletonJson.ReadCurve(curve5, timeline15, bezier5, frame10, 3, time6, time13, a, na, 1.0);
                                                    }
                                                    time6 = time13;
                                                    r2 = nr;
                                                    g2 = ng;
                                                    b2 = nb;
                                                    a = na;
                                                    keyMap7 = nextMap5;
                                                    frame10 = (frame10 + 1) | 0;
                                                }
                                                timeline15.Shrink(bezier5);
                                                timelines.Add(timeline15);
                                                break;
                                            }
                                        case "rgb": 
                                            {
                                                var timeline16 = new Spine.RGBTimeline(frames4, Bridge.Int.mul(frames4, 3), slotIndex2);
                                                var keyMapEnumerator8 = values6.GetEnumerator();
                                                keyMapEnumerator8.moveNext();
                                                var keyMap8 = Bridge.cast(keyMapEnumerator8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time7 = Spine.SkeletonJson.GetFloat(keyMap8, "time", 0.0);
                                                var color3 = Bridge.cast(keyMap8.getItem("color"), System.String);
                                                var r3 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                                var g3 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                                var b3 = Spine.SkeletonJson.ToColor(color3, 2, 6);
                                                var frame11 = 0;
                                                var bezier7 = 0;
                                                while (true) {
                                                    timeline16.SetFrame(frame11, time7, r3, g3, b3);
                                                    if (!keyMapEnumerator8.moveNext()) {
                                                        break;
                                                    }
                                                    var nextMap7 = Bridge.cast(keyMapEnumerator8.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var time15 = Spine.SkeletonJson.GetFloat(nextMap7, "time", 0.0);
                                                    color3 = Bridge.cast(nextMap7.getItem("color"), System.String);
                                                    var nr3 = Spine.SkeletonJson.ToColor(color3, 0, 6);
                                                    var ng3 = Spine.SkeletonJson.ToColor(color3, 1, 6);
                                                    var nb2 = Spine.SkeletonJson.ToColor(color3, 2, 6);
                                                    if (keyMap8.containsKey("curve")) {
                                                        var curve6 = keyMap8.getItem("curve");
                                                        bezier7 = Spine.SkeletonJson.ReadCurve(curve6, timeline16, bezier7, frame11, 0, time7, time15, r3, nr3, 1.0);
                                                        bezier7 = Spine.SkeletonJson.ReadCurve(curve6, timeline16, bezier7, frame11, 1, time7, time15, g3, ng3, 1.0);
                                                        bezier7 = Spine.SkeletonJson.ReadCurve(curve6, timeline16, bezier7, frame11, 2, time7, time15, b3, nb2, 1.0);
                                                    }
                                                    time7 = time15;
                                                    r3 = nr3;
                                                    g3 = ng3;
                                                    b3 = nb2;
                                                    keyMap8 = nextMap7;
                                                    frame11 = (frame11 + 1) | 0;
                                                }
                                                timeline16.Shrink(bezier7);
                                                timelines.Add(timeline16);
                                                break;
                                            }
                                        case "alpha": 
                                            {
                                                var keyMapEnumerator9 = { v : values6.GetEnumerator() };
                                                keyMapEnumerator9.v.moveNext();
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator9, new Spine.AlphaTimeline(frames4, frames4, slotIndex2), 0.0, 1.0));
                                                break;
                                            }
                                        case "rgba2": 
                                            {
                                                var timeline17 = new Spine.RGBA2Timeline(frames4, Bridge.Int.mul(frames4, 7), slotIndex2);
                                                var keyMapEnumerator10 = values6.GetEnumerator();
                                                keyMapEnumerator10.moveNext();
                                                var keyMap9 = Bridge.cast(keyMapEnumerator10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time8 = Spine.SkeletonJson.GetFloat(keyMap9, "time", 0.0);
                                                var color4 = Bridge.cast(keyMap9.getItem("light"), System.String);
                                                var r4 = Spine.SkeletonJson.ToColor(color4, 0);
                                                var g4 = Spine.SkeletonJson.ToColor(color4, 1);
                                                var b4 = Spine.SkeletonJson.ToColor(color4, 2);
                                                var a2 = Spine.SkeletonJson.ToColor(color4, 3);
                                                color4 = Bridge.cast(keyMap9.getItem("dark"), System.String);
                                                var r6 = Spine.SkeletonJson.ToColor(color4, 0, 6);
                                                var g6 = Spine.SkeletonJson.ToColor(color4, 1, 6);
                                                var b6 = Spine.SkeletonJson.ToColor(color4, 2, 6);
                                                var frame12 = 0;
                                                var bezier8 = 0;
                                                while (true) {
                                                    timeline17.SetFrame(frame12, time8, r4, g4, b4, a2, r6, g6, b6);
                                                    if (!keyMapEnumerator10.moveNext()) {
                                                        break;
                                                    }
                                                    var nextMap8 = Bridge.cast(keyMapEnumerator10.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var time16 = Spine.SkeletonJson.GetFloat(nextMap8, "time", 0.0);
                                                    color4 = Bridge.cast(nextMap8.getItem("light"), System.String);
                                                    var nr4 = Spine.SkeletonJson.ToColor(color4, 0);
                                                    var ng4 = Spine.SkeletonJson.ToColor(color4, 1);
                                                    var nb4 = Spine.SkeletonJson.ToColor(color4, 2);
                                                    var na2 = Spine.SkeletonJson.ToColor(color4, 3);
                                                    color4 = Bridge.cast(nextMap8.getItem("dark"), System.String);
                                                    var nr5 = Spine.SkeletonJson.ToColor(color4, 0, 6);
                                                    var ng5 = Spine.SkeletonJson.ToColor(color4, 1, 6);
                                                    var nb5 = Spine.SkeletonJson.ToColor(color4, 2, 6);
                                                    if (keyMap9.containsKey("curve")) {
                                                        var curve7 = keyMap9.getItem("curve");
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 0, time8, time16, r4, nr4, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 1, time8, time16, g4, ng4, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 2, time8, time16, b4, nb4, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 3, time8, time16, a2, na2, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 4, time8, time16, r6, nr5, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 5, time8, time16, g6, ng5, 1.0);
                                                        bezier8 = Spine.SkeletonJson.ReadCurve(curve7, timeline17, bezier8, frame12, 6, time8, time16, b6, nb5, 1.0);
                                                    }
                                                    time8 = time16;
                                                    r4 = nr4;
                                                    g4 = ng4;
                                                    b4 = nb4;
                                                    a2 = na2;
                                                    r6 = nr5;
                                                    g6 = ng5;
                                                    b6 = nb5;
                                                    keyMap9 = nextMap8;
                                                    frame12 = (frame12 + 1) | 0;
                                                }
                                                timeline17.Shrink(bezier8);
                                                timelines.Add(timeline17);
                                                break;
                                            }
                                        case "rgb2": 
                                            {
                                                var timeline13 = new Spine.RGB2Timeline(frames4, Bridge.Int.mul(frames4, 6), slotIndex2);
                                                var keyMapEnumerator6 = values6.GetEnumerator();
                                                keyMapEnumerator6.moveNext();
                                                var keyMap6 = Bridge.cast(keyMapEnumerator6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time5 = Spine.SkeletonJson.GetFloat(keyMap6, "time", 0.0);
                                                var color = Bridge.cast(keyMap6.getItem("light"), System.String);
                                                var r = Spine.SkeletonJson.ToColor(color, 0, 6);
                                                var g = Spine.SkeletonJson.ToColor(color, 1, 6);
                                                var b = Spine.SkeletonJson.ToColor(color, 2, 6);
                                                color = Bridge.cast(keyMap6.getItem("dark"), System.String);
                                                var r5 = Spine.SkeletonJson.ToColor(color, 0, 6);
                                                var g5 = Spine.SkeletonJson.ToColor(color, 1, 6);
                                                var b5 = Spine.SkeletonJson.ToColor(color, 2, 6);
                                                var frame9 = 0;
                                                var bezier6 = 0;
                                                while (true) {
                                                    timeline13.SetFrame(frame9, time5, r, g, b, r5, g5, b5);
                                                    if (!keyMapEnumerator6.moveNext()) {
                                                        break;
                                                    }
                                                    var nextMap6 = Bridge.cast(keyMapEnumerator6.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var time14 = Spine.SkeletonJson.GetFloat(nextMap6, "time", 0.0);
                                                    color = Bridge.cast(nextMap6.getItem("light"), System.String);
                                                    var nr2 = Spine.SkeletonJson.ToColor(color, 0, 6);
                                                    var ng2 = Spine.SkeletonJson.ToColor(color, 1, 6);
                                                    var nb3 = Spine.SkeletonJson.ToColor(color, 2, 6);
                                                    color = Bridge.cast(nextMap6.getItem("dark"), System.String);
                                                    var nr6 = Spine.SkeletonJson.ToColor(color, 0, 6);
                                                    var ng6 = Spine.SkeletonJson.ToColor(color, 1, 6);
                                                    var nb6 = Spine.SkeletonJson.ToColor(color, 2, 6);
                                                    if (keyMap6.containsKey("curve")) {
                                                        var curve8 = keyMap6.getItem("curve");
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 0, time5, time14, r, nr2, 1.0);
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 1, time5, time14, g, ng2, 1.0);
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 2, time5, time14, b, nb3, 1.0);
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 3, time5, time14, r5, nr6, 1.0);
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 4, time5, time14, g5, ng6, 1.0);
                                                        bezier6 = Spine.SkeletonJson.ReadCurve(curve8, timeline13, bezier6, frame9, 5, time5, time14, b5, nb6, 1.0);
                                                    }
                                                    time5 = time14;
                                                    r = nr2;
                                                    g = ng2;
                                                    b = nb3;
                                                    r5 = nr6;
                                                    g5 = ng6;
                                                    b5 = nb6;
                                                    keyMap6 = nextMap6;
                                                    frame9 = (frame9 + 1) | 0;
                                                }
                                                timeline13.Shrink(bezier6);
                                                timelines.Add(timeline13);
                                                break;
                                            }
                                        default: 
                                            throw new System.Exception("Invalid timeline type for a slot: " + (timelineName3 || "") + " (" + (slotName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("bones")) {
                    $t3 = Bridge.getEnumerator(Bridge.cast(map.getItem("bones"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t3.moveNext()) {
                            var entry2 = $t3.Current;
                            var boneName = entry2.key;
                            var boneIndex = -1;
                            var bones = skeletonData.bones.Items;
                            var n = 0;
                            for (var n4 = skeletonData.bones.Count; n < n4; n = (n + 1) | 0) {
                                if (Bridge.referenceEquals(bones[n].name, boneName)) {
                                    boneIndex = n;
                                    break;
                                }
                            }
                            if (boneIndex === -1) {
                                throw new System.Exception("Bone not found: " + (boneName || ""));
                            }
                            var timelineMap6 = Bridge.cast(entry2.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t4 = Bridge.getEnumerator(timelineMap6);
                            try {
                                while ($t4.moveNext()) {
                                    var timelineEntry3 = $t4.Current;
                                    var values7 = Bridge.cast(timelineEntry3.value, System.Collections.Generic.List$1(System.Object));
                                    var keyMapEnumerator5 = { v : values7.GetEnumerator() };
                                    if (keyMapEnumerator5.v.moveNext()) {
                                        var frames3 = values7.Count;
                                        var timelineName2 = timelineEntry3.key;
                                        switch (timelineName2) {
                                            case "rotate": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.RotateTimeline(frames3, frames3, boneIndex), 0.0, 1.0));
                                                continue;
                                            case "translate": 
                                                {
                                                    var timeline10 = new Spine.TranslateTimeline(frames3, frames3 << 1, boneIndex);
                                                    timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline10, "x", "y", 0.0, scale));
                                                    continue;
                                                }
                                            case "translatex": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.TranslateXTimeline(frames3, frames3, boneIndex), 0.0, scale));
                                                continue;
                                            case "translatey": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.TranslateYTimeline(frames3, frames3, boneIndex), 0.0, scale));
                                                continue;
                                            case "scale": 
                                                {
                                                    var timeline11 = new Spine.ScaleTimeline(frames3, frames3 << 1, boneIndex);
                                                    timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline11, "x", "y", 1.0, 1.0));
                                                    continue;
                                                }
                                            case "scalex": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ScaleXTimeline(frames3, frames3, boneIndex), 1.0, 1.0));
                                                continue;
                                            case "scaley": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ScaleYTimeline(frames3, frames3, boneIndex), 1.0, 1.0));
                                                continue;
                                            case "shear": 
                                                {
                                                    var timeline12 = new Spine.ShearTimeline(frames3, frames3 << 1, boneIndex);
                                                    timelines.Add(Spine.SkeletonJson.ReadTimeline$1(keyMapEnumerator5, timeline12, "x", "y", 0.0, 1.0));
                                                    continue;
                                                }
                                            case "shearx": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ShearXTimeline(frames3, frames3, boneIndex), 0.0, 1.0));
                                                continue;
                                            case "sheary": 
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator5, new Spine.ShearYTimeline(frames3, frames3, boneIndex), 0.0, 1.0));
                                                continue;
                                        }
                                        throw new System.Exception("Invalid timeline type for a bone: " + (timelineName2 || "") + " (" + (boneName || "") + ")");
                                    }
                                }
                            } finally {
                                if (Bridge.is($t4, System.IDisposable)) {
                                    $t4.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("ik")) {
                    $t5 = Bridge.getEnumerator(Bridge.cast(map.getItem("ik"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t5.moveNext()) {
                            var timelineMap5 = $t5.Current;
                            var values5 = Bridge.cast(timelineMap5.value, System.Collections.Generic.List$1(System.Object));
                            var keyMapEnumerator4 = values5.GetEnumerator();
                            if (!keyMapEnumerator4.moveNext()) {
                                continue;
                            }
                            var keyMap4 = Bridge.cast(keyMapEnumerator4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var constraint3 = skeletonData.FindIkConstraint(timelineMap5.key);
                            var timeline9 = new Spine.IkConstraintTimeline(values5.Count, values5.Count << 1, skeletonData.IkConstraints.IndexOf(constraint3));
                            var time4 = Spine.SkeletonJson.GetFloat(keyMap4, "time", 0.0);
                            var mix = Spine.SkeletonJson.GetFloat(keyMap4, "mix", 1.0);
                            var softness = Spine.SkeletonJson.GetFloat(keyMap4, "softness", 0.0) * scale;
                            var frame7 = 0;
                            var bezier4 = 0;
                            while (true) {
                                timeline9.SetFrame(frame7, time4, mix, softness, Spine.SkeletonJson.GetBoolean(keyMap4, "bendPositive", true) ? 1 : (-1), Spine.SkeletonJson.GetBoolean(keyMap4, "compress", false), Spine.SkeletonJson.GetBoolean(keyMap4, "stretch", false));
                                if (!keyMapEnumerator4.moveNext()) {
                                    break;
                                }
                                var nextMap4 = Bridge.cast(keyMapEnumerator4.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                var time12 = Spine.SkeletonJson.GetFloat(nextMap4, "time", 0.0);
                                var mix2 = Spine.SkeletonJson.GetFloat(nextMap4, "mix", 1.0);
                                var softness2 = Spine.SkeletonJson.GetFloat(nextMap4, "softness", 0.0) * scale;
                                if (keyMap4.containsKey("curve")) {
                                    var curve4 = keyMap4.getItem("curve");
                                    bezier4 = Spine.SkeletonJson.ReadCurve(curve4, timeline9, bezier4, frame7, 0, time4, time12, mix, mix2, 1.0);
                                    bezier4 = Spine.SkeletonJson.ReadCurve(curve4, timeline9, bezier4, frame7, 1, time4, time12, softness, softness2, scale);
                                }
                                time4 = time12;
                                mix = mix2;
                                softness = softness2;
                                keyMap4 = nextMap4;
                                frame7 = (frame7 + 1) | 0;
                            }
                            timeline9.Shrink(bezier4);
                            timelines.Add(timeline9);
                        }
                    } finally {
                        if (Bridge.is($t5, System.IDisposable)) {
                            $t5.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("transform")) {
                    $t6 = Bridge.getEnumerator(Bridge.cast(map.getItem("transform"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t6.moveNext()) {
                            var timelineMap4 = $t6.Current;
                            var values4 = Bridge.cast(timelineMap4.value, System.Collections.Generic.List$1(System.Object));
                            var keyMapEnumerator3 = values4.GetEnumerator();
                            if (!keyMapEnumerator3.moveNext()) {
                                continue;
                            }
                            var keyMap3 = Bridge.cast(keyMapEnumerator3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var constraint2 = skeletonData.FindTransformConstraint(timelineMap4.key);
                            var timeline8 = new Spine.TransformConstraintTimeline(values4.Count, Bridge.Int.mul(values4.Count, 6), skeletonData.TransformConstraints.IndexOf(constraint2));
                            var time3 = Spine.SkeletonJson.GetFloat(keyMap3, "time", 0.0);
                            var mixRotate2 = Spine.SkeletonJson.GetFloat(keyMap3, "mixRotate", 1.0);
                            var mixShearY = Spine.SkeletonJson.GetFloat(keyMap3, "mixShearY", 1.0);
                            var mixX2 = Spine.SkeletonJson.GetFloat(keyMap3, "mixX", 1.0);
                            var mixY2 = Spine.SkeletonJson.GetFloat(keyMap3, "mixY", mixX2);
                            var mixScaleX = Spine.SkeletonJson.GetFloat(keyMap3, "mixScaleX", 1.0);
                            var mixScaleY = Spine.SkeletonJson.GetFloat(keyMap3, "mixScaleY", mixScaleX);
                            var frame6 = 0;
                            var bezier3 = 0;
                            while (true) {
                                timeline8.SetFrame(frame6, time3, mixRotate2, mixX2, mixY2, mixScaleX, mixScaleY, mixShearY);
                                if (!keyMapEnumerator3.moveNext()) {
                                    break;
                                }
                                var nextMap3 = Bridge.cast(keyMapEnumerator3.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                var time11 = Spine.SkeletonJson.GetFloat(nextMap3, "time", 0.0);
                                var mixRotate4 = Spine.SkeletonJson.GetFloat(nextMap3, "mixRotate", 1.0);
                                var mixShearY2 = Spine.SkeletonJson.GetFloat(nextMap3, "mixShearY", 1.0);
                                var mixX4 = Spine.SkeletonJson.GetFloat(nextMap3, "mixX", 1.0);
                                var mixY4 = Spine.SkeletonJson.GetFloat(nextMap3, "mixY", mixX4);
                                var mixScaleX2 = Spine.SkeletonJson.GetFloat(nextMap3, "mixScaleX", 1.0);
                                var mixScaleY2 = Spine.SkeletonJson.GetFloat(nextMap3, "mixScaleY", mixScaleX2);
                                if (keyMap3.containsKey("curve")) {
                                    var curve3 = keyMap3.getItem("curve");
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 0, time3, time11, mixRotate2, mixRotate4, 1.0);
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 1, time3, time11, mixX2, mixX4, 1.0);
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 2, time3, time11, mixY2, mixY4, 1.0);
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 3, time3, time11, mixScaleX, mixScaleX2, 1.0);
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 4, time3, time11, mixScaleY, mixScaleY2, 1.0);
                                    bezier3 = Spine.SkeletonJson.ReadCurve(curve3, timeline8, bezier3, frame6, 5, time3, time11, mixShearY, mixShearY2, 1.0);
                                }
                                time3 = time11;
                                mixRotate2 = mixRotate4;
                                mixX2 = mixX4;
                                mixY2 = mixY4;
                                mixScaleX = mixScaleX2;
                                mixScaleY = mixScaleY2;
                                mixShearY = mixShearY2;
                                keyMap3 = nextMap3;
                                frame6 = (frame6 + 1) | 0;
                            }
                            timeline8.Shrink(bezier3);
                            timelines.Add(timeline8);
                        }
                    } finally {
                        if (Bridge.is($t6, System.IDisposable)) {
                            $t6.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("path")) {
                    $t7 = Bridge.getEnumerator(Bridge.cast(map.getItem("path"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t7.moveNext()) {
                            var constraintMap = $t7.Current;
                            var constraint = skeletonData.FindPathConstraint(constraintMap.key);
                            if (constraint == null) {
                                throw new System.Exception("Path constraint not found: " + (constraintMap.key || ""));
                            }
                            var constraintIndex = skeletonData.pathConstraints.IndexOf(constraint);
                            var timelineMap2 = Bridge.cast(constraintMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            $t8 = Bridge.getEnumerator(timelineMap2);
                            try {
                                while ($t8.moveNext()) {
                                    var timelineEntry = $t8.Current;
                                    var values3 = Bridge.cast(timelineEntry.value, System.Collections.Generic.List$1(System.Object));
                                    var keyMapEnumerator2 = { v : values3.GetEnumerator() };
                                    if (!keyMapEnumerator2.v.moveNext()) {
                                        continue;
                                    }
                                    var frames2 = values3.Count;
                                    switch (timelineEntry.key) {
                                        case "position": 
                                            {
                                                var timeline5 = new Spine.PathConstraintPositionTimeline(frames2, frames2, constraintIndex);
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator2, timeline5, 0.0, (constraint.positionMode === Spine.PositionMode.Fixed) ? scale : 1.0));
                                                break;
                                            }
                                        case "spacing": 
                                            {
                                                var timeline6 = new Spine.PathConstraintSpacingTimeline(frames2, frames2, constraintIndex);
                                                timelines.Add(Spine.SkeletonJson.ReadTimeline(keyMapEnumerator2, timeline6, 0.0, (constraint.spacingMode === Spine.SpacingMode.Length || constraint.spacingMode === Spine.SpacingMode.Fixed) ? scale : 1.0));
                                                break;
                                            }
                                        case "mix": 
                                            {
                                                var timeline7 = new Spine.PathConstraintMixTimeline(frames2, Bridge.Int.mul(frames2, 3), constraintIndex);
                                                var keyMap2 = Bridge.cast(keyMapEnumerator2.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                var time2 = Spine.SkeletonJson.GetFloat(keyMap2, "time", 0.0);
                                                var mixRotate = Spine.SkeletonJson.GetFloat(keyMap2, "mixRotate", 1.0);
                                                var mixX = Spine.SkeletonJson.GetFloat(keyMap2, "mixX", 1.0);
                                                var mixY = Spine.SkeletonJson.GetFloat(keyMap2, "mixY", mixX);
                                                var frame5 = 0;
                                                var bezier2 = 0;
                                                while (true) {
                                                    timeline7.SetFrame(frame5, time2, mixRotate, mixX, mixY);
                                                    if (!keyMapEnumerator2.v.moveNext()) {
                                                        break;
                                                    }
                                                    var nextMap2 = Bridge.cast(keyMapEnumerator2.v.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var time10 = Spine.SkeletonJson.GetFloat(nextMap2, "time", 0.0);
                                                    var mixRotate3 = Spine.SkeletonJson.GetFloat(nextMap2, "mixRotate", 1.0);
                                                    var mixX3 = Spine.SkeletonJson.GetFloat(nextMap2, "mixX", 1.0);
                                                    var mixY3 = Spine.SkeletonJson.GetFloat(nextMap2, "mixY", mixX3);
                                                    if (keyMap2.containsKey("curve")) {
                                                        var curve2 = keyMap2.getItem("curve");
                                                        bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline7, bezier2, frame5, 0, time2, time10, mixRotate, mixRotate3, 1.0);
                                                        bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline7, bezier2, frame5, 1, time2, time10, mixX, mixX3, 1.0);
                                                        bezier2 = Spine.SkeletonJson.ReadCurve(curve2, timeline7, bezier2, frame5, 2, time2, time10, mixY, mixY3, 1.0);
                                                    }
                                                    time2 = time10;
                                                    mixRotate = mixRotate3;
                                                    mixX = mixX3;
                                                    mixY = mixY3;
                                                    keyMap2 = nextMap2;
                                                    frame5 = (frame5 + 1) | 0;
                                                }
                                                timeline7.Shrink(bezier2);
                                                timelines.Add(timeline7);
                                                break;
                                            }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t8, System.IDisposable)) {
                                    $t8.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t7, System.IDisposable)) {
                            $t7.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("attachments")) {
                    $t9 = Bridge.getEnumerator(Bridge.cast(map.getItem("attachments"), System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                    try {
                        while ($t9.moveNext()) {
                            var attachmentsMap = $t9.Current;
                            var skin = skeletonData.FindSkin(attachmentsMap.key);
                            $t10 = Bridge.getEnumerator(Bridge.cast(attachmentsMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                            try {
                                while ($t10.moveNext()) {
                                    var slotMap = $t10.Current;
                                    var slot = skeletonData.FindSlot(slotMap.key);
                                    if (slot == null) {
                                        throw new System.Exception("Slot not found: " + (slotMap.key || ""));
                                    }
                                    $t11 = Bridge.getEnumerator(Bridge.cast(slotMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                    try {
                                        while ($t11.moveNext()) {
                                            var attachmentMap = $t11.Current;
                                            var attachment = skin.GetAttachment(slot.index, attachmentMap.key);
                                            if (attachment == null) {
                                                throw new System.Exception("Timeline attachment not found: " + (attachmentMap.key || ""));
                                            }
                                            $t12 = Bridge.getEnumerator(Bridge.cast(attachmentMap.value, System.Collections.Generic.Dictionary$2(System.String,System.Object)));
                                            try {
                                                while ($t12.moveNext()) {
                                                    var timelineMap = $t12.Current;
                                                    var values2 = Bridge.cast(timelineMap.value, System.Collections.Generic.List$1(System.Object));
                                                    var keyMapEnumerator = values2.GetEnumerator();
                                                    if (!keyMapEnumerator.moveNext()) {
                                                        continue;
                                                    }
                                                    var keyMap = Bridge.cast(keyMapEnumerator.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                    var frames = values2.Count;
                                                    var timelineName = timelineMap.key;
                                                    if (Bridge.referenceEquals(timelineName, "deform")) {
                                                        var vertexAttachment = Bridge.cast(attachment, Spine.VertexAttachment);
                                                        var weighted = vertexAttachment.bones != null;
                                                        var vertices = vertexAttachment.vertices;
                                                        var deformLength = (weighted ? (((Bridge.Int.div(vertices.length, 3)) | 0) << 1) : vertices.length);
                                                        var timeline4 = new Spine.DeformTimeline(frames, frames, slot.Index, vertexAttachment);
                                                        var time = Spine.SkeletonJson.GetFloat(keyMap, "time", 0.0);
                                                        var frame4 = 0;
                                                        var bezier = 0;
                                                        while (true) {
                                                            var deform;
                                                            if (!keyMap.containsKey("vertices")) {
                                                                deform = (weighted ? System.Array.init(deformLength, 0, System.Single) : vertices);
                                                            } else {
                                                                deform = System.Array.init(deformLength, 0, System.Single);
                                                                var start = Spine.SkeletonJson.GetInt$1(keyMap, "offset", 0);
                                                                var verticesValue = Spine.SkeletonJson.GetFloatArray(keyMap, "vertices", 1.0);
                                                                System.Array.copy(verticesValue, 0, deform, start, verticesValue.length);
                                                                if (scale !== 1.0) {
                                                                    var m = start;
                                                                    for (var n3 = (m + verticesValue.length) | 0; m < n3; m = (m + 1) | 0) {
                                                                        deform[m] *= scale;
                                                                    }
                                                                }
                                                                if (!weighted) {
                                                                    for (var l = 0; l < deformLength; l = (l + 1) | 0) {
                                                                        deform[l] += vertices[l];
                                                                    }
                                                                }
                                                            }
                                                            timeline4.SetFrame(frame4, time, deform);
                                                            if (!keyMapEnumerator.moveNext()) {
                                                                break;
                                                            }
                                                            var nextMap = Bridge.cast(keyMapEnumerator.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                                            var time9 = Spine.SkeletonJson.GetFloat(nextMap, "time", 0.0);
                                                            if (keyMap.containsKey("curve")) {
                                                                var curve = keyMap.getItem("curve");
                                                                bezier = Spine.SkeletonJson.ReadCurve(curve, timeline4, bezier, frame4, 0, time, time9, 0.0, 1.0, 1.0);
                                                            }
                                                            time = time9;
                                                            keyMap = nextMap;
                                                            frame4 = (frame4 + 1) | 0;
                                                        }
                                                        timeline4.Shrink(bezier);
                                                        timelines.Add(timeline4);
                                                    } else if (Bridge.referenceEquals(timelineName, "sequence")) {
                                                        var timeline3 = new Spine.SequenceTimeline(frames, slot.index, attachment);
                                                        var lastDelay = 0.0;
                                                        var frame3 = 0;
                                                        while (keyMap != null) {
                                                            var delay = Spine.SkeletonJson.GetFloat(keyMap, "delay", lastDelay);
                                                            var sequenceMode = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.SequenceMode, Spine.SkeletonJson.GetString(keyMap, "mode", "hold"), true), Spine.SequenceMode), System.Int32));
                                                            timeline3.SetFrame(frame3, Spine.SkeletonJson.GetFloat(keyMap, "time", 0.0), sequenceMode, Spine.SkeletonJson.GetInt$1(keyMap, "index", 0), delay);
                                                            lastDelay = delay;
                                                            keyMap = (keyMapEnumerator.moveNext() ? Bridge.cast(keyMapEnumerator.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object)) : null);
                                                            frame3 = (frame3 + 1) | 0;
                                                        }
                                                        timelines.Add(timeline3);
                                                    }
                                                }
                                            } finally {
                                                if (Bridge.is($t12, System.IDisposable)) {
                                                    $t12.System$IDisposable$Dispose();
                                                }
                                            }
                                        }
                                    } finally {
                                        if (Bridge.is($t11, System.IDisposable)) {
                                            $t11.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t10, System.IDisposable)) {
                                    $t10.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t9, System.IDisposable)) {
                            $t9.System$IDisposable$Dispose();
                        }
                    }
                }
                if (map.containsKey("drawOrder")) {
                    var values = Bridge.cast(map.getItem("drawOrder"), System.Collections.Generic.List$1(System.Object));
                    var timeline2 = new Spine.DrawOrderTimeline(values.Count);
                    var slotCount = skeletonData.slots.Count;
                    var frame2 = 0;
                    $t13 = Bridge.getEnumerator(values);
                    try {
                        while ($t13.moveNext()) {
                            var drawOrderMap = Bridge.cast($t13.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var drawOrder = null;
                            if (drawOrderMap.containsKey("offsets")) {
                                drawOrder = System.Array.init(slotCount, 0, System.Int32);
                                for (var k = (slotCount - 1) | 0; k >= 0; k = (k - 1) | 0) {
                                    drawOrder[k] = -1;
                                }
                                var offsets = Bridge.cast(drawOrderMap.getItem("offsets"), System.Collections.Generic.List$1(System.Object));
                                var unchanged = System.Array.init(((slotCount - offsets.Count) | 0), 0, System.Int32);
                                var originalIndex = 0;
                                var unchangedIndex = 0;
                                $t14 = Bridge.getEnumerator(offsets);
                                try {
                                    while ($t14.moveNext()) {
                                        var offsetMap = Bridge.cast($t14.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                                        var slotIndex = this.FindSlotIndex(skeletonData, Bridge.cast(offsetMap.getItem("slot"), System.String));
                                        while (originalIndex !== slotIndex) {
                                            unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                        }
                                        var index = (originalIndex + Bridge.Int.clip32(System.Nullable.getValue(Bridge.cast(Bridge.unbox(offsetMap.getItem("offset"), System.Single), System.Single)))) | 0;
                                        drawOrder[index] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                    }
                                } finally {
                                    if (Bridge.is($t14, System.IDisposable)) {
                                        $t14.System$IDisposable$Dispose();
                                    }
                                }
                                while (originalIndex < slotCount) {
                                    unchanged[Bridge.identity(unchangedIndex, ((unchangedIndex = (unchangedIndex + 1) | 0)))] = Bridge.identity(originalIndex, ((originalIndex = (originalIndex + 1) | 0)));
                                }
                                for (var j = (slotCount - 1) | 0; j >= 0; j = (j - 1) | 0) {
                                    if (drawOrder[j] === -1) {
                                        drawOrder[j] = unchanged[((unchangedIndex = (unchangedIndex - 1) | 0))];
                                    }
                                }
                            }
                            timeline2.SetFrame(frame2, Spine.SkeletonJson.GetFloat(drawOrderMap, "time", 0.0), drawOrder);
                            frame2 = (frame2 + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t13, System.IDisposable)) {
                            $t13.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline2);
                }
                if (map.containsKey("events")) {
                    var eventsMap = Bridge.cast(map.getItem("events"), System.Collections.Generic.List$1(System.Object));
                    var timeline = new Spine.EventTimeline(eventsMap.Count);
                    var frame = 0;
                    $t15 = Bridge.getEnumerator(eventsMap);
                    try {
                        while ($t15.moveNext()) {
                            var eventMap = Bridge.cast($t15.Current, System.Collections.Generic.Dictionary$2(System.String,System.Object));
                            var eventData = skeletonData.FindEvent(Bridge.cast(eventMap.getItem("name"), System.String));
                            if (eventData == null) {
                                throw new System.Exception(System.String.concat("Event not found: ", eventMap.getItem("name")));
                            }
                            var e = ($t16 = new Spine.Event(Spine.SkeletonJson.GetFloat(eventMap, "time", 0.0), eventData), $t16.intValue = Spine.SkeletonJson.GetInt$1(eventMap, "int", eventData.Int), $t16.floatValue = Spine.SkeletonJson.GetFloat(eventMap, "float", eventData.Float), $t16.stringValue = Spine.SkeletonJson.GetString(eventMap, "string", eventData.String), $t16);
                            if (e.data.AudioPath != null) {
                                e.volume = Spine.SkeletonJson.GetFloat(eventMap, "volume", eventData.Volume);
                                e.balance = Spine.SkeletonJson.GetFloat(eventMap, "balance", eventData.Balance);
                            }
                            timeline.SetFrame(frame, e);
                            frame = (frame + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t15, System.IDisposable)) {
                            $t15.System$IDisposable$Dispose();
                        }
                    }
                    timelines.Add(timeline);
                }
                timelines.TrimExcess();
                var duration = 0.0;
                var items = timelines.Items;
                var i = 0;
                for (var n2 = timelines.Count; i < n2; i = (i + 1) | 0) {
                    duration = Math.max(duration, items[i].Duration);
                }
                skeletonData.animations.Add(new Spine.Animation(name, timelines, duration));
            },
            /*Spine.SkeletonJson.ReadAnimation end.*/


        },
        overloads: {
            "ReadSkeletonData(TextReader)": "ReadSkeletonData$1"
        }
    });
    /*Spine.SkeletonJson end.*/

    /*Spine.Skin+SkinKeyComparer start.*/
    Bridge.define("Spine.Skin.SkinKeyComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(Spine.Skin.SkinKey)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#init", this ); }

                    this.Instance = new Spine.Skin.SkinKeyComparer();
                }
            }
        },
        alias: [
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2",
            "System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"
        ],
        methods: {
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2: function (e1, e2) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2", this ); }

                return e1.slotIndex === e2.slotIndex && System.String.equals(e1.name, e2.name, 4);
            },
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$equals2 end.*/

            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2 start.*/
            System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2: function (e) {
if ( TRACE ) { TRACE( "Spine.Skin.SkinKeyComparer#System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2", this ); }

                return e.hashCode;
            },
            /*Spine.Skin+SkinKeyComparer.System$Collections$Generic$IEqualityComparer$1$Spine$Skin$SkinKey$getHashCode2 end.*/


        }
    });
    /*Spine.Skin+SkinKeyComparer end.*/

    /*Spine.TrackEntry start.*/
    Bridge.define("Spine.TrackEntry", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#inherits", this ); }
 return [Spine.Pool$1.IPoolable(Spine.TrackEntry)]; },
        fields: {
            animation: null,
            previous: null,
            next: null,
            mixingFrom: null,
            mixingTo: null,
            trackIndex: 0,
            loop: false,
            holdPrevious: false,
            reverse: false,
            shortestRotation: false,
            eventThreshold: 0,
            attachmentThreshold: 0,
            drawOrderThreshold: 0,
            animationStart: 0,
            animationEnd: 0,
            animationLast: 0,
            nextAnimationLast: 0,
            delay: 0,
            trackTime: 0,
            trackLast: 0,
            nextTrackLast: 0,
            trackEnd: 0,
            timeScale: 0,
            alpha: 0,
            mixTime: 0,
            mixDuration: 0,
            interruptAlpha: 0,
            totalAlpha: 0,
            mixBlend: 0,
            timelineMode: null,
            timelineHoldMix: null,
            timelinesRotation: null
        },
        events: {
            Start: null,
            Interrupt: null,
            End: null,
            Dispose: null,
            Complete: null,
            Event: null
        },
        props: {
            TrackIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackIndex#get", this ); }

                    return this.trackIndex;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Animation#get", this ); }

                    return this.animation;
                }
            },
            Loop: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#get", this ); }

                    return this.loop;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Loop#set", this ); }

                    this.loop = value;
                }
            },
            Delay: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#get", this ); }

                    return this.delay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Delay#set", this ); }

                    this.delay = value;
                }
            },
            TrackTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#get", this ); }

                    return this.trackTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackTime#set", this ); }

                    this.trackTime = value;
                }
            },
            TrackEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#get", this ); }

                    return this.trackEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackEnd#set", this ); }

                    this.trackEnd = value;
                }
            },
            TrackComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TrackComplete#get", this ); }

                    var duration = this.animationEnd - this.animationStart;
                    if (duration !== 0.0) {
                        if (this.loop) {
                            return duration * (((1 + Bridge.Int.clip32((this.trackTime / duration))) | 0));
                        }
                        if (this.trackTime < duration) {
                            return duration;
                        }
                    }
                    return this.trackTime;
                }
            },
            AnimationStart: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#get", this ); }

                    return this.animationStart;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationStart#set", this ); }

                    this.animationStart = value;
                }
            },
            AnimationEnd: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#get", this ); }

                    return this.animationEnd;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationEnd#set", this ); }

                    this.animationEnd = value;
                }
            },
            AnimationLast: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#get", this ); }

                    return this.animationLast;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationLast#set", this ); }

                    this.animationLast = value;
                    this.nextAnimationLast = value;
                }
            },
            AnimationTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AnimationTime#get", this ); }

                    if (this.loop) {
                        var duration = this.animationEnd - this.animationStart;
                        if (duration === 0.0) {
                            return this.animationStart;
                        }
                        return this.trackTime % duration + this.animationStart;
                    }
                    var animationTime = this.trackTime + this.animationStart;
                    return (this.animationEnd >= this.animation.duration) ? animationTime : Math.min(animationTime, this.animationEnd);
                }
            },
            TimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#get", this ); }

                    return this.timeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#TimeScale#set", this ); }

                    this.timeScale = value;
                }
            },
            Alpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#get", this ); }

                    return this.alpha;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Alpha#set", this ); }

                    this.alpha = value;
                }
            },
            InterruptAlpha: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#InterruptAlpha#get", this ); }

                    return this.interruptAlpha;
                }
            },
            EventThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#get", this ); }

                    return this.eventThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#EventThreshold#set", this ); }

                    this.eventThreshold = value;
                }
            },
            AttachmentThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#get", this ); }

                    return this.attachmentThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AttachmentThreshold#set", this ); }

                    this.attachmentThreshold = value;
                }
            },
            DrawOrderThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#get", this ); }

                    return this.drawOrderThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#DrawOrderThreshold#set", this ); }

                    this.drawOrderThreshold = value;
                }
            },
            Next: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Next#get", this ); }

                    return this.next;
                }
            },
            Previous: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Previous#get", this ); }

                    return this.previous;
                }
            },
            IsComplete: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsComplete#get", this ); }

                    return this.trackTime >= this.animationEnd - this.animationStart;
                }
            },
            MixTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#get", this ); }

                    return this.mixTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixTime#set", this ); }

                    this.mixTime = value;
                }
            },
            MixDuration: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#get", this ); }

                    return this.mixDuration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixDuration#set", this ); }

                    this.mixDuration = value;
                }
            },
            MixBlend: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#get", this ); }

                    return this.mixBlend;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixBlend#set", this ); }

                    this.mixBlend = value;
                }
            },
            MixingFrom: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingFrom#get", this ); }

                    return this.mixingFrom;
                }
            },
            MixingTo: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#MixingTo#get", this ); }

                    return this.mixingTo;
                }
            },
            HoldPrevious: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#get", this ); }

                    return this.holdPrevious;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#HoldPrevious#set", this ); }

                    this.holdPrevious = value;
                }
            },
            Reverse: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reverse#get", this ); }

                    return this.reverse;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reverse#set", this ); }

                    this.reverse = value;
                }
            },
            ShortestRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ShortestRotation#get", this ); }

                    return this.shortestRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ShortestRotation#set", this ); }

                    this.shortestRotation = value;
                }
            },
            IsEmptyAnimation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#IsEmptyAnimation#get", this ); }

                    return Bridge.referenceEquals(this.animation, Spine.AnimationState.EmptyAnimation);
                }
            }
        },
        alias: ["Reset", "Spine$Pool$1$IPoolable$Spine$TrackEntry$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#init", this ); }

                this.timeScale = 1.0;
                this.mixBlend = Spine.MixBlend.Replace;
                this.timelineMode = new (Spine.ExposedList$1(System.Int32)).ctor();
                this.timelineHoldMix = new (Spine.ExposedList$1(Spine.TrackEntry)).ctor();
                this.timelinesRotation = new (Spine.ExposedList$1(System.Single)).ctor();
            }
        },
        methods: {
            /*Spine.TrackEntry.OnStart start.*/
            OnStart: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnStart", this ); }

                if (!Bridge.staticEquals(this.Start, null)) {
                    this.Start(this);
                }
            },
            /*Spine.TrackEntry.OnStart end.*/

            /*Spine.TrackEntry.OnInterrupt start.*/
            OnInterrupt: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnInterrupt", this ); }

                if (!Bridge.staticEquals(this.Interrupt, null)) {
                    this.Interrupt(this);
                }
            },
            /*Spine.TrackEntry.OnInterrupt end.*/

            /*Spine.TrackEntry.OnEnd start.*/
            OnEnd: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEnd", this ); }

                if (!Bridge.staticEquals(this.End, null)) {
                    this.End(this);
                }
            },
            /*Spine.TrackEntry.OnEnd end.*/

            /*Spine.TrackEntry.OnDispose start.*/
            OnDispose: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnDispose", this ); }

                if (!Bridge.staticEquals(this.Dispose, null)) {
                    this.Dispose(this);
                }
            },
            /*Spine.TrackEntry.OnDispose end.*/

            /*Spine.TrackEntry.OnComplete start.*/
            OnComplete: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnComplete", this ); }

                if (!Bridge.staticEquals(this.Complete, null)) {
                    this.Complete(this);
                }
            },
            /*Spine.TrackEntry.OnComplete end.*/

            /*Spine.TrackEntry.OnEvent start.*/
            OnEvent: function (e) {
if ( TRACE ) { TRACE( "Spine.TrackEntry#OnEvent", this ); }

                if (!Bridge.staticEquals(this.Event, null)) {
                    this.Event(this, e);
                }
            },
            /*Spine.TrackEntry.OnEvent end.*/

            /*Spine.TrackEntry.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#Reset", this ); }

                this.previous = null;
                this.next = null;
                this.mixingFrom = null;
                this.mixingTo = null;
                this.animation = null;
                this.Start = null;
                this.Interrupt = null;
                this.End = null;
                this.Dispose = null;
                this.Complete = null;
                this.Event = null;
                this.timelineMode.Clear();
                this.timelineHoldMix.Clear();
                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.Reset end.*/

            /*Spine.TrackEntry.ResetRotationDirections start.*/
            ResetRotationDirections: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#ResetRotationDirections", this ); }

                this.timelinesRotation.Clear();
            },
            /*Spine.TrackEntry.ResetRotationDirections end.*/

            /*Spine.TrackEntry.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#toString", this ); }

                return (this.animation == null) ? "<none>" : this.animation.name;
            },
            /*Spine.TrackEntry.toString end.*/

            /*Spine.TrackEntry.AllowImmediateQueue start.*/
            AllowImmediateQueue: function () {
if ( TRACE ) { TRACE( "Spine.TrackEntry#AllowImmediateQueue", this ); }

                if (this.nextTrackLast < 0.0) {
                    this.nextTrackLast = 0.0;
                }
            },
            /*Spine.TrackEntry.AllowImmediateQueue end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TrackEntry end.*/

    /*Spine.TransformConstraint start.*/
    Bridge.define("Spine.TransformConstraint", {
        inherits: [Spine.IUpdatable],
        fields: {
            data: null,
            bones: null,
            target: null,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            mixScaleX: 0,
            mixScaleY: 0,
            mixShearY: 0,
            active: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Target#set", this ); }

                    this.target = value;
                }
            },
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            MixScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleX#get", this ); }

                    return this.mixScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleX#set", this ); }

                    this.mixScaleX = value;
                }
            },
            MixScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleY#get", this ); }

                    return this.mixScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixScaleY#set", this ); }

                    this.mixScaleY = value;
                }
            },
            MixShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixShearY#get", this ); }

                    return this.mixShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#MixShearY#set", this ); }

                    this.mixShearY = value;
                }
            },
            Active: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Active#get", this ); }

                    return this.active;
                }
            },
            Data: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Data#get", this ); }

                    return this.data;
                }
            }
        },
        alias: [
            "Active", "Spine$IUpdatable$Active",
            "Update", "Spine$IUpdatable$Update"
        ],
        ctors: {
            $ctor1: function (data, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#$ctor1", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "data cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor3("skeleton", "skeleton cannot be null.");
                }
                this.data = data;
                this.mixRotate = data.mixRotate;
                this.mixX = data.mixX;
                this.mixY = data.mixY;
                this.mixScaleX = data.mixScaleX;
                this.mixScaleY = data.mixScaleY;
                this.mixShearY = data.mixShearY;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).ctor();
                $t = Bridge.getEnumerator(data.bones);
                try {
                    while ($t.moveNext()) {
                        var boneData = $t.Current;
                        this.bones.Add(($t1 = skeleton.bones.Items)[boneData.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.bones.Items)[data.target.index];
            },
            ctor: function (constraint, skeleton) {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ctor", this ); }

                var $t, $t1, $t2;
                this.$initialize();
                if (constraint == null) {
                    throw new System.ArgumentNullException.$ctor1("constraint cannot be null.");
                }
                if (skeleton == null) {
                    throw new System.ArgumentNullException.$ctor1("skeleton cannot be null.");
                }
                this.data = constraint.data;
                this.bones = new (Spine.ExposedList$1(Spine.Bone)).$ctor3(constraint.Bones.Count);
                $t = Bridge.getEnumerator(constraint.Bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        this.bones.Add(($t1 = skeleton.Bones.Items)[bone.data.index]);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.target = ($t2 = skeleton.Bones.Items)[constraint.target.data.index];
                this.mixRotate = constraint.mixRotate;
                this.mixX = constraint.mixX;
                this.mixY = constraint.mixY;
                this.mixScaleX = constraint.mixScaleX;
                this.mixScaleY = constraint.mixScaleY;
                this.mixShearY = constraint.mixShearY;
            }
        },
        methods: {
            /*Spine.TransformConstraint.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#Update", this ); }

                if (this.mixRotate === 0.0 && this.mixX === 0.0 && this.mixY === 0.0 && this.mixScaleX === 0.0 && this.mixScaleY === 0.0 && this.mixShearY === 0.0) {
                    return;
                }
                if (this.data.local) {
                    if (this.data.relative) {
                        this.ApplyRelativeLocal();
                    } else {
                        this.ApplyAbsoluteLocal();
                    }
                } else if (this.data.relative) {
                    this.ApplyRelativeWorld();
                } else {
                    this.ApplyAbsoluteWorld();
                }
            },
            /*Spine.TransformConstraint.Update end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteWorld start.*/
            ApplyAbsoluteWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteWorld", this ); }

                var mixRotate = this.mixRotate;
                var mixX = this.mixX;
                var mixY = this.mixY;
                var mixScaleX = this.mixScaleX;
                var mixScaleY = this.mixScaleY;
                var mixShearY = this.mixShearY;
                var translate = mixX !== 0.0 || mixY !== 0.0;
                var target = this.target;
                var ta = target.a;
                var tb = target.b;
                var tc = target.c;
                var td = target.d;
                var degRadReflect = ((ta * td - tb * tc > 0.0) ? (0.0174532924) : (-0.0174532924));
                var offsetRotation = this.data.offsetRotation * degRadReflect;
                var offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (mixRotate !== 0.0) {
                        var a = bone.a;
                        var b2 = bone.b;
                        var c = bone.c;
                        var d2 = bone.d;
                        var r2 = Spine.MathUtils.Atan2(tc, ta) - Spine.MathUtils.Atan2(c, a) + offsetRotation;
                        if (r2 > 3.14159274) {
                            r2 -= 6.28318548;
                        } else if (r2 < -3.14159274) {
                            r2 += 6.28318548;
                        }
                        r2 *= mixRotate;
                        var cos = Spine.MathUtils.Cos(r2);
                        var sin = Spine.MathUtils.Sin(r2);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b2 - sin * d2;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b2 + cos * d2;
                    }
                    if (translate) {
                        var tx = { };
                        var ty = { };
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty);
                        bone.worldX += (tx.v - bone.worldX) * mixX;
                        bone.worldY += (ty.v - bone.worldY) * mixY;
                    }
                    if (mixScaleX !== 0.0) {
                        var s3 = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                        if (s3 !== 0.0) {
                            s3 = (s3 + (Math.sqrt(ta * ta + tc * tc) - s3 + this.data.offsetScaleX) * mixScaleX) / s3;
                        }
                        bone.a *= s3;
                        bone.c *= s3;
                    }
                    if (mixScaleY !== 0.0) {
                        var s2 = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                        if (s2 !== 0.0) {
                            s2 = (s2 + (Math.sqrt(tb * tb + td * td) - s2 + this.data.offsetScaleY) * mixScaleY) / s2;
                        }
                        bone.b *= s2;
                        bone.d *= s2;
                    }
                    if (mixShearY > 0.0) {
                        var b = bone.b;
                        var d = bone.d;
                        var by = Spine.MathUtils.Atan2(d, b);
                        var r = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta) - (by - Spine.MathUtils.Atan2(bone.c, bone.a));
                        if (r > 3.14159274) {
                            r -= 6.28318548;
                        } else if (r < -3.14159274) {
                            r += 6.28318548;
                        }
                        r = by + (r + offsetShearY) * mixShearY;
                        var s = Math.sqrt(b * b + d * d);
                        bone.b = Spine.MathUtils.Cos(r) * s;
                        bone.d = Spine.MathUtils.Sin(r) * s;
                    }
                    bone.UpdateAppliedTransform();
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteWorld end.*/

            /*Spine.TransformConstraint.ApplyRelativeWorld start.*/
            ApplyRelativeWorld: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeWorld", this ); }

                var mixRotate = this.mixRotate;
                var mixX = this.mixX;
                var mixY = this.mixY;
                var mixScaleX = this.mixScaleX;
                var mixScaleY = this.mixScaleY;
                var mixShearY = this.mixShearY;
                var translate = mixX !== 0.0 || mixY !== 0.0;
                var target = this.target;
                var ta = target.a;
                var tb = target.b;
                var tc = target.c;
                var td = target.d;
                var degRadReflect = ((ta * td - tb * tc > 0.0) ? (0.0174532924) : (-0.0174532924));
                var offsetRotation = this.data.offsetRotation * degRadReflect;
                var offsetShearY = this.data.offsetShearY * degRadReflect;
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    if (mixRotate !== 0.0) {
                        var a = bone.a;
                        var b2 = bone.b;
                        var c = bone.c;
                        var d2 = bone.d;
                        var r2 = Spine.MathUtils.Atan2(tc, ta) + offsetRotation;
                        if (r2 > 3.14159274) {
                            r2 -= 6.28318548;
                        } else if (r2 < -3.14159274) {
                            r2 += 6.28318548;
                        }
                        r2 *= mixRotate;
                        var cos = Spine.MathUtils.Cos(r2);
                        var sin = Spine.MathUtils.Sin(r2);
                        bone.a = cos * a - sin * c;
                        bone.b = cos * b2 - sin * d2;
                        bone.c = sin * a + cos * c;
                        bone.d = sin * b2 + cos * d2;
                    }
                    if (translate) {
                        var tx = { };
                        var ty = { };
                        target.LocalToWorld(this.data.offsetX, this.data.offsetY, tx, ty);
                        bone.worldX += tx.v * mixX;
                        bone.worldY += ty.v * mixY;
                    }
                    if (mixScaleX !== 0.0) {
                        var s3 = (Math.sqrt(ta * ta + tc * tc) - 1.0 + this.data.offsetScaleX) * mixScaleX + 1.0;
                        bone.a *= s3;
                        bone.c *= s3;
                    }
                    if (mixScaleY !== 0.0) {
                        var s2 = (Math.sqrt(tb * tb + td * td) - 1.0 + this.data.offsetScaleY) * mixScaleY + 1.0;
                        bone.b *= s2;
                        bone.d *= s2;
                    }
                    if (mixShearY > 0.0) {
                        var r = Spine.MathUtils.Atan2(td, tb) - Spine.MathUtils.Atan2(tc, ta);
                        if (r > 3.14159274) {
                            r -= 6.28318548;
                        } else if (r < -3.14159274) {
                            r += 6.28318548;
                        }
                        var b = bone.b;
                        var d = bone.d;
                        r = Spine.MathUtils.Atan2(d, b) + (r - 1.57079637 + offsetShearY) * mixShearY;
                        var s = Math.sqrt(b * b + d * d);
                        bone.b = Spine.MathUtils.Cos(r) * s;
                        bone.d = Spine.MathUtils.Sin(r) * s;
                    }
                    bone.UpdateAppliedTransform();
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeWorld end.*/

            /*Spine.TransformConstraint.ApplyAbsoluteLocal start.*/
            ApplyAbsoluteLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyAbsoluteLocal", this ); }

                var mixRotate = this.mixRotate;
                var mixX = this.mixX;
                var mixY = this.mixY;
                var mixScaleX = this.mixScaleX;
                var mixScaleY = this.mixScaleY;
                var mixShearY = this.mixShearY;
                var target = this.target;
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    var rotation = bone.arotation;
                    if (mixRotate !== 0.0) {
                        var r2 = target.arotation - rotation + this.data.offsetRotation;
                        r2 -= (Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - (r2 / 360.0)))) | 0)), 360)) | 0;
                        rotation += r2 * mixRotate;
                    }
                    var x = bone.ax;
                    var y = bone.ay;
                    x += (target.ax - x + this.data.offsetX) * mixX;
                    y += (target.ay - y + this.data.offsetY) * mixY;
                    var scaleX = bone.ascaleX;
                    var scaleY = bone.ascaleY;
                    if (mixScaleX !== 0.0 && scaleX !== 0.0) {
                        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * mixScaleX) / scaleX;
                    }
                    if (mixScaleY !== 0.0 && scaleY !== 0.0) {
                        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * mixScaleY) / scaleY;
                    }
                    var shearY = bone.ashearY;
                    if (mixShearY !== 0.0) {
                        var r = target.ashearY - shearY + this.data.offsetShearY;
                        r -= (Bridge.Int.mul((((16384 - Bridge.Int.clip32((16384.499999999996 - (r / 360.0)))) | 0)), 360)) | 0;
                        shearY += r * mixShearY;
                    }
                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyAbsoluteLocal end.*/

            /*Spine.TransformConstraint.ApplyRelativeLocal start.*/
            ApplyRelativeLocal: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#ApplyRelativeLocal", this ); }

                var mixRotate = this.mixRotate;
                var mixX = this.mixX;
                var mixY = this.mixY;
                var mixScaleX = this.mixScaleX;
                var mixScaleY = this.mixScaleY;
                var mixShearY = this.mixShearY;
                var target = this.target;
                var bones = this.bones.Items;
                var i = 0;
                for (var j = this.bones.Count; i < j; i = (i + 1) | 0) {
                    var bone = bones[i];
                    var rotation = bone.arotation + (target.arotation + this.data.offsetRotation) * mixRotate;
                    var x = bone.ax + (target.ax + this.data.offsetX) * mixX;
                    var y = bone.ay + (target.ay + this.data.offsetY) * mixY;
                    var scaleX = bone.ascaleX * ((target.ascaleX - 1.0 + this.data.offsetScaleX) * mixScaleX + 1.0);
                    var scaleY = bone.ascaleY * ((target.ascaleY - 1.0 + this.data.offsetScaleY) * mixScaleY + 1.0);
                    var shearY = bone.ashearY + (target.ashearY + this.data.offsetShearY) * mixShearY;
                    bone.UpdateWorldTransform$1(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                }
            },
            /*Spine.TransformConstraint.ApplyRelativeLocal end.*/

            /*Spine.TransformConstraint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraint#toString", this ); }

                return this.data.name;
            },
            /*Spine.TransformConstraint.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    Bridge.define("Spine.TransformConstraintData", {
        inherits: [Spine.ConstraintData],
        fields: {
            bones: null,
            target: null,
            mixRotate: 0,
            mixX: 0,
            mixY: 0,
            mixScaleX: 0,
            mixScaleY: 0,
            mixShearY: 0,
            offsetRotation: 0,
            offsetX: 0,
            offsetY: 0,
            offsetScaleX: 0,
            offsetScaleY: 0,
            offsetShearY: 0,
            relative: false,
            local: false
        },
        props: {
            Bones: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Bones#get", this ); }

                    return this.bones;
                }
            },
            Target: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#get", this ); }

                    return this.target;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Target#set", this ); }

                    this.target = value;
                }
            },
            MixRotate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixRotate#get", this ); }

                    return this.mixRotate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixRotate#set", this ); }

                    this.mixRotate = value;
                }
            },
            MixX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixX#get", this ); }

                    return this.mixX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixX#set", this ); }

                    this.mixX = value;
                }
            },
            MixY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixY#get", this ); }

                    return this.mixY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixY#set", this ); }

                    this.mixY = value;
                }
            },
            MixScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleX#get", this ); }

                    return this.mixScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleX#set", this ); }

                    this.mixScaleX = value;
                }
            },
            MixScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleY#get", this ); }

                    return this.mixScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixScaleY#set", this ); }

                    this.mixScaleY = value;
                }
            },
            MixShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixShearY#get", this ); }

                    return this.mixShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#MixShearY#set", this ); }

                    this.mixShearY = value;
                }
            },
            OffsetRotation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#get", this ); }

                    return this.offsetRotation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetRotation#set", this ); }

                    this.offsetRotation = value;
                }
            },
            OffsetX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#get", this ); }

                    return this.offsetX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetX#set", this ); }

                    this.offsetX = value;
                }
            },
            OffsetY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#get", this ); }

                    return this.offsetY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetY#set", this ); }

                    this.offsetY = value;
                }
            },
            OffsetScaleX: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#get", this ); }

                    return this.offsetScaleX;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleX#set", this ); }

                    this.offsetScaleX = value;
                }
            },
            OffsetScaleY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#get", this ); }

                    return this.offsetScaleY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetScaleY#set", this ); }

                    this.offsetScaleY = value;
                }
            },
            OffsetShearY: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#get", this ); }

                    return this.offsetShearY;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#OffsetShearY#set", this ); }

                    this.offsetShearY = value;
                }
            },
            Relative: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#get", this ); }

                    return this.relative;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Relative#set", this ); }

                    this.relative = value;
                }
            },
            Local: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#get", this ); }

                    return this.local;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#Local#set", this ); }

                    this.local = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#init", this ); }

                this.bones = new (Spine.ExposedList$1(Spine.BoneData)).ctor();
            },
            ctor: function (name) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintData#ctor", this ); }

                this.$initialize();
                Spine.ConstraintData.ctor.call(this, name);
            }
        }
    });
    /*Spine.TransformConstraintData end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }
                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(Spine.Skin.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        var slotIndex = 0;
                        for (var slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.BlendMode === Spine.BlendMode.Normal || (!includeAdditiveSlots && slot.BlendMode === Spine.BlendMode.Additive)) {
                                continue;
                            }
                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    skin.GetAttachments(slotIndex, entryBuffer);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }
                            var templateMaterial = null;
                            switch (slot.BlendMode) {
                                case Spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case Spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case Spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }
                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var item = $t1.Current;
                                    var renderableAttachment;
                                    if (((renderableAttachment = Bridge.as(item.Attachment, Spine.IHasTextureRegion))) != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                var materials = this.atlasAsset.materials;
                $t = Bridge.getEnumerator(materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        var textureName = other.mainTexture.name;
                        if (Bridge.referenceEquals(textureName, name) || (this.atlasAsset.OnDemandTextureLoader != null && Bridge.referenceEquals(textureName, this.atlasAsset.OnDemandTextureLoader.GetPlaceholderTextureName(name)))) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewRegionAttachment", "Spine$AttachmentLoader$NewRegionAttachment",
            "NewMeshAttachment", "Spine$AttachmentLoader$NewMeshAttachment",
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                return ($t = new Spine.RegionAttachment.$ctor1(name), $t.Region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                return ($t = new Spine.MeshAttachment.$ctor1(name), $t.Region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new Spine.BoundingBoxAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new Spine.PathAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new Spine.PointAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new Spine.ClippingAttachment.$ctor1(name);
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : ((this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim)));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }
                var start = time;
                var end = animation.Duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return Bridge.getDefaultValue(Spine.Unity.SkeletonRootMotionBase.RootMotionInfo);
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = -1;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }

                if ((this.mecanimLayerFlags & (1 << layerIndex)) === 0 || weight === 0.0) {
                    return;
                }
                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta", this ); }

                var result = this.rotationDelta;
                this.rotationDelta = 0.0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            skeletonGraphic: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonGraphic) ? this.skeletonGraphic.MeshScale : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }
                var animation = track.Animation;
                var start = track.AnimationTime;
                var end = animation.Duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.GetCurrent(trackIndex);
                if (track == null) {
                    return Bridge.getDefaultValue(Spine.Unity.SkeletonRootMotionBase.RootMotionInfo);
                }
                var animation = track.Animation;
                var time = track.AnimationTime;
                return this.GetAnimationRootMotionInfo(track.Animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = -1;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                var $t;
                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.animationState = ($t = (Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent))) != null ? $t.Spine$Unity$IAnimationStateComponent$AnimationState : null;
                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;
                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & (1 << trackIndex)) === 0) {
                        continue;
                    }
                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.AnimationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }
                        next = track;
                        track = track.MixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta", this ); }

                var localDelta = 0.0;
                var trackCount = this.animationState.Tracks.Count;
                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & (1 << trackIndex)) === 0) {
                        continue;
                    }
                    var track = this.animationState.GetCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.Animation;
                        var start = track.AnimationLast;
                        var end = track.AnimationTime;
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0.0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }
                        next = track;
                        track = track.MixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1", this ); }

                var mixAlpha = { v : 1.0 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                var mixAlpha = { v : 1.0 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetMixAlpha", this ); }

                var mix;
                if (next != null) {
                    if (next.MixDuration === 0.0) {
                        mix = 1.0;
                    } else {
                        mix = next.MixTime / next.MixDuration;
                        if (mix > 1.0) {
                            mix = 1.0;
                        }
                    }
                    var mixAndAlpha = track.Alpha * next.InterruptAlpha * (1.0 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                    return;
                }
                if (track.MixDuration === 0.0) {
                    mix = 1.0;
                } else {
                    mix = track.Alpha * (track.MixTime / track.MixDuration);
                    if (mix > 1.0) {
                        mix = 1.0;
                    }
                }
                cumulatedMixAlpha.v *= mix;
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }
                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }
                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }
                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var j = 0; j < ((atlasLines.length - 1) | 0); j = (j + 1) | 0) {
                        var line = atlasLines[j].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    var i = 0;
                    for (var m = pages.Count; i < m; i = (i + 1) | 0) {
                        var mat = null;
                        var pageName = pages.getItem(i);
                        var k = 0;
                        for (var l = textures.length; k < l; k = (k + 1) | 0) {
                            if (System.String.equals(pageName, textures[k].name, 5)) {
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[k];
                                break;
                            }
                        }
                        if (mat != null) {
                            materials[i] = mat;
                            continue;
                        }
                        throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                    }
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }
                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }
                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return (this.materials != null) ? this.materials.length : 0;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || ""), this);
                    this.Clear();
                    return null;
                }
                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || ""), this);
                    this.Clear();
                    return null;
                }
                if (this.atlas != null) {
                    return this.atlas;
                }
                try {
                    var loader;
                    if (!onlyMetaData) {
                        var textureLoader;
                        if (this.customTextureLoader != null) {
                            textureLoader = this.customTextureLoader;
                        } else {
                            var textureLoader2 = new Spine.Unity.MaterialsTextureLoader(this);
                            textureLoader = textureLoader2;
                        }
                        loader = textureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.FindRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }
                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([new pc.Color( 1, 1, 1, 1 ), new pc.Color( 1, 1, 1, 1 ), new pc.Color( 1, 1, 1, 1 ), new pc.Color( 1, 1, 1, 1 )], UnityEngine.Color);
                    var triangles = System.Array.init([0, 1, 2, 2, 3, 0], System.Int32);
                    var left = region.width / -2.0;
                    var right = left * -1.0;
                    var top = region.height / 2.0;
                    var bottom = top * -1.0;
                    verts[0] = new pc.Vec3( left, bottom, 0.0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0.0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0.0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0.0 ).clone().scale( scale );
                    var u = region.u;
                    var v = region.v;
                    var u2 = region.u2;
                    var v2 = region.v2;
                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }
                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();
                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }
                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }
                    var slot = skeletonData.FindSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.FindSkin(hierarchy.skin).GetAttachment(slot.Index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return (renderer.skeleton == null) ? null : renderer.skeleton.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.FindBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;
                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }
                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return (this.materials != null) ? this.materials.length : 0;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || ""), this);
                    this.Clear();
                    return null;
                }
                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || ""), this);
                    this.Clear();
                    return null;
                }
                if (this.atlas != null) {
                    return this.atlas;
                }
                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (Bridge.ensureBaseProperty(this, "name").$UnityEngine$Object$name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;
                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }
                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;
                        region.degrees = ((savedRegion.packingRotation !== 0) ? 90 : 0);
                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;
                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;
                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);
                        region.offsetX = 0.0;
                        region.offsetY = 0.0;
                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }

                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }
                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);
                var material = this.materials[0];
                material.mainTexture = texture;
                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;
                page.minFilter = Spine.TextureFilter.Linear;
                page.magFilter = Spine.TextureFilter.Linear;
                page.uWrap = Spine.TextureWrap.ClampToEdge;
                page.vWrap = Spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);
                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);
                for (var i = 0; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = ((sprite.packingRotation !== 0) ? 90 : 0);
                    region.u2 = 1.0;
                    region.v2 = 1.0;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;
                    region.index = i;
                    regions.add(region);
                }
                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);
                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#ctor", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationComplete#NowWaitFor$1", this ); }

                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#ctor", this ); }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            NowWaitFor$1: function (trackEntry) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineAnimationEnd#NowWaitFor$1", this ); }

                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*UIManager start.*/
    Bridge.define("UIManager", {
        inherits: function () {
if ( TRACE ) { TRACE( "UIManager#inherits", this ); }
 return [Singleton$1(UIManager)]; },
        fields: {
            uicLose: null,
            uicWin: null,
            animTakePhoto: null
        },
        methods: {
            /*UIManager.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "UIManager#TriggerCTA", this ); }
 },
            /*UIManager.TriggerCTA end.*/

            /*UIManager.ShowGamePlay start.*/
            ShowGamePlay: function () {
if ( TRACE ) { TRACE( "UIManager#ShowGamePlay", this ); }

                this.uicLose.gameObject.SetActive(false);
                this.uicWin.gameObject.SetActive(false);
            },
            /*UIManager.ShowGamePlay end.*/

            /*UIManager.ShowLose start.*/
            ShowLose: function () {
if ( TRACE ) { TRACE( "UIManager#ShowLose", this ); }

                this.uicLose.gameObject.SetActive(true);
                this.uicLose.OnShowed();
            },
            /*UIManager.ShowLose end.*/

            /*UIManager.ShowWin start.*/
            ShowWin: function () {
if ( TRACE ) { TRACE( "UIManager#ShowWin", this ); }

                this.uicWin.gameObject.SetActive(true);
                this.uicWin.OnShowed();
                Singleton$1(SoundManager).Ins.PlaySound("GirlSay", false);
            },
            /*UIManager.ShowWin end.*/

            /*UIManager.TakePhoto start.*/
            TakePhoto: function () {
if ( TRACE ) { TRACE( "UIManager#TakePhoto", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.animTakePhoto.gameObject.SetActive(true);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UIManager.TakePhoto end.*/


        }
    });
    /*UIManager end.*/

    /*Spine.CurveTimeline1 start.*/
    Bridge.define("Spine.CurveTimeline1", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                VALUE: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#init", this ); }

                    this.ENTRIES = 2;
                    this.VALUE = 1;
                }
            }
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#FrameEntries#get", this ); }

                    return 2;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, propertyId) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [propertyId]);
            }
        },
        methods: {
            /*Spine.CurveTimeline1.SetFrame start.*/
            SetFrame: function (frame, time, value) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#SetFrame", this ); }

                frame = frame << 1;
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = value;
            },
            /*Spine.CurveTimeline1.SetFrame end.*/

            /*Spine.CurveTimeline1.GetCurveValue start.*/
            GetCurveValue: function (time) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline1#GetCurveValue", this ); }

                var frames = this.frames;
                var i = (frames.length - 2) | 0;
                for (var ii = 2; ii <= i; ii = (ii + 2) | 0) {
                    if (frames[ii] > time) {
                        i = (ii - 2) | 0;
                        break;
                    }
                }
                var curveType = Bridge.Int.clip32(this.curves[i >> 1]);
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            var value = frames[((i + 1) | 0)];
                            return value + (time - before) / (frames[((i + 2) | 0)] - before) * (frames[((((i + 2) | 0) + 1) | 0)] - value);
                        }
                    case 1: 
                        return frames[((i + 1) | 0)];
                    default: 
                        return this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                }
            },
            /*Spine.CurveTimeline1.GetCurveValue end.*/


        }
    });
    /*Spine.CurveTimeline1 end.*/

    /*Spine.Atlas start.*/
    Bridge.define("Spine.Atlas", {
        inherits: [System.Collections.Generic.IEnumerable$1(Spine.AtlasRegion),System.Collections.IEnumerable],
        statics: {
            methods: {
                /*Spine.Atlas.ReadEntry:static start.*/
                ReadEntry: function (entry, line) {
if ( TRACE ) { TRACE( "Spine.Atlas#ReadEntry", this ); }

                    if (line == null) {
                        return 0;
                    }
                    line = line.trim();
                    if (line.length === 0) {
                        return 0;
                    }
                    var colon = System.String.indexOf(line, String.fromCharCode(58));
                    if (colon === -1) {
                        return 0;
                    }
                    entry[0] = line.substr(0, colon).trim();
                    var i = 1;
                    var lastMatch = (colon + 1) | 0;
                    while (true) {
                        var comma = System.String.indexOf(line, String.fromCharCode(44), lastMatch);
                        if (comma === -1) {
                            entry[i] = line.substr(lastMatch).trim();
                            return i;
                        }
                        entry[i] = line.substr(lastMatch, ((comma - lastMatch) | 0)).trim();
                        lastMatch = (comma + 1) | 0;
                        if (i === 4) {
                            break;
                        }
                        i = (i + 1) | 0;
                    }
                    return 4;
                },
                /*Spine.Atlas.ReadEntry:static end.*/


            }
        },
        fields: {
            pages: null,
            regions: null,
            textureLoader: null
        },
        props: {
            Regions: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Regions#get", this ); }

                    return this.regions;
                }
            },
            Pages: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Pages#get", this ); }

                    return this.pages;
                }
            }
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$Spine$AtlasRegion$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#init", this ); }

                this.pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                this.regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
            },
            ctor: function (pages, regions) {
if ( TRACE ) { TRACE( "Spine.Atlas#ctor", this ); }

                this.$initialize();
                if (pages == null) {
                    throw new System.ArgumentNullException.$ctor3("pages", "pages cannot be null.");
                }
                if (regions == null) {
                    throw new System.ArgumentNullException.$ctor3("regions", "regions cannot be null.");
                }
                this.pages = pages;
                this.regions = regions;
                this.textureLoader = null;
            },
            $ctor1: function (reader, imagesDir, textureLoader) {
if ( TRACE ) { TRACE( "Spine.Atlas#$ctor1", this ); }

                this.$initialize();
                if (reader == null) {
                    throw new System.ArgumentNullException.$ctor3("reader", "reader cannot be null.");
                }
                if (imagesDir == null) {
                    throw new System.ArgumentNullException.$ctor3("imagesDir", "imagesDir cannot be null.");
                }
                if (textureLoader == null) {
                    throw new System.ArgumentNullException.$ctor3("textureLoader", "textureLoader cannot be null.");
                }
                this.textureLoader = textureLoader;
                var entry = System.Array.init(5, null, System.String);
                var page = null;
                var region = null;
                var pageFields = function (_o1) {
                        _o1.add("size", function () {
                            page.width = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            page.height = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o1.add("format", function () {
                            page.format = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.Format, entry[1], false), Spine.Format), System.Int32));
                        });
                        _o1.add("filter", function () {
                            page.minFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, entry[1], false), Spine.TextureFilter), System.Int32));
                            page.magFilter = System.Nullable.getValue(Bridge.cast(Bridge.unbox(System.Enum.parse(Spine.TextureFilter, entry[2], false), Spine.TextureFilter), System.Int32));
                        });
                        _o1.add("repeat", function () {
                            if (System.String.indexOf(entry[1], String.fromCharCode(120)) !== -1) {
                                page.uWrap = Spine.TextureWrap.Repeat;
                            }
                            if (System.String.indexOf(entry[1], String.fromCharCode(121)) !== -1) {
                                page.vWrap = Spine.TextureWrap.Repeat;
                            }
                        });
                        _o1.add("pma", function () {
                            page.pma = Bridge.referenceEquals(entry[1], "true");
                        });
                        return _o1;
                    }(new (System.Collections.Generic.Dictionary$2(System.String,Function)).$ctor4(5));
                var regionFields = function (_o2) {
                        _o2.add("xy", function () {
                            region.x = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.y = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("size", function () {
                            region.width = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.height = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("bounds", function () {
                            region.x = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.y = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.width = System.Int32.parseWithProvider(entry[3], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.height = System.Int32.parseWithProvider(entry[4], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("offset", function () {
                            region.offsetX = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.offsetY = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("orig", function () {
                            region.originalWidth = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.originalHeight = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("offsets", function () {
                            region.offsetX = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.offsetY = System.Int32.parseWithProvider(entry[2], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.originalWidth = System.Int32.parseWithProvider(entry[3], 7, System.Globalization.CultureInfo.invariantCulture);
                            region.originalHeight = System.Int32.parseWithProvider(entry[4], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        _o2.add("rotate", function () {
                            var text = entry[1];
                            if (Bridge.referenceEquals(text, "true")) {
                                region.degrees = 90;
                            } else if (!Bridge.referenceEquals(text, "false")) {
                                region.degrees = System.Int32.parseWithProvider(text, 7, System.Globalization.CultureInfo.invariantCulture);
                            }
                        });
                        _o2.add("index", function () {
                            region.index = System.Int32.parseWithProvider(entry[1], 7, System.Globalization.CultureInfo.invariantCulture);
                        });
                        return _o2;
                    }(new (System.Collections.Generic.Dictionary$2(System.String,Function)).$ctor4(8));
                var line = reader.ReadLine();
                while (line != null && line.trim().length === 0) {
                    line = reader.ReadLine();
                }
                while (line != null && line.trim().length !== 0 && Spine.Atlas.ReadEntry(entry, line) !== 0) {
                    line = reader.ReadLine();
                }
                var names = null;
                var values = null;
                while (line != null) {
                    if (line.trim().length === 0) {
                        page = null;
                        line = reader.ReadLine();
                        continue;
                    }
                    if (page == null) {
                        page = new Spine.AtlasPage();
                        page.name = line.trim();
                        while (Spine.Atlas.ReadEntry(entry, (line = reader.ReadLine())) !== 0) {
                            var field2 = { };
                            if (pageFields.tryGetValue(entry[0], field2)) {
                                field2.v();
                            }
                        }
                        textureLoader.Spine$TextureLoader$Load(page, System.IO.Path.Combine(imagesDir, page.name));
                        this.pages.add(page);
                        continue;
                    }
                    region = new Spine.AtlasRegion();
                    region.page = page;
                    region.name = line;
                    while (true) {
                        var count = Spine.Atlas.ReadEntry(entry, (line = reader.ReadLine()));
                        if (count === 0) {
                            break;
                        }
                        var field = { };
                        if (regionFields.tryGetValue(entry[0], field)) {
                            field.v();
                            continue;
                        }
                        if (names == null) {
                            names = new (System.Collections.Generic.List$1(System.String)).$ctor2(8);
                            values = new (System.Collections.Generic.List$1(System.Array.type(System.Int32))).$ctor2(8);
                        }
                        names.add(entry[0]);
                        var entryValues = System.Array.init(count, 0, System.Int32);
                        for (var i = 0; i < count; i = (i + 1) | 0) {
                            System.Int32.tryParseWithProvider(entry[((i + 1) | 0)], 511, System.Globalization.CultureInfo.invariantCulture, Bridge.ref(entryValues, i));
                        }
                        values.add(entryValues);
                    }
                    if (region.originalWidth === 0 && region.originalHeight === 0) {
                        region.originalWidth = region.width;
                        region.originalHeight = region.height;
                    }
                    if (names != null && names.Count > 0) {
                        region.names = names.ToArray();
                        region.values = values.ToArray();
                        names.clear();
                        values.clear();
                    }
                    region.u = region.x / page.width;
                    region.v = region.y / page.height;
                    if (region.degrees === 90) {
                        region.u2 = (((region.x + region.height) | 0)) / page.width;
                        region.v2 = (((region.y + region.width) | 0)) / page.height;
                        var tempSwap = region.packedWidth;
                        region.packedWidth = region.packedHeight;
                        region.packedHeight = tempSwap;
                    } else {
                        region.u2 = (((region.x + region.width) | 0)) / page.width;
                        region.v2 = (((region.y + region.height) | 0)) / page.height;
                    }
                    this.regions.add(region);
                }
            }
        },
        methods: {
            /*Spine.Atlas.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.GetEnumerator end.*/

            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.regions.GetEnumerator().$clone();
            },
            /*Spine.Atlas.System$Collections$IEnumerable$GetEnumerator end.*/

            /*Spine.Atlas.FlipV start.*/
            FlipV: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#FlipV", this ); }

                var i = 0;
                for (var j = this.regions.Count; i < j; i = (i + 1) | 0) {
                    var region = this.regions.getItem(i);
                    region.v = 1.0 - region.v;
                    region.v2 = 1.0 - region.v2;
                }
            },
            /*Spine.Atlas.FlipV end.*/

            /*Spine.Atlas.FindRegion start.*/
            FindRegion: function (name) {
if ( TRACE ) { TRACE( "Spine.Atlas#FindRegion", this ); }

                var i = 0;
                for (var j = this.regions.Count; i < j; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.regions.getItem(i).name, name)) {
                        return this.regions.getItem(i);
                    }
                }
                return null;
            },
            /*Spine.Atlas.FindRegion end.*/

            /*Spine.Atlas.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Atlas#Dispose", this ); }

                if (this.textureLoader != null) {
                    var i = 0;
                    for (var j = this.pages.Count; i < j; i = (i + 1) | 0) {
                        this.textureLoader.Spine$TextureLoader$Unload(this.pages.getItem(i).rendererObject);
                    }
                }
            },
            /*Spine.Atlas.Dispose end.*/


        }
    });
    /*Spine.Atlas end.*/

    /*Spine.BoundingBoxAttachment start.*/
    Bridge.define("Spine.BoundingBoxAttachment", {
        inherits: [Spine.VertexAttachment],
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
            }
        },
        methods: {
            /*Spine.BoundingBoxAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.BoundingBoxAttachment#Copy", this ); }

                return new Spine.BoundingBoxAttachment.ctor(this);
            },
            /*Spine.BoundingBoxAttachment.Copy end.*/


        }
    });
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    Bridge.define("Spine.ClippingAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            endSlot: null
        },
        props: {
            EndSlot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#get", this ); }

                    return this.endSlot;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#EndSlot#set", this ); }

                    this.endSlot = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
                this.endSlot = other.endSlot;
            }
        },
        methods: {
            /*Spine.ClippingAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.ClippingAttachment#Copy", this ); }

                return new Spine.ClippingAttachment.ctor(this);
            },
            /*Spine.ClippingAttachment.Copy end.*/


        }
    });
    /*Spine.ClippingAttachment end.*/

    /*Spine.CurveTimeline2 start.*/
    Bridge.define("Spine.CurveTimeline2", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                VALUE1: 0,
                VALUE2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#init", this ); }

                    this.ENTRIES = 3;
                    this.VALUE1 = 1;
                    this.VALUE2 = 2;
                }
            }
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#FrameEntries#get", this ); }

                    return 3;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, propertyId1, propertyId2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [propertyId1, propertyId2]);
            }
        },
        methods: {
            /*Spine.CurveTimeline2.SetFrame start.*/
            SetFrame: function (frame, time, value1, value2) {
if ( TRACE ) { TRACE( "Spine.CurveTimeline2#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 3);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = value1;
                this.frames[((frame + 2) | 0)] = value2;
            },
            /*Spine.CurveTimeline2.SetFrame end.*/


        }
    });
    /*Spine.CurveTimeline2 end.*/

    /*Spine.DeformTimeline start.*/
    Bridge.define("Spine.DeformTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0,
            attachment: null,
            vertices: null
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            },
            Attachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Attachment#get", this ); }

                    return this.attachment;
                }
            },
            Vertices: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Vertices#get", this ); }

                    return this.vertices;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex, attachment) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [11 + "|" + slotIndex + "|" + attachment.Id]);
                this.slotIndex = slotIndex;
                this.attachment = attachment;
                this.vertices = System.Array.init(frameCount, null, System.Array.type(System.Single));
            }
        },
        methods: {
            /*Spine.DeformTimeline.SetFrame start.*/
            SetFrame: function (frame, time, vertices) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#SetFrame", this ); }

                this.frames[frame] = time;
                this.vertices[frame] = vertices;
            },
            /*Spine.DeformTimeline.SetFrame end.*/

            /*Spine.DeformTimeline.setBezier start.*/
            setBezier: function (bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#setBezier", this ); }

                var curves = this.curves;
                var i = (this.FrameCount + Bridge.Int.mul(bezier, 18)) | 0;
                if (value === 0) {
                    curves[frame] = (2 + i) | 0;
                }
                var tmpx = (time1 - cx1 * 2.0 + cx2) * 0.03;
                var tmpy = cy2 * 0.03 - cy1 * 0.06;
                var dddx = ((cx1 - cx2) * 3.0 - time1 + time2) * 0.006;
                var dddy = (cy1 - cy2 + 0.333333343) * 0.018;
                var ddx = tmpx * 2.0 + dddx;
                var ddy = tmpy * 2.0 + dddy;
                var dx = (cx1 - time1) * 0.3 + tmpx + dddx * (0.166666672);
                var dy = cy1 * 0.3 + tmpy + dddy * (0.166666672);
                var x = time1 + dx;
                var y = dy;
                for (var j = (i + 18) | 0; i < j; i = (i + 2) | 0) {
                    curves[i] = x;
                    curves[((i + 1) | 0)] = y;
                    dx += ddx;
                    dy += ddy;
                    ddx += dddx;
                    ddy += dddy;
                    x += dx;
                    y += dy;
                }
            },
            /*Spine.DeformTimeline.setBezier end.*/

            /*Spine.DeformTimeline.GetCurvePercent start.*/
            GetCurvePercent: function (time, frame) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#GetCurvePercent", this ); }

                var curves = this.curves;
                var i = Bridge.Int.clip32(curves[frame]);
                switch (i) {
                    case 0: 
                        {
                            var x = this.frames[frame];
                            return (time - x) / (this.frames[((frame + this.FrameEntries) | 0)] - x);
                        }
                    case 1: 
                        return 0.0;
                    default: 
                        {
                            i = (i - 2) | 0;
                            if (curves[i] > time) {
                                var x3 = this.frames[frame];
                                return curves[((i + 1) | 0)] * (time - x3) / (curves[i] - x3);
                            }
                            var j = (i + 18) | 0;
                            for (i = (i + 2) | 0; i < j; i = (i + 2) | 0) {
                                if (curves[i] >= time) {
                                    var x2 = curves[((i - 2) | 0)];
                                    var y = curves[((i - 1) | 0)];
                                    return y + (time - x2) / (curves[i] - x2) * (curves[((i + 1) | 0)] - y);
                                }
                            }
                            var x4 = curves[((j - 2) | 0)];
                            var y2 = curves[((j - 1) | 0)];
                            return y2 + (1.0 - y2) * (time - x4) / (this.frames[((frame + this.FrameEntries) | 0)] - x4);
                        }
                }
            },
            /*Spine.DeformTimeline.GetCurvePercent end.*/

            /*Spine.DeformTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.DeformTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                var vertexAttachment;
                if (!slot.bone.active || !(((vertexAttachment = Bridge.as(slot.attachment, Spine.VertexAttachment))) != null) || !Bridge.referenceEquals(vertexAttachment.TimelineAttachment, this.attachment)) {
                    return;
                }
                var deformArray = slot.deform;
                if (deformArray.Count === 0) {
                    blend = Spine.MixBlend.Setup;
                }
                var vertices = this.vertices;
                var vertexCount = vertices[0].length;
                var frames = this.frames;
                var deform;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            deformArray.Clear();
                            break;
                        case Spine.MixBlend.First: 
                            if (alpha === 1.0) {
                                deformArray.Clear();
                                break;
                            }
                            if (deformArray.Capacity < vertexCount) {
                                deformArray.Capacity = vertexCount;
                            }
                            deformArray.Count = vertexCount;
                            deform = deformArray.Items;
                            if (vertexAttachment.bones == null) {
                                var setupVertices3 = vertexAttachment.vertices;
                                for (var i2 = 0; i2 < vertexCount; i2 = (i2 + 1) | 0) {
                                    deform[i2] += (setupVertices3[i2] - deform[i2]) * alpha;
                                }
                            } else {
                                alpha = 1.0 - alpha;
                                for (var i4 = 0; i4 < vertexCount; i4 = (i4 + 1) | 0) {
                                    deform[i4] *= alpha;
                                }
                            }
                            break;
                    }
                    return;
                }
                if (deformArray.Capacity < vertexCount) {
                    deformArray.Capacity = vertexCount;
                }
                deformArray.Count = vertexCount;
                deform = deformArray.Items;
                if (time >= frames[((frames.length - 1) | 0)]) {
                    var lastVertices = vertices[((frames.length - 1) | 0)];
                    if (alpha === 1.0) {
                        if (blend === Spine.MixBlend.Add) {
                            if (vertexAttachment.bones == null) {
                                var setupVertices7 = vertexAttachment.vertices;
                                for (var i12 = 0; i12 < vertexCount; i12 = (i12 + 1) | 0) {
                                    deform[i12] += lastVertices[i12] - setupVertices7[i12];
                                }
                            } else {
                                for (var i11 = 0; i11 < vertexCount; i11 = (i11 + 1) | 0) {
                                    deform[i11] += lastVertices[i11];
                                }
                            }
                        } else {
                            System.Array.copy(lastVertices, 0, deform, 0, vertexCount);
                        }
                        return;
                    }
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            if (vertexAttachment.bones == null) {
                                var setupVertices5 = vertexAttachment.vertices;
                                for (var i7 = 0; i7 < vertexCount; i7 = (i7 + 1) | 0) {
                                    var setup2 = setupVertices5[i7];
                                    deform[i7] = setup2 + (lastVertices[i7] - setup2) * alpha;
                                }
                            } else {
                                for (var i6 = 0; i6 < vertexCount; i6 = (i6 + 1) | 0) {
                                    deform[i6] = lastVertices[i6] * alpha;
                                }
                            }
                            break;
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                for (var i8 = 0; i8 < vertexCount; i8 = (i8 + 1) | 0) {
                                    deform[i8] += (lastVertices[i8] - deform[i8]) * alpha;
                                }
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            if (vertexAttachment.bones == null) {
                                var setupVertices6 = vertexAttachment.vertices;
                                for (var i10 = 0; i10 < vertexCount; i10 = (i10 + 1) | 0) {
                                    deform[i10] += (lastVertices[i10] - setupVertices6[i10]) * alpha;
                                }
                            } else {
                                for (var i9 = 0; i9 < vertexCount; i9 = (i9 + 1) | 0) {
                                    deform[i9] += lastVertices[i9] * alpha;
                                }
                            }
                            break;
                    }
                    return;
                }
                var frame = Spine.Timeline.Search(frames, time);
                var percent = this.GetCurvePercent(time, frame);
                var prevVertices = vertices[frame];
                var nextVertices = vertices[((frame + 1) | 0)];
                if (alpha === 1.0) {
                    if (blend === Spine.MixBlend.Add) {
                        if (vertexAttachment.bones == null) {
                            var setupVertices4 = vertexAttachment.vertices;
                            for (var i5 = 0; i5 < vertexCount; i5 = (i5 + 1) | 0) {
                                var prev8 = prevVertices[i5];
                                deform[i5] += prev8 + (nextVertices[i5] - prev8) * percent - setupVertices4[i5];
                            }
                        } else {
                            for (var i3 = 0; i3 < vertexCount; i3 = (i3 + 1) | 0) {
                                var prev7 = prevVertices[i3];
                                deform[i3] += prev7 + (nextVertices[i3] - prev7) * percent;
                            }
                        }
                    } else {
                        for (var n = 0; n < vertexCount; n = (n + 1) | 0) {
                            var prev6 = prevVertices[n];
                            deform[n] = prev6 + (nextVertices[n] - prev6) * percent;
                        }
                    }
                    return;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        if (vertexAttachment.bones == null) {
                            var setupVertices = vertexAttachment.vertices;
                            for (var j = 0; j < vertexCount; j = (j + 1) | 0) {
                                var prev2 = prevVertices[j];
                                var setup = setupVertices[j];
                                deform[j] = setup + (prev2 + (nextVertices[j] - prev2) * percent - setup) * alpha;
                            }
                        } else {
                            for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                                var prev = prevVertices[i];
                                deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
                            }
                        }
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        {
                            for (var k = 0; k < vertexCount; k = (k + 1) | 0) {
                                var prev3 = prevVertices[k];
                                deform[k] += (prev3 + (nextVertices[k] - prev3) * percent - deform[k]) * alpha;
                            }
                            break;
                        }
                    case Spine.MixBlend.Add: 
                        if (vertexAttachment.bones == null) {
                            var setupVertices2 = vertexAttachment.vertices;
                            for (var m = 0; m < vertexCount; m = (m + 1) | 0) {
                                var prev5 = prevVertices[m];
                                deform[m] += (prev5 + (nextVertices[m] - prev5) * percent - setupVertices2[m]) * alpha;
                            }
                        } else {
                            for (var l = 0; l < vertexCount; l = (l + 1) | 0) {
                                var prev4 = prevVertices[l];
                                deform[l] += (prev4 + (nextVertices[l] - prev4) * percent) * alpha;
                            }
                        }
                        break;
                }
            },
            /*Spine.DeformTimeline.Apply end.*/


        }
    });
    /*Spine.DeformTimeline end.*/

    /*Spine.IkConstraintTimeline start.*/
    Bridge.define("Spine.IkConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                MIX: 0,
                SOFTNESS: 0,
                BEND_DIRECTION: 0,
                COMPRESS: 0,
                STRETCH: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#init", this ); }

                    this.ENTRIES = 6;
                    this.MIX = 1;
                    this.SOFTNESS = 2;
                    this.BEND_DIRECTION = 3;
                    this.COMPRESS = 4;
                    this.STRETCH = 5;
                }
            }
        },
        fields: {
            ikConstraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#FrameEntries#get", this ); }

                    return 6;
                }
            },
            IkConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#IkConstraintIndex#get", this ); }

                    return this.ikConstraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, ikConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [14 + "|" + ikConstraintIndex]);
                this.ikConstraintIndex = ikConstraintIndex;
            }
        },
        methods: {
            /*Spine.IkConstraintTimeline.SetFrame start.*/
            SetFrame: function (frame, time, mix, softness, bendDirection, compress, stretch) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 6);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = mix;
                this.frames[((frame + 2) | 0)] = softness;
                this.frames[((frame + 3) | 0)] = bendDirection;
                this.frames[((frame + 4) | 0)] = (compress ? 1 : 0);
                this.frames[((frame + 5) | 0)] = (stretch ? 1 : 0);
            },
            /*Spine.IkConstraintTimeline.SetFrame end.*/

            /*Spine.IkConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.IkConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.ikConstraints.Items)[this.ikConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mix = constraint.data.mix;
                            constraint.softness = constraint.data.softness;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            break;
                        case Spine.MixBlend.First: 
                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                            constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
                            constraint.bendDirection = constraint.data.bendDirection;
                            constraint.compress = constraint.data.compress;
                            constraint.stretch = constraint.data.stretch;
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 6);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 6)) | 0)]);
                var mix;
                var softness;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            mix = frames[((i + 1) | 0)];
                            softness = frames[((i + 2) | 0)];
                            var t = (time - before) / (frames[((i + 6) | 0)] - before);
                            mix += (frames[((((i + 6) | 0) + 1) | 0)] - mix) * t;
                            softness += (frames[((((i + 6) | 0) + 2) | 0)] - softness) * t;
                            break;
                        }
                    case 1: 
                        mix = frames[((i + 1) | 0)];
                        softness = frames[((i + 2) | 0)];
                        break;
                    default: 
                        mix = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        softness = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        break;
                }
                if (blend === Spine.MixBlend.Setup) {
                    constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;
                    constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;
                    if (direction === Spine.MixDirection.Out) {
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                    } else {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((i + 3) | 0)]);
                        constraint.compress = frames[((i + 4) | 0)] !== 0.0;
                        constraint.stretch = frames[((i + 5) | 0)] !== 0.0;
                    }
                } else {
                    constraint.mix += (mix - constraint.mix) * alpha;
                    constraint.softness += (softness - constraint.softness) * alpha;
                    if (direction === Spine.MixDirection.In) {
                        constraint.bendDirection = Bridge.Int.clip32(frames[((i + 3) | 0)]);
                        constraint.compress = frames[((i + 4) | 0)] !== 0.0;
                        constraint.stretch = frames[((i + 5) | 0)] !== 0.0;
                    }
                }
            },
            /*Spine.IkConstraintTimeline.Apply end.*/


        }
    });
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.MeshAttachment start.*/
    Bridge.define("Spine.MeshAttachment", {
        inherits: [Spine.VertexAttachment,Spine.IHasTextureRegion],
        fields: {
            region: null,
            path: null,
            regionUVs: null,
            uvs: null,
            triangles: null,
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            hullLength: 0,
            parentMesh: null,
            sequence: null,
            Edges: null,
            Width: 0,
            Height: 0
        },
        props: {
            Region: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Region#get", this ); }

                    return this.region;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Region#set", this ); }

                    if (value == null) {
                        throw new System.ArgumentNullException.$ctor3("region", "region cannot be null.");
                    }
                    this.region = value;
                }
            },
            HullLength: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#get", this ); }

                    return this.hullLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#HullLength#set", this ); }

                    this.hullLength = value;
                }
            },
            RegionUVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#get", this ); }

                    return this.regionUVs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#RegionUVs#set", this ); }

                    this.regionUVs = value;
                }
            },
            UVs: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#get", this ); }

                    return this.uvs;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UVs#set", this ); }

                    this.uvs = value;
                }
            },
            Triangles: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#get", this ); }

                    return this.triangles;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Triangles#set", this ); }

                    this.triangles = value;
                }
            },
            R: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#get", this ); }

                    return this.r;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#R#set", this ); }

                    this.r = value;
                }
            },
            G: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#get", this ); }

                    return this.g;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#G#set", this ); }

                    this.g = value;
                }
            },
            B: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#get", this ); }

                    return this.b;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#B#set", this ); }

                    this.b = value;
                }
            },
            A: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#get", this ); }

                    return this.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#A#set", this ); }

                    this.a = value;
                }
            },
            Path: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Path#get", this ); }

                    return this.path;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Path#set", this ); }

                    this.path = value;
                }
            },
            Sequence: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Sequence#get", this ); }

                    return this.sequence;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Sequence#set", this ); }

                    this.sequence = value;
                }
            },
            ParentMesh: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#get", this ); }

                    return this.parentMesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ParentMesh#set", this ); }

                    this.parentMesh = value;
                    if (value != null) {
                        this.bones = value.bones;
                        this.vertices = value.vertices;
                        this.worldVerticesLength = value.worldVerticesLength;
                        this.regionUVs = value.regionUVs;
                        this.triangles = value.triangles;
                        this.HullLength = value.HullLength;
                        this.Edges = value.Edges;
                        this.Width = value.Width;
                        this.Height = value.Height;
                    }
                }
            }
        },
        alias: [
            "Region", "Spine$IHasTextureRegion$Region",
            "R", "Spine$IHasTextureRegion$R",
            "G", "Spine$IHasTextureRegion$G",
            "B", "Spine$IHasTextureRegion$B",
            "A", "Spine$IHasTextureRegion$A",
            "Path", "Spine$IHasTextureRegion$Path",
            "Sequence", "Spine$IHasTextureRegion$Sequence",
            "UpdateRegion", "Spine$IHasTextureRegion$UpdateRegion"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#init", this ); }

                this.r = 1.0;
                this.g = 1.0;
                this.b = 1.0;
                this.a = 1.0;
            },
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
                if (this.parentMesh != null) {
                    throw new System.ArgumentException.$ctor1("Use newLinkedMesh to copy a linked mesh.");
                }
                this.region = other.region;
                this.path = other.path;
                this.r = other.r;
                this.g = other.g;
                this.b = other.b;
                this.a = other.a;
                this.regionUVs = System.Array.init(other.regionUVs.length, 0, System.Single);
                System.Array.copy(other.regionUVs, 0, this.regionUVs, 0, this.regionUVs.length);
                this.uvs = System.Array.init(other.uvs.length, 0, System.Single);
                System.Array.copy(other.uvs, 0, this.uvs, 0, this.uvs.length);
                this.triangles = System.Array.init(other.triangles.length, 0, System.Int32);
                System.Array.copy(other.triangles, 0, this.triangles, 0, this.triangles.length);
                this.hullLength = other.hullLength;
                this.sequence = ((other.sequence == null) ? null : new Spine.Sequence.ctor(other.sequence));
                if (other.Edges != null) {
                    this.Edges = System.Array.init(other.Edges.length, 0, System.Int32);
                    System.Array.copy(other.Edges, 0, this.Edges, 0, this.Edges.length);
                }
                this.Width = other.Width;
                this.Height = other.Height;
            }
        },
        methods: {
            /*Spine.MeshAttachment.UpdateRegion start.*/
            UpdateRegion: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#UpdateRegion", this ); }

                var regionUVs = this.regionUVs;
                if (this.uvs == null || this.uvs.length !== regionUVs.length) {
                    this.uvs = System.Array.init(regionUVs.length, 0, System.Single);
                }
                var uvs = this.uvs;
                var m = uvs.length;
                var u;
                var v;
                var width;
                var height;
                if (Bridge.is(this.region, Spine.AtlasRegion)) {
                    u = this.region.u;
                    v = this.region.v;
                    var region = Bridge.cast(this.region, Spine.AtlasRegion);
                    var textureWidth = this.region.width / (region.u2 - region.u);
                    var textureHeight = this.region.height / (region.v2 - region.v);
                    switch (region.degrees) {
                        case 90: 
                            {
                                u -= (region.originalHeight - region.offsetY - region.packedWidth) / textureWidth;
                                v -= (region.originalWidth - region.offsetX - region.packedHeight) / textureHeight;
                                width = region.originalHeight / textureWidth;
                                height = region.originalWidth / textureHeight;
                                for (var j = 0; j < m; j = (j + 2) | 0) {
                                    uvs[j] = u + regionUVs[((j + 1) | 0)] * width;
                                    uvs[((j + 1) | 0)] = v + (1.0 - regionUVs[j]) * height;
                                }
                                return;
                            }
                        case 180: 
                            {
                                u -= (region.originalWidth - region.offsetX - region.packedWidth) / textureWidth;
                                v -= region.offsetY / textureHeight;
                                width = region.originalWidth / textureWidth;
                                height = region.originalHeight / textureHeight;
                                for (var k = 0; k < m; k = (k + 2) | 0) {
                                    uvs[k] = u + (1.0 - regionUVs[k]) * width;
                                    uvs[((k + 1) | 0)] = v + (1.0 - regionUVs[((k + 1) | 0)]) * height;
                                }
                                return;
                            }
                        case 270: 
                            {
                                u -= region.offsetY / textureWidth;
                                v -= region.offsetX / textureHeight;
                                width = region.originalHeight / textureWidth;
                                height = region.originalWidth / textureHeight;
                                for (var l = 0; l < m; l = (l + 2) | 0) {
                                    uvs[l] = u + (1.0 - regionUVs[((l + 1) | 0)]) * width;
                                    uvs[((l + 1) | 0)] = v + regionUVs[l] * height;
                                }
                                return;
                            }
                    }
                    u -= region.offsetX / textureWidth;
                    v -= (region.originalHeight - region.offsetY - region.packedHeight) / textureHeight;
                    width = region.originalWidth / textureWidth;
                    height = region.originalHeight / textureHeight;
                } else if (this.region == null) {
                    u = ((v = 0.0));
                    width = ((height = 1.0));
                } else {
                    u = this.region.u;
                    v = this.region.v;
                    width = this.region.u2 - u;
                    height = this.region.v2 - v;
                }
                for (var i = 0; i < m; i = (i + 2) | 0) {
                    uvs[i] = u + regionUVs[i] * width;
                    uvs[((i + 1) | 0)] = v + regionUVs[((i + 1) | 0)] * height;
                }
            },
            /*Spine.MeshAttachment.UpdateRegion end.*/

            /*Spine.MeshAttachment.ComputeWorldVertices start.*/
            ComputeWorldVertices: function (slot, start, count, worldVertices, offset, stride) {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#ComputeWorldVertices", this ); }

                if (stride === void 0) { stride = 2; }
                if (this.sequence != null) {
                    this.sequence.Apply(slot, this);
                }
                Spine.VertexAttachment.prototype.ComputeWorldVertices.call(this, slot, start, count, worldVertices, offset, stride);
            },
            /*Spine.MeshAttachment.ComputeWorldVertices end.*/

            /*Spine.MeshAttachment.NewLinkedMesh start.*/
            NewLinkedMesh: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#NewLinkedMesh", this ); }

                var mesh = new Spine.MeshAttachment.$ctor1(this.Name);
                mesh.timelineAttachment = this.timelineAttachment;
                mesh.region = this.region;
                mesh.path = this.path;
                mesh.r = this.r;
                mesh.g = this.g;
                mesh.b = this.b;
                mesh.a = this.a;
                mesh.ParentMesh = ((this.parentMesh != null) ? this.parentMesh : this);
                if (mesh.Region != null) {
                    mesh.UpdateRegion();
                }
                return mesh;
            },
            /*Spine.MeshAttachment.NewLinkedMesh end.*/

            /*Spine.MeshAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.MeshAttachment#Copy", this ); }

                return (this.parentMesh != null) ? this.NewLinkedMesh() : new Spine.MeshAttachment.ctor(this);
            },
            /*Spine.MeshAttachment.Copy end.*/


        }
    });
    /*Spine.MeshAttachment end.*/

    /*Spine.PathAttachment start.*/
    Bridge.define("Spine.PathAttachment", {
        inherits: [Spine.VertexAttachment],
        fields: {
            lengths: null,
            closed: false,
            constantSpeed: false
        },
        props: {
            Lengths: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#get", this ); }

                    return this.lengths;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Lengths#set", this ); }

                    this.lengths = value;
                }
            },
            Closed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#get", this ); }

                    return this.closed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Closed#set", this ); }

                    this.closed = value;
                }
            },
            ConstantSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#get", this ); }

                    return this.constantSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ConstantSpeed#set", this ); }

                    this.constantSpeed = value;
                }
            }
        },
        ctors: {
            $ctor1: function (name) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#$ctor1", this ); }

                this.$initialize();
                Spine.VertexAttachment.$ctor1.call(this, name);
            },
            ctor: function (other) {
if ( TRACE ) { TRACE( "Spine.PathAttachment#ctor", this ); }

                this.$initialize();
                Spine.VertexAttachment.ctor.call(this, other);
                this.lengths = System.Array.init(other.lengths.length, 0, System.Single);
                System.Array.copy(other.lengths, 0, this.lengths, 0, this.lengths.length);
                this.closed = other.closed;
                this.constantSpeed = other.constantSpeed;
            }
        },
        methods: {
            /*Spine.PathAttachment.Copy start.*/
            Copy: function () {
if ( TRACE ) { TRACE( "Spine.PathAttachment#Copy", this ); }

                return new Spine.PathAttachment.ctor(this);
            },
            /*Spine.PathAttachment.Copy end.*/


        }
    });
    /*Spine.PathAttachment end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    Bridge.define("Spine.PathConstraintMixTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                ROTATE: 0,
                X: 0,
                Y: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#init", this ); }

                    this.ENTRIES = 4;
                    this.ROTATE = 1;
                    this.X = 2;
                    this.Y = 3;
                }
            }
        },
        fields: {
            pathConstraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#FrameEntries#get", this ); }

                    return 4;
                }
            },
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [18 + "|" + pathConstraintIndex]);
                this.pathConstraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintMixTimeline.SetFrame start.*/
            SetFrame: function (frame, time, mixRotate, mixX, mixY) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#SetFrame", this ); }

                frame = frame << 2;
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = mixRotate;
                this.frames[((frame + 2) | 0)] = mixX;
                this.frames[((frame + 3) | 0)] = mixY;
            },
            /*Spine.PathConstraintMixTimeline.SetFrame end.*/

            /*Spine.PathConstraintMixTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintMixTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mixRotate = constraint.data.mixRotate;
                            constraint.mixX = constraint.data.mixX;
                            constraint.mixY = constraint.data.mixY;
                            break;
                        case Spine.MixBlend.First: 
                            constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;
                            constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;
                            constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 4);
                var curveType = Bridge.Int.clip32(this.curves[i >> 2]);
                var rotate;
                var x;
                var y;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            rotate = frames[((i + 1) | 0)];
                            x = frames[((i + 2) | 0)];
                            y = frames[((i + 3) | 0)];
                            var t = (time - before) / (frames[((i + 4) | 0)] - before);
                            rotate += (frames[((((i + 4) | 0) + 1) | 0)] - rotate) * t;
                            x += (frames[((((i + 4) | 0) + 2) | 0)] - x) * t;
                            y += (frames[((((i + 4) | 0) + 3) | 0)] - y) * t;
                            break;
                        }
                    case 1: 
                        rotate = frames[((i + 1) | 0)];
                        x = frames[((i + 2) | 0)];
                        y = frames[((i + 3) | 0)];
                        break;
                    default: 
                        rotate = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        x = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        y = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        break;
                }
                if (blend === Spine.MixBlend.Setup) {
                    var data = constraint.data;
                    constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;
                    constraint.mixX = data.mixX + (x - data.mixX) * alpha;
                    constraint.mixY = data.mixY + (y - data.mixY) * alpha;
                } else {
                    constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;
                    constraint.mixX += (x - constraint.mixX) * alpha;
                    constraint.mixY += (y - constraint.mixY) * alpha;
                }
            },
            /*Spine.PathConstraintMixTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PowOut start.*/
    Bridge.define("Spine.PowOut", {
        inherits: [Spine.Pow],
        ctors: {
            ctor: function (power) {
if ( TRACE ) { TRACE( "Spine.PowOut#ctor", this ); }

                this.$initialize();
                Spine.Pow.ctor.call(this, power);
            }
        },
        methods: {
            /*Spine.PowOut.Apply$1 start.*/
            Apply$1: function (a) {
if ( TRACE ) { TRACE( "Spine.PowOut#Apply$1", this ); }

                return Math.pow(a - 1.0, this.Power) * ((this.Power % 2.0 !== 0.0) ? 1 : (-1)) + 1.0;
            },
            /*Spine.PowOut.Apply$1 end.*/


        },
        overloads: {
            "Apply(float)": "Apply$1"
        }
    });
    /*Spine.PowOut end.*/

    /*Spine.RGB2Timeline start.*/
    Bridge.define("Spine.RGB2Timeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#init", this ); }

                    this.ENTRIES = 7;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.R2 = 4;
                    this.G2 = 5;
                    this.B2 = 6;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#FrameEntries#get", this ); }

                    return 7;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [7 + "|" + slotIndex, 9 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGB2Timeline.SetFrame start.*/
            SetFrame: function (frame, time, r, g, b, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 7);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = r;
                this.frames[((frame + 2) | 0)] = g;
                this.frames[((frame + 3) | 0)] = b;
                this.frames[((frame + 4) | 0)] = r2;
                this.frames[((frame + 5) | 0)] = g2;
                this.frames[((frame + 6) | 0)] = b2;
            },
            /*Spine.RGB2Timeline.SetFrame end.*/

            /*Spine.RGB2Timeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGB2Timeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var setup2 = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup2.r;
                            slot.g = setup2.g;
                            slot.b = setup2.b;
                            slot.ClampColor();
                            slot.r2 = setup2.r2;
                            slot.g2 = setup2.g2;
                            slot.b2 = setup2.b2;
                            slot.ClampSecondColor();
                            break;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - setup2.r) * alpha;
                            slot.g += (slot.g - setup2.g) * alpha;
                            slot.b += (slot.b - setup2.b) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - setup2.r2) * alpha;
                            slot.g2 += (slot.g2 - setup2.g2) * alpha;
                            slot.b2 += (slot.b2 - setup2.b2) * alpha;
                            slot.ClampSecondColor();
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 7);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 7)) | 0)]);
                var r;
                var g;
                var b;
                var r2;
                var g2;
                var b2;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            r = frames[((i + 1) | 0)];
                            g = frames[((i + 2) | 0)];
                            b = frames[((i + 3) | 0)];
                            r2 = frames[((i + 4) | 0)];
                            g2 = frames[((i + 5) | 0)];
                            b2 = frames[((i + 6) | 0)];
                            var t = (time - before) / (frames[((i + 7) | 0)] - before);
                            r += (frames[((((i + 7) | 0) + 1) | 0)] - r) * t;
                            g += (frames[((((i + 7) | 0) + 2) | 0)] - g) * t;
                            b += (frames[((((i + 7) | 0) + 3) | 0)] - b) * t;
                            r2 += (frames[((((i + 7) | 0) + 4) | 0)] - r2) * t;
                            g2 += (frames[((((i + 7) | 0) + 5) | 0)] - g2) * t;
                            b2 += (frames[((((i + 7) | 0) + 6) | 0)] - b2) * t;
                            break;
                        }
                    case 1: 
                        r = frames[((i + 1) | 0)];
                        g = frames[((i + 2) | 0)];
                        b = frames[((i + 3) | 0)];
                        r2 = frames[((i + 4) | 0)];
                        g2 = frames[((i + 5) | 0)];
                        b2 = frames[((i + 6) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        g = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        b = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        r2 = this.GetBezierValue(time, i, 4, ((((curveType + 54) | 0) - 2) | 0));
                        g2 = this.GetBezierValue(time, i, 5, ((((curveType + 72) | 0) - 2) | 0));
                        b2 = this.GetBezierValue(time, i, 6, ((((curveType + 90) | 0) - 2) | 0));
                        break;
                }
                if (alpha === 1.0) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                } else {
                    var br;
                    var bg;
                    var bb;
                    var br2;
                    var bg2;
                    var bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        var setup = slot.data;
                        br = setup.r;
                        bg = setup.g;
                        bb = setup.b;
                        br2 = setup.r2;
                        bg2 = setup.g2;
                        bb2 = setup.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.r2 = br2 + (r2 - br2) * alpha;
                    slot.g2 = bg2 + (g2 - bg2) * alpha;
                    slot.b2 = bb2 + (b2 - bb2) * alpha;
                }
                slot.ClampColor();
                slot.ClampSecondColor();
            },
            /*Spine.RGB2Timeline.Apply end.*/


        }
    });
    /*Spine.RGB2Timeline end.*/

    /*Spine.RGBA2Timeline start.*/
    Bridge.define("Spine.RGBA2Timeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0,
                R2: 0,
                G2: 0,
                B2: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#init", this ); }

                    this.ENTRIES = 8;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                    this.R2 = 5;
                    this.G2 = 6;
                    this.B2 = 7;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#FrameEntries#get", this ); }

                    return 8;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [7 + "|" + slotIndex, 8 + "|" + slotIndex, 9 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBA2Timeline.SetFrame start.*/
            SetFrame: function (frame, time, r, g, b, a, r2, g2, b2) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#SetFrame", this ); }

                frame = frame << 3;
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = r;
                this.frames[((frame + 2) | 0)] = g;
                this.frames[((frame + 3) | 0)] = b;
                this.frames[((frame + 4) | 0)] = a;
                this.frames[((frame + 5) | 0)] = r2;
                this.frames[((frame + 6) | 0)] = g2;
                this.frames[((frame + 7) | 0)] = b2;
            },
            /*Spine.RGBA2Timeline.SetFrame end.*/

            /*Spine.RGBA2Timeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBA2Timeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            slot.a = setup.a;
                            slot.ClampColor();
                            slot.r2 = setup.r2;
                            slot.g2 = setup.g2;
                            slot.b2 = setup.b2;
                            slot.ClampSecondColor();
                            break;
                        case Spine.MixBlend.First: 
                            slot.r += (slot.r - setup.r) * alpha;
                            slot.g += (slot.g - setup.g) * alpha;
                            slot.b += (slot.b - setup.b) * alpha;
                            slot.a += (slot.a - setup.a) * alpha;
                            slot.ClampColor();
                            slot.r2 += (slot.r2 - setup.r2) * alpha;
                            slot.g2 += (slot.g2 - setup.g2) * alpha;
                            slot.b2 += (slot.b2 - setup.b2) * alpha;
                            slot.ClampSecondColor();
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 8);
                var curveType = Bridge.Int.clip32(this.curves[i >> 3]);
                var r;
                var g;
                var b;
                var a;
                var r2;
                var g2;
                var b2;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            r = frames[((i + 1) | 0)];
                            g = frames[((i + 2) | 0)];
                            b = frames[((i + 3) | 0)];
                            a = frames[((i + 4) | 0)];
                            r2 = frames[((i + 5) | 0)];
                            g2 = frames[((i + 6) | 0)];
                            b2 = frames[((i + 7) | 0)];
                            var t = (time - before) / (frames[((i + 8) | 0)] - before);
                            r += (frames[((((i + 8) | 0) + 1) | 0)] - r) * t;
                            g += (frames[((((i + 8) | 0) + 2) | 0)] - g) * t;
                            b += (frames[((((i + 8) | 0) + 3) | 0)] - b) * t;
                            a += (frames[((((i + 8) | 0) + 4) | 0)] - a) * t;
                            r2 += (frames[((((i + 8) | 0) + 5) | 0)] - r2) * t;
                            g2 += (frames[((((i + 8) | 0) + 6) | 0)] - g2) * t;
                            b2 += (frames[((((i + 8) | 0) + 7) | 0)] - b2) * t;
                            break;
                        }
                    case 1: 
                        r = frames[((i + 1) | 0)];
                        g = frames[((i + 2) | 0)];
                        b = frames[((i + 3) | 0)];
                        a = frames[((i + 4) | 0)];
                        r2 = frames[((i + 5) | 0)];
                        g2 = frames[((i + 6) | 0)];
                        b2 = frames[((i + 7) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        g = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        b = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        a = this.GetBezierValue(time, i, 4, ((((curveType + 54) | 0) - 2) | 0));
                        r2 = this.GetBezierValue(time, i, 5, ((((curveType + 72) | 0) - 2) | 0));
                        g2 = this.GetBezierValue(time, i, 6, ((((curveType + 90) | 0) - 2) | 0));
                        b2 = this.GetBezierValue(time, i, 7, ((((curveType + 108) | 0) - 2) | 0));
                        break;
                }
                if (alpha === 1.0) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                    slot.r2 = r2;
                    slot.g2 = g2;
                    slot.b2 = b2;
                } else {
                    var br;
                    var bg;
                    var bb;
                    var ba;
                    var br2;
                    var bg2;
                    var bb2;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                        br2 = slot.data.r2;
                        bg2 = slot.data.g2;
                        bb2 = slot.data.b2;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                        br2 = slot.r2;
                        bg2 = slot.g2;
                        bb2 = slot.b2;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.a = ba + (a - ba) * alpha;
                    slot.r2 = br2 + (r2 - br2) * alpha;
                    slot.g2 = bg2 + (g2 - bg2) * alpha;
                    slot.b2 = bb2 + (b2 - bb2) * alpha;
                }
                slot.ClampColor();
                slot.ClampSecondColor();
            },
            /*Spine.RGBA2Timeline.Apply end.*/


        }
    });
    /*Spine.RGBA2Timeline end.*/

    /*Spine.RGBATimeline start.*/
    Bridge.define("Spine.RGBATimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0,
                A: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#init", this ); }

                    this.ENTRIES = 5;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                    this.A = 4;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#FrameEntries#get", this ); }

                    return 5;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [7 + "|" + slotIndex, 8 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBATimeline.SetFrame start.*/
            SetFrame: function (frame, time, r, g, b, a) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 5);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = r;
                this.frames[((frame + 2) | 0)] = g;
                this.frames[((frame + 3) | 0)] = b;
                this.frames[((frame + 4) | 0)] = a;
            },
            /*Spine.RGBATimeline.SetFrame end.*/

            /*Spine.RGBATimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBATimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup.r;
                            slot.g = setup.g;
                            slot.b = setup.b;
                            slot.a = setup.a;
                            break;
                        case Spine.MixBlend.First: 
                            slot.r += (setup.r - slot.r) * alpha;
                            slot.g += (setup.g - slot.g) * alpha;
                            slot.b += (setup.b - slot.b) * alpha;
                            slot.a += (setup.a - slot.a) * alpha;
                            slot.ClampColor();
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 5);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 5)) | 0)]);
                var r;
                var g;
                var b;
                var a;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            r = frames[((i + 1) | 0)];
                            g = frames[((i + 2) | 0)];
                            b = frames[((i + 3) | 0)];
                            a = frames[((i + 4) | 0)];
                            var t = (time - before) / (frames[((i + 5) | 0)] - before);
                            r += (frames[((((i + 5) | 0) + 1) | 0)] - r) * t;
                            g += (frames[((((i + 5) | 0) + 2) | 0)] - g) * t;
                            b += (frames[((((i + 5) | 0) + 3) | 0)] - b) * t;
                            a += (frames[((((i + 5) | 0) + 4) | 0)] - a) * t;
                            break;
                        }
                    case 1: 
                        r = frames[((i + 1) | 0)];
                        g = frames[((i + 2) | 0)];
                        b = frames[((i + 3) | 0)];
                        a = frames[((i + 4) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        g = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        b = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        a = this.GetBezierValue(time, i, 4, ((((curveType + 54) | 0) - 2) | 0));
                        break;
                }
                if (alpha === 1.0) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                    slot.a = a;
                } else {
                    var br;
                    var bg;
                    var bb;
                    var ba;
                    if (blend === Spine.MixBlend.Setup) {
                        br = slot.data.r;
                        bg = slot.data.g;
                        bb = slot.data.b;
                        ba = slot.data.a;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                        ba = slot.a;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                    slot.a = ba + (a - ba) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.RGBATimeline.Apply end.*/


        }
    });
    /*Spine.RGBATimeline end.*/

    /*Spine.RGBTimeline start.*/
    Bridge.define("Spine.RGBTimeline", {
        inherits: [Spine.CurveTimeline,Spine.ISlotTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                R: 0,
                G: 0,
                B: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#init", this ); }

                    this.ENTRIES = 4;
                    this.R = 1;
                    this.G = 2;
                    this.B = 3;
                }
            }
        },
        fields: {
            slotIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#FrameEntries#get", this ); }

                    return 4;
                }
            },
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [7 + "|" + slotIndex]);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.RGBTimeline.SetFrame start.*/
            SetFrame: function (frame, time, r, g, b) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#SetFrame", this ); }

                frame = frame << 2;
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = r;
                this.frames[((frame + 2) | 0)] = g;
                this.frames[((frame + 3) | 0)] = b;
            },
            /*Spine.RGBTimeline.SetFrame end.*/

            /*Spine.RGBTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RGBTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var setup2 = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.r = setup2.r;
                            slot.g = setup2.g;
                            slot.b = setup2.b;
                            break;
                        case Spine.MixBlend.First: 
                            slot.r += (setup2.r - slot.r) * alpha;
                            slot.g += (setup2.g - slot.g) * alpha;
                            slot.b += (setup2.b - slot.b) * alpha;
                            slot.ClampColor();
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 4);
                var curveType = Bridge.Int.clip32(this.curves[i >> 2]);
                var r;
                var g;
                var b;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            r = frames[((i + 1) | 0)];
                            g = frames[((i + 2) | 0)];
                            b = frames[((i + 3) | 0)];
                            var t = (time - before) / (frames[((i + 4) | 0)] - before);
                            r += (frames[((((i + 4) | 0) + 1) | 0)] - r) * t;
                            g += (frames[((((i + 4) | 0) + 2) | 0)] - g) * t;
                            b += (frames[((((i + 4) | 0) + 3) | 0)] - b) * t;
                            break;
                        }
                    case 1: 
                        r = frames[((i + 1) | 0)];
                        g = frames[((i + 2) | 0)];
                        b = frames[((i + 3) | 0)];
                        break;
                    default: 
                        r = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        g = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        b = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        break;
                }
                if (alpha === 1.0) {
                    slot.r = r;
                    slot.g = g;
                    slot.b = b;
                } else {
                    var br;
                    var bg;
                    var bb;
                    if (blend === Spine.MixBlend.Setup) {
                        var setup = slot.data;
                        br = setup.r;
                        bg = setup.g;
                        bb = setup.b;
                    } else {
                        br = slot.r;
                        bg = slot.g;
                        bb = slot.b;
                    }
                    slot.r = br + (r - br) * alpha;
                    slot.g = bg + (g - bg) * alpha;
                    slot.b = bb + (b - bb) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.RGBTimeline.Apply end.*/


        }
    });
    /*Spine.RGBTimeline end.*/

    /*Spine.TransformConstraintTimeline start.*/
    Bridge.define("Spine.TransformConstraintTimeline", {
        inherits: [Spine.CurveTimeline],
        statics: {
            fields: {
                ENTRIES: 0,
                ROTATE: 0,
                X: 0,
                Y: 0,
                SCALEX: 0,
                SCALEY: 0,
                SHEARY: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#init", this ); }

                    this.ENTRIES = 7;
                    this.ROTATE = 1;
                    this.X = 2;
                    this.Y = 3;
                    this.SCALEX = 4;
                    this.SCALEY = 5;
                    this.SHEARY = 6;
                }
            }
        },
        fields: {
            transformConstraintIndex: 0
        },
        props: {
            FrameEntries: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#FrameEntries#get", this ); }

                    return 7;
                }
            },
            TransformConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#TransformConstraintIndex#get", this ); }

                    return this.transformConstraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline.ctor.call(this, frameCount, bezierCount, [15 + "|" + transformConstraintIndex]);
                this.transformConstraintIndex = transformConstraintIndex;
            }
        },
        methods: {
            /*Spine.TransformConstraintTimeline.SetFrame start.*/
            SetFrame: function (frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#SetFrame", this ); }

                frame = Bridge.Int.mul(frame, 7);
                this.frames[frame] = time;
                this.frames[((frame + 1) | 0)] = mixRotate;
                this.frames[((frame + 2) | 0)] = mixX;
                this.frames[((frame + 3) | 0)] = mixY;
                this.frames[((frame + 4) | 0)] = mixScaleX;
                this.frames[((frame + 5) | 0)] = mixScaleY;
                this.frames[((frame + 6) | 0)] = mixShearY;
            },
            /*Spine.TransformConstraintTimeline.SetFrame end.*/

            /*Spine.TransformConstraintTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.transformConstraints.Items)[this.transformConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var data2 = constraint.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.mixRotate = data2.mixRotate;
                            constraint.mixX = data2.mixX;
                            constraint.mixY = data2.mixY;
                            constraint.mixScaleX = data2.mixScaleX;
                            constraint.mixScaleY = data2.mixScaleY;
                            constraint.mixShearY = data2.mixShearY;
                            break;
                        case Spine.MixBlend.First: 
                            constraint.mixRotate += (data2.mixRotate - constraint.mixRotate) * alpha;
                            constraint.mixX += (data2.mixX - constraint.mixX) * alpha;
                            constraint.mixY += (data2.mixY - constraint.mixY) * alpha;
                            constraint.mixScaleX += (data2.mixScaleX - constraint.mixScaleX) * alpha;
                            constraint.mixScaleY += (data2.mixScaleY - constraint.mixScaleY) * alpha;
                            constraint.mixShearY += (data2.mixShearY - constraint.mixShearY) * alpha;
                            break;
                    }
                } else {
                    var rotate = { };
                    var x = { };
                    var y = { };
                    var scaleX = { };
                    var scaleY = { };
                    var shearY = { };
                    this.GetCurveValue(rotate, x, y, scaleX, scaleY, shearY, time);
                    if (blend === Spine.MixBlend.Setup) {
                        var data = constraint.data;
                        constraint.mixRotate = data.mixRotate + (rotate.v - data.mixRotate) * alpha;
                        constraint.mixX = data.mixX + (x.v - data.mixX) * alpha;
                        constraint.mixY = data.mixY + (y.v - data.mixY) * alpha;
                        constraint.mixScaleX = data.mixScaleX + (scaleX.v - data.mixScaleX) * alpha;
                        constraint.mixScaleY = data.mixScaleY + (scaleY.v - data.mixScaleY) * alpha;
                        constraint.mixShearY = data.mixShearY + (shearY.v - data.mixShearY) * alpha;
                    } else {
                        constraint.mixRotate += (rotate.v - constraint.mixRotate) * alpha;
                        constraint.mixX += (x.v - constraint.mixX) * alpha;
                        constraint.mixY += (y.v - constraint.mixY) * alpha;
                        constraint.mixScaleX += (scaleX.v - constraint.mixScaleX) * alpha;
                        constraint.mixScaleY += (scaleY.v - constraint.mixScaleY) * alpha;
                        constraint.mixShearY += (shearY.v - constraint.mixShearY) * alpha;
                    }
                }
            },
            /*Spine.TransformConstraintTimeline.Apply end.*/

            /*Spine.TransformConstraintTimeline.GetCurveValue start.*/
            GetCurveValue: function (rotate, x, y, scaleX, scaleY, shearY, time) {
if ( TRACE ) { TRACE( "Spine.TransformConstraintTimeline#GetCurveValue", this ); }

                var frames = this.frames;
                var i = Spine.Timeline.Search$1(frames, time, 7);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 7)) | 0)]);
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            rotate.v = frames[((i + 1) | 0)];
                            x.v = frames[((i + 2) | 0)];
                            y.v = frames[((i + 3) | 0)];
                            scaleX.v = frames[((i + 4) | 0)];
                            scaleY.v = frames[((i + 5) | 0)];
                            shearY.v = frames[((i + 6) | 0)];
                            var t = (time - before) / (frames[((i + 7) | 0)] - before);
                            rotate.v += (frames[((((i + 7) | 0) + 1) | 0)] - rotate.v) * t;
                            x.v += (frames[((((i + 7) | 0) + 2) | 0)] - x.v) * t;
                            y.v += (frames[((((i + 7) | 0) + 3) | 0)] - y.v) * t;
                            scaleX.v += (frames[((((i + 7) | 0) + 4) | 0)] - scaleX.v) * t;
                            scaleY.v += (frames[((((i + 7) | 0) + 5) | 0)] - scaleY.v) * t;
                            shearY.v += (frames[((((i + 7) | 0) + 6) | 0)] - shearY.v) * t;
                            break;
                        }
                    case 1: 
                        rotate.v = frames[((i + 1) | 0)];
                        x.v = frames[((i + 2) | 0)];
                        y.v = frames[((i + 3) | 0)];
                        scaleX.v = frames[((i + 4) | 0)];
                        scaleY.v = frames[((i + 5) | 0)];
                        shearY.v = frames[((i + 6) | 0)];
                        break;
                    default: 
                        rotate.v = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        x.v = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        y.v = this.GetBezierValue(time, i, 3, ((((curveType + 36) | 0) - 2) | 0));
                        scaleX.v = this.GetBezierValue(time, i, 4, ((((curveType + 54) | 0) - 2) | 0));
                        scaleY.v = this.GetBezierValue(time, i, 5, ((((curveType + 72) | 0) - 2) | 0));
                        shearY.v = this.GetBezierValue(time, i, 6, ((((curveType + 90) | 0) - 2) | 0));
                        break;
                }
            },
            /*Spine.TransformConstraintTimeline.GetCurveValue end.*/


        }
    });
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset,Spine.Unity.ISpineComponent],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                var $t;
                if (!(this.skeletonDataAsset == null)) {
                    this.animation = ($t = this.skeletonDataAsset.GetSkeletonData(true)) != null ? $t.FindAnimation(this.animationName) : null;
                    if (this.animation == null) {
                        UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                    }
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.ISpineComponent,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (this.valid) {
                    this.UpdateReferences();
                }
            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);
                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;
                    var slot = skeleton.FindSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.Data.Index;
                        this.bone = slot.Bone;
                        this.point = Bridge.as(skeleton.GetAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;
                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }
                var worldPos = Bridge.getDefaultValue(UnityEngine.Vector2);
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.ComputeWorldRotation(this.bone);
                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * (0.0174532924);
                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var i = transformParent.localToWorldMatrix.$clone();
                        if (i.e00 * i.e11 - i.e01 * i.e10 < 0.0) {
                            rotation = 0.0 - rotation;
                        }
                    }
                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }
                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.Skeleton.ScaleX * this.bone.Skeleton.ScaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.ISpineComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            updateMode: 0,
            updateWhenInvisible: 0,
            separatorSlotNames: null,
            separatorSlots: null,
            zSpacing: 0,
            useClipping: false,
            immutableTriangles: false,
            pmaVertexColors: false,
            clearStateOnDisable: false,
            tintBlack: false,
            singleSubmesh: false,
            fixDrawOrder: false,
            addNormals: false,
            calculateTangents: false,
            maskInteraction: 0,
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            OnPostProcessVertices: null,
            OnRebuild: null,
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                }
            },
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;
                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                if (Bridge.staticEquals(this.generateMeshOverride, null) || !this.disableRenderingOnOverride) {
                    this.updateMode = this.updateWhenInvisible;
                }
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.SetToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.currentInstructions.Clear();
                this.rendererBuffers.Clear();
                this.meshGenerator.Begin();
                this.skeleton = null;
                this.valid = false;
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData != null) {
                    this.valid = true;
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                        this.meshFilter = Bridge.ensureBaseProperty(this, "gameObject").$UnityEngine$Component$gameObject.AddComponent(UnityEngine.MeshFilter);
                    }
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.rendererBuffers.Initialize();
                    this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.ScaleX = ((!this.initialFlipX) ? 1 : (-1)), $t.ScaleY = ((!this.initialFlipY) ? 1 : (-1)), $t);
                    if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                        this.skeleton.SetSkin$1(this.initialSkinName);
                    }
                    this.separatorSlots.clear();
                    for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                        this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                    }
                    var updateModeSaved = this.updateMode;
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                    this.skeleton.UpdateWorldTransform();
                    this.LateUpdate();
                    this.updateMode = updateModeSaved;
                    if (!Bridge.staticEquals(this.OnRebuild, null)) {
                        this.OnRebuild(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (this.valid && this.updateMode === Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh();
                var updateTriangles;
                if (this.singleSubmesh) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0].$clone(), updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }
                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);
                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);
                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && this.maskMaterials.AnyMaterialCreated) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }
                this.meshGenerator.FillLateVertexData(currentMesh);
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);
                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }
                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (!System.String.isNullOrEmpty(startsWith)) {
                    this.FindAndApplySeparatorSlots(function (slotName) {
                        return System.String.startsWith(slotName, startsWith);
                    }, clearExistingSeparators, updateStringArray);
                }
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null) || !this.valid) {
                    return;
                }
                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }
                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot2 = $t.Current;
                        if (slotNamePredicate(slot2.Data.Name)) {
                            this.separatorSlots.add(slot2);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (!updateStringArray) {
                    return;
                }
                var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                try {
                    while ($t1.moveNext()) {
                        var slot = $t1.Current;
                        var slotName = slot.Data.Name;
                        if (slotNamePredicate(slotName)) {
                            detectedSeparatorNames.add(slotName);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                if (!clearExistingSeparators) {
                    var originalNames = this.separatorSlotNames;
                    var array = originalNames;
                    $t2 = Bridge.getEnumerator(array);
                    try {
                        while ($t2.moveNext()) {
                            var originalName = $t2.Current;
                            detectedSeparatorNames.add(originalName);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }
                }
                this.separatorSlotNames = detectedSeparatorNames.ToArray();
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }
                this.separatorSlots.clear();
                var i = 0;
                for (var j = this.separatorSlotNames.length; i < j; i = (i + 1) | 0) {
                    var slot = this.skeleton.FindSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;
                if (UnityEngine.Application.isPlaying && this.maskInteraction !== 0 && this.maskMaterials.materialsMaskDisabled.length === 0) {
                    this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                }
                if (this.maskMaterials.materialsMaskDisabled.length !== 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if ((this.maskMaterials.materialsInsideMask.length !== 0 && !(($t1 = this.maskMaterials.materialsInsideMask)[0] == null)) || this.InitSpriteMaskMaterialsInsideMask()) {
                        this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                    }
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask && ((this.maskMaterials.materialsOutsideMask.length !== 0 && !(($t2 = this.maskMaterials.materialsOutsideMask)[0] == null)) || this.InitSpriteMaskMaterialsOutsideMask())) {
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(UnityEngine.Rendering.CompareFunction.LessEqual, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(UnityEngine.Rendering.CompareFunction.Greater, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }

                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var originalMaterial = originalMaterials[i];
                    if (originalMaterial == null) {
                        materialsToFill.v[i] = null;
                        continue;
                    }
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterial);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#HandleOnDemandLoading", this ); }

                var $t, $t1, $t2;
                var atlasAssets = this.skeletonDataAsset.atlasAssets;
                $t = Bridge.getEnumerator(atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode === Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            continue;
                        }
                        atlasAsset.BeginCustomTextureLoading();
                        var i = 0;
                        for (var count = this.meshRenderer.sharedMaterials.length; i < count; i = (i + 1) | 0) {
                            var overrideMaterial = { v : null };
                            atlasAsset.RequireTexturesLoaded(($t1 = this.meshRenderer.sharedMaterials)[i], overrideMaterial);
                            if (overrideMaterial.v != null) {
                                ($t2 = this.meshRenderer.sharedMaterials)[i] = overrideMaterial.v;
                            }
                        }
                        atlasAsset.EndCustomTextureLoading();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }
                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }
                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        if (!hasPerRendererBlock) {
                            this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                        }
                        this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                        this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);
                        ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.ISpineComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static start.*/
                SetRectTransformSize$1: function (target, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize$1", this ); }

                    Spine.Unity.SkeletonGraphic.SetRectTransformSize(target.rectTransform, size.$clone());
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (targetRectTransform, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize", this ); }

                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(targetRectTransform.parent, null)) {
                        var parentTransform = targetRectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = targetRectTransform.anchorMax.$clone().sub( targetRectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    targetRectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            meshScale: 0,
            layoutScaleMode: 0,
            referenceSize: null,
            referenceScale: 0,
            updateMode: 0,
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            separatorSlotNames: null,
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            updateSeparatorPartScale: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            OnRebuild: null,
            OnInstructionsPrepared: null,
            OnMeshAndMaterialsUpdated: null,
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            MeshScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshScale#get", this ); }

                    return this.meshScale;
                }
            },
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    this.Initialize(false);
                    return (this.skeleton == null) ? null : this.skeleton.Data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get", this ); }

                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get", this ); }

                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get", this ); }

                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.referenceSize = new UnityEngine.Vector2();
                this.timeScale = 1.0;
                this.meshScale = 1.0;
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.referenceScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.updateSeparatorPartScale = false;
                this.wasUpdatedAfterInit = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            addAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer", this ); }

                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            removeAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer", this ); }

                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            addAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers", this ); }

                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            removeAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers", this ); }

                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));
                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    if (this.IsValid) {
                        this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (this.IsValid && !this.canvasRenderer.cull) {
                    if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                        this.PrepareInstructionsAndRenderers(true);
                        this.UpdateMeshToInstructions();
                    }
                    if (this.allowMultipleCanvasRenderers) {
                        this.canvasRenderer.Clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }

                if (!this.freeze && this.updateTiming === Spine.Unity.UpdateTiming.InUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }
                this.wasUpdatedAfterInit = true;
                if (this.updateMode >= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.UpdateAnimationStatus(deltaTime);
                    if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                        this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    } else {
                        this.ApplyAnimation();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#FixedUpdate", this ); }

                if (!this.freeze && this.updateTiming === Spine.Unity.UpdateTiming.InFixedUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }
                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }
                this.skeleton.UpdateWorldTransform();
                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }
                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                if (!this.IsValid) {
                    return;
                }
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0.0);
                }
                if (!this.freeze && this.updateMode === Spine.Unity.UpdateMode.FullUpdate) {
                    if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate) {
                        this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                    }
                    this.UpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }
                this.separatorSlots.clear();
                var i = 0;
                for (var j = this.separatorSlotNames.length; i < j; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (!(Bridge.referenceEquals(slotName, ""))) {
                        var slot = this.skeleton.FindSlot(slotName);
                        if (slot != null) {
                            this.separatorSlots.add(slot);
                        }
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0.0);
                }
                this.UpdateMesh();
                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                }
                return this.MatchRectTransformMultipleRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0 || pc.Vec3.equals( mesh.bounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = Bridge.getDefaultValue(UnityEngine.Bounds);
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }
                    var mesh = ($t = this.meshes.Items)[i];
                    if (!(mesh == null) && mesh.vertexCount !== 0) {
                        mesh.RecalculateBounds();
                        var bounds = mesh.bounds;
                        if (anyBoundsAdded) {
                            combinedBounds.add( bounds );
                            continue;
                        }
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }
                if (!anyBoundsAdded || pc.Vec3.equals( combinedBounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t, $t1;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - center.x / size.x, 0.5 - center.y / size.y );
                Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(this, UnityEngine.Vector2.FromVector3(size.$clone()));
                this.rectTransform.pivot = p.$clone();
                $t = Bridge.getEnumerator(this.separatorParts);
                try {
                    while ($t.moveNext()) {
                        var separatorPart = $t.Current;
                        var separatorTransform = separatorPart.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(separatorTransform)) {
                            Spine.Unity.SkeletonGraphic.SetRectTransformSize(separatorTransform, UnityEngine.Vector2.FromVector3(size.$clone()));
                            separatorTransform.pivot = p.$clone();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t1.moveNext()) {
                        var submeshGraphic = $t1.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(submeshGraphic, UnityEngine.Vector2.FromVector3(size.$clone()));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                this.referenceSize = UnityEngine.Vector2.FromVector3(size.$clone());
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                            UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                        } else {
                            UnityEngine.Object.Destroy(canvasRenderer.gameObject);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if ((this.IsValid && !overwrite) || this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null || this.skeletonDataAsset.atlasAssets.length === 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }
                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.ScaleX = ((!this.initialFlipX) ? 1 : (-1)), $t1.ScaleY = ((!this.initialFlipY) ? 1 : (-1)), $t1);
                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture);
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.SetSkin$1(this.initialSkinName);
                }
                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.FindSlot(this.separatorSlotNames[i]));
                }
                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }
                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }
                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.startingLoop);
                    }
                }
                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots && this.separatorSlots.Count > 0);
                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions", this ); }

                if (this.IsValid && this.currentInstructions.rawVertexCount >= 0) {
                    Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());
                    if (!this.allowMultipleCanvasRenderers) {
                        this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                    } else {
                        this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                        this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                    }
                    if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                        this.OnMeshAndMaterialsUpdated(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();
                if (currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0].$clone(), updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }
                this.meshScale = ((UnityEngine.Component.op_Equality(this.canvas, null)) ? 100.0 : this.canvas.referencePixelsPerUnit);
                if (this.layoutScaleMode !== 0) {
                    this.meshScale *= this.referenceScale;
                    var flag = true;
                    this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                }
                this.meshGenerator.ScaleVertexData(this.meshScale);
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }
                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);
                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }
                var assignAtCanvasRenderer = Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride;
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }
                var assignTexture = false;
                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            assignTexture = true;
                        }
                    }
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (assignTexture) {
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers", this ); }

                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0;
                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        if (submeshMaterial == null) {
                            usedMaterialItems[i] = null;
                            usedTextureItems[i] = null;
                            continue;
                        }
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                            continue;
                        }
                        var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                        var usedMaterial2 = this.materialForRendering;
                        if (blendMode === Spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                            usedMaterial2 = this.additiveMaterial;
                        } else if (blendMode === Spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                            usedMaterial2 = this.multiplyMaterial;
                        } else if (blendMode === Spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                            usedMaterial2 = this.screenMaterial;
                        }
                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial2);
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial)) {
                            usedMaterial.v = this.material;
                        }
                        var usedTexture = { };
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }
                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                this.meshScale = ((UnityEngine.Component.op_Equality(this.canvas, null)) ? 100.0 : this.canvas.referencePixelsPerUnit);
                if (this.layoutScaleMode !== 0) {
                    this.meshScale *= this.referenceScale;
                    var flag = true;
                    this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                }
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0;
                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var j = 0; j < submeshCount; j = (j + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[j].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem.$clone());
                    var targetMesh = meshesItems[j];
                    this.meshGenerator.ScaleVertexData(this.meshScale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);
                    var canvasRenderer = this.canvasRenderers.getItem(j);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }
                    var submeshGraphic = this.submeshGraphics.getItem(j);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[j]);
                        if ((materialBlendMode === Spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === Spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh && mainCullTransparentMesh;
                    }
                    canvasRenderer.materialCount = 1;
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var canvasRenderer2 = this.canvasRenderers.getItem(i);
                        canvasRenderer2.SetMaterial$1(usedMaterialItems[i], usedTextureItems[i]);
                    }
                }
                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HandleOnDemandLoading", this ); }

                var $t, $t1;
                var atlasAssets = this.skeletonDataAsset.atlasAssets;
                $t = Bridge.getEnumerator(atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode === Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            continue;
                        }
                        atlasAsset.BeginCustomTextureLoading();
                        if (!this.allowMultipleCanvasRenderers) {
                            var loadedTexture2 = { v : null };
                            atlasAsset.RequireTextureLoaded(this.mainTexture, loadedTexture2, null);
                            if (UnityEngine.Object.op_Implicit(loadedTexture2.v)) {
                                this.baseTexture = loadedTexture2.v;
                            }
                        } else {
                            var textureItems = this.usedTextures.Items;
                            var i = 0;
                            for (var count = this.usedTextures.Count; i < count; i = (i + 1) | 0) {
                                var loadedTexture = { v : null };
                                atlasAsset.RequireTextureLoaded(textureItems[i], loadedTexture, null);
                                if (UnityEngine.Object.op_Implicit(loadedTexture.v)) {
                                    ($t1 = this.usedTextures.Items)[i] = loadedTexture.v;
                                }
                            }
                        }
                        atlasAsset.EndCustomTextureLoading();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    submeshGraphic.rectTransform.pivot = this.rectTransform.pivot.$clone();
                    submeshGraphic.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    submeshGraphic.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    submeshGraphic.rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects", this ); }

                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }
                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);
                var parent = ((this.separatorParts.Count === 0) ? this.transform : this.separatorParts.getItem(0));
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        var separatorPart = this.separatorParts.getItem(p);
                        if (!(UnityEngine.Component.op_Equality(separatorPart, null))) {
                            separatorPart.position = this.transform.position.$clone();
                            separatorPart.rotation = this.transform.rotation.$clone();
                        }
                    }
                }
                if (this.updateSeparatorPartScale) {
                    var targetScale = this.transform.lossyScale.$clone();
                    for (var p2 = 0; p2 < this.separatorParts.Count; p2 = (p2 + 1) | 0) {
                        var separatorPart2 = this.separatorParts.getItem(p2);
                        if (!(UnityEngine.Component.op_Equality(separatorPart2, null))) {
                            var partParent = separatorPart2.parent;
                            var parentScale = ((UnityEngine.Component.op_Equality(partParent, null)) ? new pc.Vec3( 1, 1, 1 ) : partParent.lossyScale.$clone());
                            separatorPart2.localScale = new pc.Vec3( (parentScale.x === 0.0) ? 1.0 : (targetScale.x / parentScale.x), (parentScale.y === 0.0) ? 1.0 : (targetScale.y / parentScale.y), (parentScale.z === 0.0) ? 1.0 : (targetScale.z / parentScale.z) );
                        }
                    }
                }
                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(canvasRenderer, null)) {
                        if (i >= this.usedRenderersCount) {
                            canvasRenderer.gameObject.SetActive(true);
                        }
                        if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform) && !isInRebuild) {
                            canvasRenderer.transform.SetParent(parent.transform, false);
                        }
                        canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    }
                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Inequality(submeshGraphic, null)) {
                        var dstTransform = submeshGraphic.rectTransform;
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    }
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount", this ); }

                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount !== 1) {
                    var currentCount = this.separatorParts.Count;
                    for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                        var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", "Part", Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                        go.transform.SetParent(this.transform, false);
                        var dstTransform = go.transform.GetComponent(UnityEngine.RectTransform);
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                        this.separatorParts.add(go.transform);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0;
                    for (var j = 0; j < this.canvasRenderers.Count; j = (j + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(j);
                        if (System.String.contains(canvasRenderer.transform.parent.name,"Part")) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i = 0; i < this.separatorParts.Count; i = (i + 1) | 0) {
                    var isUsed = i < usedCount;
                    this.separatorParts.getItem(i).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLayoutScale", this ); }

                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                switch (mode) {
                    case Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent: 
                        mode = ((!(frameAspect > referenceAspect)) ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth);
                        break;
                    case Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent: 
                        mode = ((frameAspect > referenceAspect) ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth);
                        break;
                }
                switch (mode) {
                    case Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight: 
                        return currentSize.x / this.referenceSize.x;
                    case Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth: 
                        return currentSize.y / this.referenceSize.y;
                    default: 
                        return 1.0;
                }
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetCurrentRectSize", this ); }

                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.AlphaTimeline start.*/
    Bridge.define("Spine.AlphaTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.ISlotTimeline],
        fields: {
            slotIndex: 0
        },
        props: {
            SlotIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#SlotIndex#get", this ); }

                    return this.slotIndex;
                }
            }
        },
        alias: ["SlotIndex", "Spine$ISlotTimeline$SlotIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, slotIndex) {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 8 + "|" + slotIndex);
                this.slotIndex = slotIndex;
            }
        },
        methods: {
            /*Spine.AlphaTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.AlphaTimeline#Apply", this ); }

                var $t;
                var slot = ($t = skeleton.slots.Items)[this.slotIndex];
                if (!slot.bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    var setup = slot.data;
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            slot.a = setup.a;
                            break;
                        case Spine.MixBlend.First: 
                            slot.a += (setup.a - slot.a) * alpha;
                            slot.ClampColor();
                            break;
                    }
                    return;
                }
                var a = this.GetCurveValue(time);
                if (alpha === 1.0) {
                    slot.a = a;
                } else {
                    if (blend === Spine.MixBlend.Setup) {
                        slot.a = slot.data.a;
                    }
                    slot.a += (a - slot.a) * alpha;
                }
                slot.ClampColor();
            },
            /*Spine.AlphaTimeline.Apply end.*/


        }
    });
    /*Spine.AlphaTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    Bridge.define("Spine.PathConstraintPositionTimeline", {
        inherits: [Spine.CurveTimeline1],
        fields: {
            pathConstraintIndex: 0
        },
        props: {
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 16 + "|" + pathConstraintIndex);
                this.pathConstraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintPositionTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintPositionTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                if (time < this.frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.position = constraint.data.position;
                            break;
                        case Spine.MixBlend.First: 
                            constraint.position += (constraint.data.position - constraint.position) * alpha;
                            break;
                    }
                } else {
                    var position = this.GetCurveValue(time);
                    if (blend === Spine.MixBlend.Setup) {
                        constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;
                    } else {
                        constraint.position += (position - constraint.position) * alpha;
                    }
                }
            },
            /*Spine.PathConstraintPositionTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    Bridge.define("Spine.PathConstraintSpacingTimeline", {
        inherits: [Spine.CurveTimeline1],
        fields: {
            pathConstraintIndex: 0
        },
        props: {
            PathConstraintIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#PathConstraintIndex#get", this ); }

                    return this.pathConstraintIndex;
                }
            }
        },
        ctors: {
            ctor: function (frameCount, bezierCount, pathConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 17 + "|" + pathConstraintIndex);
                this.pathConstraintIndex = pathConstraintIndex;
            }
        },
        methods: {
            /*Spine.PathConstraintSpacingTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, events, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.PathConstraintSpacingTimeline#Apply", this ); }

                var $t;
                var constraint = ($t = skeleton.pathConstraints.Items)[this.pathConstraintIndex];
                if (!constraint.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            constraint.spacing = constraint.data.spacing;
                            break;
                        case Spine.MixBlend.First: 
                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
                            break;
                    }
                } else {
                    var spacing = this.GetCurveValue(time);
                    if (blend === Spine.MixBlend.Setup) {
                        constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;
                    } else {
                        constraint.spacing += (spacing - constraint.spacing) * alpha;
                    }
                }
            },
            /*Spine.PathConstraintSpacingTimeline.Apply end.*/


        }
    });
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.RotateTimeline start.*/
    Bridge.define("Spine.RotateTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 0 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.RotateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.RotateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                if (time < this.frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.rotation = bone.data.rotation;
                            break;
                        case Spine.MixBlend.First: 
                            bone.rotation += (bone.data.rotation - bone.rotation) * alpha;
                            break;
                    }
                    return;
                }
                var r = this.GetCurveValue(time);
                switch (blend) {
                    default: 
                        return;
                    case Spine.MixBlend.Setup: 
                        bone.rotation = bone.data.rotation + r * alpha;
                        return;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        r += bone.data.rotation - bone.rotation;
                        break;
                    case Spine.MixBlend.Add: 
                        break;
                }
                bone.rotation += r * alpha;
            },
            /*Spine.RotateTimeline.Apply end.*/


        }
    });
    /*Spine.RotateTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    Bridge.define("Spine.ScaleTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, 3 + "|" + boneIndex, 4 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                            break;
                        case Spine.MixBlend.First: 
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 3);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 3)) | 0)]);
                var x;
                var y;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            x = frames[((i + 1) | 0)];
                            y = frames[((i + 2) | 0)];
                            var t = (time - before) / (frames[((i + 3) | 0)] - before);
                            x += (frames[((((i + 3) | 0) + 1) | 0)] - x) * t;
                            y += (frames[((((i + 3) | 0) + 2) | 0)] - y) * t;
                            break;
                        }
                    case 1: 
                        x = frames[((i + 1) | 0)];
                        y = frames[((i + 2) | 0)];
                        break;
                    default: 
                        x = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        y = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        break;
                }
                x *= bone.data.scaleX;
                y *= bone.data.scaleY;
                if (alpha === 1.0) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleX += x - bone.data.scaleX;
                        bone.scaleY += y - bone.data.scaleY;
                    } else {
                        bone.scaleX = x;
                        bone.scaleY = y;
                    }
                } else if (direction === Spine.MixDirection.Out) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var bx = bone.data.scaleX;
                                var by = bone.data.scaleY;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var bx1 = bone.scaleX;
                                var by1 = bone.scaleY;
                                bone.scaleX = bx1 + (Math.abs(x) * Bridge.Int.sign(bx1) - bx1) * alpha;
                                bone.scaleY = by1 + (Math.abs(y) * Bridge.Int.sign(by1) - by1) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleX += (x - bone.data.scaleX) * alpha;
                            bone.scaleY += (y - bone.data.scaleY) * alpha;
                            break;
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var bx2 = Math.abs(bone.data.scaleX) * Bridge.Int.sign(x);
                                var by2 = Math.abs(bone.data.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx2 + (x - bx2) * alpha;
                                bone.scaleY = by2 + (y - by2) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var bx3 = Math.abs(bone.scaleX) * Bridge.Int.sign(x);
                                var by3 = Math.abs(bone.scaleY) * Bridge.Int.sign(y);
                                bone.scaleX = bx3 + (x - bx3) * alpha;
                                bone.scaleY = by3 + (y - by3) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleX += (x - bone.data.scaleX) * alpha;
                            bone.scaleY += (y - bone.data.scaleY) * alpha;
                            break;
                    }
                }
            },
            /*Spine.ScaleTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleTimeline end.*/

    /*Spine.ScaleXTimeline start.*/
    Bridge.define("Spine.ScaleXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 3 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleX = bone.data.scaleX;
                            break;
                        case Spine.MixBlend.First: 
                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                            break;
                    }
                    return;
                }
                var x = this.GetCurveValue(time) * bone.data.scaleX;
                if (alpha === 1.0) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleX += x - bone.data.scaleX;
                    } else {
                        bone.scaleX = x;
                    }
                } else if (direction === Spine.MixDirection.Out) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var bx = bone.data.scaleX;
                                bone.scaleX = bx + (Math.abs(x) * Bridge.Int.sign(bx) - bx) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var bx1 = bone.scaleX;
                                bone.scaleX = bx1 + (Math.abs(x) * Bridge.Int.sign(bx1) - bx1) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleX += (x - bone.data.scaleX) * alpha;
                            break;
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var bx2 = Math.abs(bone.data.scaleX) * Bridge.Int.sign(x);
                                bone.scaleX = bx2 + (x - bx2) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var bx3 = Math.abs(bone.scaleX) * Bridge.Int.sign(x);
                                bone.scaleX = bx3 + (x - bx3) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleX += (x - bone.data.scaleX) * alpha;
                            break;
                    }
                }
            },
            /*Spine.ScaleXTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleXTimeline end.*/

    /*Spine.ScaleYTimeline start.*/
    Bridge.define("Spine.ScaleYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 4 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ScaleYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ScaleYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.scaleY = bone.data.scaleY;
                            break;
                        case Spine.MixBlend.First: 
                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                            break;
                    }
                    return;
                }
                var y = this.GetCurveValue(time) * bone.data.scaleY;
                if (alpha === 1.0) {
                    if (blend === Spine.MixBlend.Add) {
                        bone.scaleY += y - bone.data.scaleY;
                    } else {
                        bone.scaleY = y;
                    }
                } else if (direction === Spine.MixDirection.Out) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var by = bone.data.scaleY;
                                bone.scaleY = by + (Math.abs(y) * Bridge.Int.sign(by) - by) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var by1 = bone.scaleY;
                                bone.scaleY = by1 + (Math.abs(y) * Bridge.Int.sign(by1) - by1) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleY += (y - bone.data.scaleY) * alpha;
                            break;
                    }
                } else {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            {
                                var by2 = Math.abs(bone.data.scaleY) * Bridge.Int.sign(y);
                                bone.scaleY = by2 + (y - by2) * alpha;
                                break;
                            }
                        case Spine.MixBlend.First: 
                        case Spine.MixBlend.Replace: 
                            {
                                var by3 = Math.abs(bone.scaleY) * Bridge.Int.sign(y);
                                bone.scaleY = by3 + (y - by3) * alpha;
                                break;
                            }
                        case Spine.MixBlend.Add: 
                            bone.scaleY += (y - bone.data.scaleY) * alpha;
                            break;
                    }
                }
            },
            /*Spine.ScaleYTimeline.Apply end.*/


        }
    });
    /*Spine.ScaleYTimeline end.*/

    /*Spine.ShearTimeline start.*/
    Bridge.define("Spine.ShearTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, 5 + "|" + boneIndex, 6 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                            break;
                        case Spine.MixBlend.First: 
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                            break;
                    }
                    return;
                }
                var i = Spine.Timeline.Search$1(frames, time, 3);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 3)) | 0)]);
                var x;
                var y;
                switch (curveType) {
                    case 0: 
                        {
                            var before = frames[i];
                            x = frames[((i + 1) | 0)];
                            y = frames[((i + 2) | 0)];
                            var t = (time - before) / (frames[((i + 3) | 0)] - before);
                            x += (frames[((((i + 3) | 0) + 1) | 0)] - x) * t;
                            y += (frames[((((i + 3) | 0) + 2) | 0)] - y) * t;
                            break;
                        }
                    case 1: 
                        x = frames[((i + 1) | 0)];
                        y = frames[((i + 2) | 0)];
                        break;
                    default: 
                        x = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        y = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        break;
                }
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearX = bone.data.shearX + x * alpha;
                        bone.shearY = bone.data.shearY + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearX += x * alpha;
                        bone.shearY += y * alpha;
                        break;
                }
            },
            /*Spine.ShearTimeline.Apply end.*/


        }
    });
    /*Spine.ShearTimeline end.*/

    /*Spine.ShearXTimeline start.*/
    Bridge.define("Spine.ShearXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 5 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearX = bone.data.shearX;
                            break;
                        case Spine.MixBlend.First: 
                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                            break;
                    }
                    return;
                }
                var x = this.GetCurveValue(time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearX = bone.data.shearX + x * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearX += x * alpha;
                        break;
                }
            },
            /*Spine.ShearXTimeline.Apply end.*/


        }
    });
    /*Spine.ShearXTimeline end.*/

    /*Spine.ShearYTimeline start.*/
    Bridge.define("Spine.ShearYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 6 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.ShearYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.ShearYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.shearY = bone.data.shearY;
                            break;
                        case Spine.MixBlend.First: 
                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                            break;
                    }
                    return;
                }
                var y = this.GetCurveValue(time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.shearY = bone.data.shearY + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.shearY += y * alpha;
                        break;
                }
            },
            /*Spine.ShearYTimeline.Apply end.*/


        }
    });
    /*Spine.ShearYTimeline end.*/

    /*Spine.TranslateTimeline start.*/
    Bridge.define("Spine.TranslateTimeline", {
        inherits: [Spine.CurveTimeline2,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline2.ctor.call(this, frameCount, bezierCount, 1 + "|" + boneIndex, 2 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                            break;
                        case Spine.MixBlend.First: 
                            bone.x += (bone.data.x - bone.x) * alpha;
                            bone.y += (bone.data.y - bone.y) * alpha;
                            break;
                    }
                    return;
                }
                var x = { };
                var y = { };
                this.GetCurveValue(x, y, time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.x = bone.data.x + x.v * alpha;
                        bone.y = bone.data.y + y.v * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.x += (bone.data.x + x.v - bone.x) * alpha;
                        bone.y += (bone.data.y + y.v - bone.y) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.x += x.v * alpha;
                        bone.y += y.v * alpha;
                        break;
                }
            },
            /*Spine.TranslateTimeline.Apply end.*/

            /*Spine.TranslateTimeline.GetCurveValue start.*/
            GetCurveValue: function (x, y, time) {
if ( TRACE ) { TRACE( "Spine.TranslateTimeline#GetCurveValue", this ); }

                var i = Spine.Timeline.Search$1(this.frames, time, 3);
                var curveType = Bridge.Int.clip32(this.curves[((Bridge.Int.div(i, 3)) | 0)]);
                switch (curveType) {
                    case 0: 
                        {
                            var before = this.frames[i];
                            x.v = this.frames[((i + 1) | 0)];
                            y.v = this.frames[((i + 2) | 0)];
                            var t = (time - before) / (this.frames[((i + 3) | 0)] - before);
                            x.v += (this.frames[((((i + 3) | 0) + 1) | 0)] - x.v) * t;
                            y.v += (this.frames[((((i + 3) | 0) + 2) | 0)] - y.v) * t;
                            break;
                        }
                    case 1: 
                        x.v = this.frames[((i + 1) | 0)];
                        y.v = this.frames[((i + 2) | 0)];
                        break;
                    default: 
                        x.v = this.GetBezierValue(time, i, 1, ((curveType - 2) | 0));
                        y.v = this.GetBezierValue(time, i, 2, ((((curveType + 18) | 0) - 2) | 0));
                        break;
                }
            },
            /*Spine.TranslateTimeline.GetCurveValue end.*/


        }
    });
    /*Spine.TranslateTimeline end.*/

    /*Spine.TranslateXTimeline start.*/
    Bridge.define("Spine.TranslateXTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 1 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateXTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateXTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.x = bone.data.x;
                            break;
                        case Spine.MixBlend.First: 
                            bone.x += (bone.data.x - bone.x) * alpha;
                            break;
                    }
                    return;
                }
                var x = this.GetCurveValue(time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.x = bone.data.x + x * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.x += (bone.data.x + x - bone.x) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.x += x * alpha;
                        break;
                }
            },
            /*Spine.TranslateXTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateXTimeline end.*/

    /*Spine.TranslateYTimeline start.*/
    Bridge.define("Spine.TranslateYTimeline", {
        inherits: [Spine.CurveTimeline1,Spine.IBoneTimeline],
        fields: {
            boneIndex: 0
        },
        props: {
            BoneIndex: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#BoneIndex#get", this ); }

                    return this.boneIndex;
                }
            }
        },
        alias: ["BoneIndex", "Spine$IBoneTimeline$BoneIndex"],
        ctors: {
            ctor: function (frameCount, bezierCount, boneIndex) {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#ctor", this ); }

                this.$initialize();
                Spine.CurveTimeline1.ctor.call(this, frameCount, bezierCount, 2 + "|" + boneIndex);
                this.boneIndex = boneIndex;
            }
        },
        methods: {
            /*Spine.TranslateYTimeline.Apply start.*/
            Apply: function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
if ( TRACE ) { TRACE( "Spine.TranslateYTimeline#Apply", this ); }

                var $t;
                var bone = ($t = skeleton.bones.Items)[this.boneIndex];
                if (!bone.active) {
                    return;
                }
                var frames = this.frames;
                if (time < frames[0]) {
                    switch (blend) {
                        case Spine.MixBlend.Setup: 
                            bone.y = bone.data.y;
                            break;
                        case Spine.MixBlend.First: 
                            bone.y += (bone.data.y - bone.y) * alpha;
                            break;
                    }
                    return;
                }
                var y = this.GetCurveValue(time);
                switch (blend) {
                    case Spine.MixBlend.Setup: 
                        bone.y = bone.data.y + y * alpha;
                        break;
                    case Spine.MixBlend.First: 
                    case Spine.MixBlend.Replace: 
                        bone.y += (bone.data.y + y - bone.y) * alpha;
                        break;
                    case Spine.MixBlend.Add: 
                        bone.y += y * alpha;
                        break;
                }
            },
            /*Spine.TranslateYTimeline.Apply end.*/


        }
    });
    /*Spine.TranslateYTimeline end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.ISpineComponent,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            unscaledTime: false,
            _animationName: null,
            loop: false,
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            },
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    var $t;
                    if (!this.valid) {
                        return this._animationName;
                    }
                    return ($t = this.state.GetCurrent(0)) != null ? $t.Animation.Name : null;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.GetCurrent(0);
                        if (entry != null && entry.Loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;
                    if (System.String.isNullOrEmpty(value)) {
                        this.state.ClearTrack(0);
                        return;
                    }
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(value);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.loop);
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1.0;
            }
        },
        methods: {
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.ClearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.state = null;
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);
                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;
                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).FindAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.SetAnimation(0, animationObject, this.loop);
                    }
                }
                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InUpdate) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }
                this.wasUpdatedAfterInit = true;
                if (this.updateMode >= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.UpdateAnimationStatus(deltaTime);
                    if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                        this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    } else {
                        this.ApplyAnimation();
                    }
                }
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#FixedUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InFixedUpdate) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.Update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.Apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton);
                }
                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }
                this.skeleton.UpdateWorldTransform();
                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }
                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0.0);
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0.0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.ISpineComponent],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);
                if (this.valid) {
                    if (this.translator == null) {
                        this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                    }
                    this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                    this.wasUpdatedAfterInit = false;
                    if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                        this._OnAnimationRebuild(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (this.valid && this.updateTiming === Spine.Unity.UpdateTiming.InUpdate) {
                    this.UpdateAnimation();
                }
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update$1", this ); }

                if (this.valid) {
                    this.UpdateAnimation();
                }
            },
            /*Spine.Unity.SkeletonMecanim.Update$1 end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#FixedUpdate", this ); }

                if (this.valid && this.updateTiming === Spine.Unity.UpdateTiming.InFixedUpdate) {
                    this.UpdateAnimation();
                }
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateAnimation", this ); }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode > Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.ApplyAnimation();
                }
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }
                this.translator.Apply(this.skeleton);
                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }
                this.skeleton.UpdateWorldTransform();
                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.UpdateWorldTransform();
                }
                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid && this.translator != null && UnityEngine.Component.op_Inequality(this.translator.Animator, null)) {
                    this.UpdateAnimation();
                }
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","Spine.Unity","System.Collections.Generic","UnityEngine","System.Collections","Spine","System.IO","UnityEngine.UI","UnityEngine.Rendering","UnityEngine.U2D","Spine.Unity.AttachmentTools","SharpJson","DG.Tweening","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options"];

    /*Anim start.*/
    $m("Anim", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"SetAnim","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"loop","pt":$n[0].Boolean,"ps":1}],"sn":"SetAnim","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"anim","t":4,"rt":$n[1].SkeletonAnimation,"sn":"anim"},{"at":[new Spine.Unity.SpineAnimation("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"tracks","t":4,"rt":$n[2].List$1(System.String),"sn":"tracks"}]}; }, $n);
    /*Anim end.*/

    /*CameraAnchor start.*/
    $m("CameraAnchor", function () { return {"nested":[CameraAnchor.AnchorType],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetAnchor","t":8,"pi":[{"n":"anchor","pt":$n[3].Vector3,"ps":0}],"sn":"SetAnchor","rt":$n[0].Void,"p":[$n[3].Vector3]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateAnchor","t":8,"sn":"UpdateAnchor","rt":$n[0].Void},{"a":1,"n":"UpdateAnchorAsync","t":8,"sn":"UpdateAnchorAsync","rt":$n[4].IEnumerator},{"a":2,"n":"anchorOffset","t":4,"rt":$n[3].Vector3,"sn":"anchorOffset"},{"a":2,"n":"anchorType","t":4,"rt":CameraAnchor.AnchorType,"sn":"anchorType","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":1,"n":"updateAnchorRoutine","t":4,"rt":$n[4].IEnumerator,"sn":"updateAnchorRoutine"}]}; }, $n);
    /*CameraAnchor end.*/

    /*CameraAnchor+AnchorType start.*/
    $m("CameraAnchor.AnchorType", function () { return {"td":CameraAnchor,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BottomCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"BottomLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"BottomRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"BottomRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"MiddleRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"MiddleRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopCenter","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopCenter","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopLeft","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopLeft","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}},{"a":2,"n":"TopRight","is":true,"t":4,"rt":CameraAnchor.AnchorType,"sn":"TopRight","box":function ($v) { return Bridge.box($v, CameraAnchor.AnchorType, System.Enum.toStringFn(CameraAnchor.AnchorType));}}]}; }, $n);
    /*CameraAnchor+AnchorType end.*/

    /*CameraElement start.*/
    $m("CameraElement", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DelayDestroy","t":8,"pi":[{"n":"win","pt":$n[0].Boolean,"ps":0}],"sn":"DelayDestroy","rt":$n[4].IEnumerator,"p":[$n[0].Boolean]},{"a":1,"n":"OnTriggerEnter2D","t":8,"pi":[{"n":"other","pt":$n[3].Collider2D,"ps":0}],"sn":"OnTriggerEnter2D","rt":$n[0].Void,"p":[$n[3].Collider2D]},{"a":2,"n":"OnWin","t":8,"sn":"OnWin","rt":$n[0].Void},{"a":2,"n":"WinPosition","t":16,"rt":$n[3].Vector2,"g":{"a":2,"n":"get_WinPosition","t":8,"rt":$n[3].Vector2,"fg":"WinPosition"},"s":{"a":2,"n":"set_WinPosition","t":8,"p":[$n[3].Vector2],"rt":$n[0].Void,"fs":"WinPosition"},"fn":"WinPosition"},{"a":1,"n":"onWin","t":4,"rt":$n[0].Boolean,"sn":"onWin","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"renderer","t":4,"rt":$n[3].SpriteRenderer,"sn":"renderer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vfxBlink","t":4,"rt":$n[3].ParticleSystem,"sn":"vfxBlink"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vfxSteam","t":4,"rt":$n[3].ParticleSystem,"sn":"vfxSteam"},{"a":1,"n":"winPosition","t":4,"rt":$n[3].Vector2,"sn":"winPosition"}]}; }, $n);
    /*CameraElement end.*/

    /*CameraFollower start.*/
    $m("CameraFollower", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"OnLose","t":8,"sn":"OnLose","rt":$n[4].IEnumerator},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"viewportHandler","t":4,"rt":ViewportHandler,"sn":"viewportHandler"}]}; }, $n);
    /*CameraFollower end.*/

    /*Cat start.*/
    $m("Cat", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Anim","t":16,"rt":Anim,"g":{"a":2,"n":"get_Anim","t":8,"rt":Anim,"fg":"Anim"},"fn":"Anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":Anim,"sn":"anim"}]}; }, $n);
    /*Cat end.*/

    /*Constant start.*/
    $m("Constant", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"animCatHappy","is":true,"t":4,"rt":$n[0].String,"sn":"animCatHappy"},{"a":2,"n":"animCatIdle","is":true,"t":4,"rt":$n[0].String,"sn":"animCatIdle"},{"a":2,"n":"animCatSad","is":true,"t":4,"rt":$n[0].String,"sn":"animCatSad"},{"a":2,"n":"animLose","is":true,"t":4,"rt":$n[0].String,"sn":"animLose"},{"a":2,"n":"animMouseIdle","is":true,"t":4,"rt":$n[0].String,"sn":"animMouseIdle"},{"a":2,"n":"animScare","is":true,"t":4,"rt":$n[0].String,"sn":"animScare"},{"a":2,"n":"animTakePhoto","is":true,"t":4,"rt":$n[0].String,"sn":"animTakePhoto"},{"a":2,"n":"soundBg","is":true,"t":4,"rt":$n[0].String,"sn":"soundBg"},{"a":2,"n":"soundClick","is":true,"t":4,"rt":$n[0].String,"sn":"soundClick"},{"a":2,"n":"soundDragPin","is":true,"t":4,"rt":$n[0].String,"sn":"soundDragPin"},{"a":2,"n":"soundGirlSay","is":true,"t":4,"rt":$n[0].String,"sn":"soundGirlSay"},{"a":2,"n":"soundInLava","is":true,"t":4,"rt":$n[0].String,"sn":"soundInLava"},{"a":2,"n":"soundLose","is":true,"t":4,"rt":$n[0].String,"sn":"soundLose"},{"a":2,"n":"soundMainScared","is":true,"t":4,"rt":$n[0].String,"sn":"soundMainScared"},{"a":2,"n":"soundNeedHelp","is":true,"t":4,"rt":$n[0].String,"sn":"soundNeedHelp"},{"a":2,"n":"soundRat","is":true,"t":4,"rt":$n[0].String,"sn":"soundRat"},{"a":2,"n":"soundTakePhoto","is":true,"t":4,"rt":$n[0].String,"sn":"soundTakePhoto"},{"a":2,"n":"tagBag","is":true,"t":4,"rt":$n[0].String,"sn":"tagBag"},{"a":2,"n":"tagCoin","is":true,"t":4,"rt":$n[0].String,"sn":"tagCoin"},{"a":2,"n":"tagDeathZone","is":true,"t":4,"rt":$n[0].String,"sn":"tagDeathZone"},{"a":2,"n":"tagLava","is":true,"t":4,"rt":$n[0].String,"sn":"tagLava"},{"a":2,"n":"tagRing","is":true,"t":4,"rt":$n[0].String,"sn":"tagRing"},{"a":2,"n":"tagRock","is":true,"t":4,"rt":$n[0].String,"sn":"tagRock"},{"a":2,"n":"tagWater","is":true,"t":4,"rt":$n[0].String,"sn":"tagWater"}]}; }, $n);
    /*Constant end.*/

    /*Hand start.*/
    $m("Hand", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"LoopClick","t":8,"sn":"LoopClick","rt":$n[4].IEnumerator},{"a":1,"n":"RunAnim","t":8,"sn":"RunAnim","rt":$n[0].Void},{"a":2,"n":"SetClick","t":8,"pi":[{"n":"position","pt":$n[3].Vector2,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1}],"sn":"SetClick","rt":$n[0].Void,"p":[$n[3].Vector2,$n[3].Transform]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":$n[3].Animator,"sn":"anim"}]}; }, $n);
    /*Hand end.*/

    /*InputReceiver start.*/
    $m("InputReceiver", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleTarget","t":8,"sn":"HandleTarget","rt":$n[0].Void},{"a":1,"n":"ResetTutorial","t":8,"sn":"ResetTutorial","rt":$n[4].IEnumerator},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*InputReceiver end.*/

    /*ItemLetter start.*/
    $m("ItemLetter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"strength","t":4,"rt":$n[0].Single,"sn":"strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"vibrato","t":4,"rt":$n[0].Int32,"sn":"vibrato","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*ItemLetter end.*/

    /*Level start.*/
    $m("Level", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ECTutorial","t":8,"sn":"ECTutorial","rt":$n[4].IEnumerator},{"a":2,"n":"OnLose","t":8,"sn":"OnLose","rt":$n[0].Void},{"a":2,"n":"OnWin","t":8,"sn":"OnWin","rt":$n[0].Void},{"a":2,"n":"SetTutorial","t":8,"sn":"SetTutorial","rt":$n[0].Void},{"a":2,"n":"SetUp","t":8,"sn":"SetUp","rt":$n[0].Void},{"a":2,"n":"SetUpSoundCharacter","t":8,"sn":"SetUpSoundCharacter","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateScale","t":8,"sn":"UpdateScale","rt":$n[0].Void},{"a":2,"n":"Hand","t":16,"rt":Hand,"g":{"a":2,"n":"get_Hand","t":8,"rt":Hand,"fg":"Hand"},"fn":"Hand"},{"a":2,"n":"Main","t":16,"rt":Main,"g":{"a":2,"n":"get_Main","t":8,"rt":Main,"fg":"Main"},"fn":"Main"},{"a":2,"n":"MaxScore","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MaxScore","t":8,"rt":$n[0].Int32,"fg":"MaxScore","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaxScore"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cameraElement","t":4,"rt":CameraElement,"sn":"cameraElement"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cat","t":4,"rt":Cat,"sn":"cat"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"frame","t":4,"rt":$n[3].Transform,"sn":"frame"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"hand","t":4,"rt":Hand,"sn":"hand"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"main","t":4,"rt":Main,"sn":"main"},{"a":1,"n":"maxScore","t":4,"rt":$n[0].Int32,"sn":"maxScore","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"originalAspect","t":4,"rt":$n[0].Single,"sn":"originalAspect","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"originalScale","t":4,"rt":$n[3].Vector3,"sn":"originalScale"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pins","t":4,"rt":$n[2].List$1(Pin),"sn":"pins"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pinsEndCard","t":4,"rt":$n[2].List$1(Pin),"sn":"pinsEndCard"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"winPositionCamera","t":4,"rt":$n[3].Transform,"sn":"winPositionCamera"}]}; }, $n);
    /*Level end.*/

    /*LevelManager start.*/
    $m("LevelManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CreateLevel","t":8,"sn":"CreateLevel","rt":$n[0].Void},{"a":1,"n":"DelayLose","t":8,"sn":"DelayLose","rt":$n[4].IEnumerator},{"a":1,"n":"DelayReplay","t":8,"sn":"DelayReplay","rt":$n[4].IEnumerator},{"a":1,"n":"DelayShowWin","t":8,"sn":"DelayShowWin","rt":$n[4].IEnumerator},{"a":2,"n":"OnLose","t":8,"sn":"OnLose","rt":$n[0].Void},{"a":2,"n":"OnWin","t":8,"sn":"OnWin","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentLevel","t":16,"rt":Level,"g":{"a":2,"n":"get_CurrentLevel","t":8,"rt":Level,"fg":"CurrentLevel"},"fn":"CurrentLevel"},{"a":2,"n":"IsEndCard","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsEndCard","t":8,"rt":$n[0].Boolean,"fg":"IsEndCard","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsEndCard"},{"a":2,"n":"IsEndGame","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsEndGame","t":8,"rt":$n[0].Boolean,"fg":"IsEndGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsEndGame"},{"a":1,"n":"currentLevel","t":4,"rt":Level,"sn":"currentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isEndCard","t":4,"rt":$n[0].Boolean,"sn":"isEndCard","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isEndGame","t":4,"rt":$n[0].Boolean,"sn":"isEndGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelPrefab","t":4,"rt":Level,"sn":"levelPrefab"},{"a":1,"n":"loseCount","t":4,"rt":$n[0].Int32,"sn":"loseCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*LevelManager end.*/

    /*Liquid start.*/
    $m("Liquid", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnCollisionStay2D","t":8,"pi":[{"n":"other","pt":$n[3].Collision2D,"ps":0}],"sn":"OnCollisionStay2D","rt":$n[0].Void,"p":[$n[3].Collision2D]},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"TransferToRock","t":8,"sn":"TransferToRock","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"liquid","t":4,"rt":$n[3].GameObject,"sn":"liquid"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"rock","t":4,"rt":$n[3].GameObject,"sn":"rock"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"steamVFX","t":4,"rt":$n[3].ParticleSystem,"sn":"steamVFX"},{"a":1,"n":"tag","t":4,"rt":$n[0].String,"sn":"tag$1"}]}; }, $n);
    /*Liquid end.*/

    /*Main start.*/
    $m("Main", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"SetAnimScare","t":8,"sn":"SetAnimScare","rt":$n[4].IEnumerator},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"Anim","t":16,"rt":Anim,"g":{"a":2,"n":"get_Anim","t":8,"rt":Anim,"fg":"Anim"},"fn":"Anim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":Anim,"sn":"anim"}]}; }, $n);
    /*Main end.*/

    /*Pin start.*/
    $m("Pin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActivePin","t":8,"sn":"ActivePin","rt":$n[0].Void},{"a":1,"n":"DelayDestroy","t":8,"sn":"DelayDestroy","rt":$n[4].IEnumerator},{"a":2,"n":"Center","t":16,"rt":$n[3].Transform,"g":{"a":2,"n":"get_Center","t":8,"rt":$n[3].Transform,"fg":"Center"},"fn":"Center"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"center","t":4,"rt":$n[3].Transform,"sn":"center"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"end","t":4,"rt":$n[3].Transform,"sn":"end"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"head","t":4,"rt":$n[3].Transform,"sn":"head"}]}; }, $n);
    /*Pin end.*/

    /*Rat start.*/
    $m("Rat", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"anim","t":4,"rt":Anim,"sn":"anim"}]}; }, $n);
    /*Rat end.*/

    /*Singleton$1 start.*/
    $m("Singleton$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Ins","is":true,"t":16,"rt":T,"g":{"a":2,"n":"get_Ins","t":8,"rt":T,"fg":"Ins","is":true},"fn":"Ins"},{"a":1,"n":"m_Ins","is":true,"t":4,"rt":T,"sn":"m_Ins"}]}; }, $n);
    /*Singleton$1 end.*/

    /*Sound start.*/
    $m("Sound", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clip","t":4,"rt":$n[3].AudioClip,"sn":"clip"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Sound end.*/

    /*SoundManager start.*/
    $m("SoundManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"GetAvailableAudioSource","t":8,"sn":"GetAvailableAudioSource","rt":$n[3].AudioSource},{"a":2,"n":"PlaySound","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"loop","pt":$n[0].Boolean,"ps":1}],"sn":"PlaySound","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SoundInLava","t":8,"sn":"SoundInLava","rt":$n[0].Void},{"a":2,"n":"StopAll","t":8,"sn":"StopAll","rt":$n[0].Void},{"a":2,"n":"InLava","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_InLava","t":8,"rt":$n[0].Boolean,"fg":"InLava","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_InLava","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"InLava"},"fn":"InLava"},{"a":2,"n":"Sounds","t":4,"rt":System.Array.type(Sound),"sn":"Sounds"},{"a":2,"n":"audioSources","t":4,"rt":$n[2].List$1(UnityEngine.AudioSource),"sn":"audioSources"},{"a":1,"n":"inLava","t":4,"rt":$n[0].Boolean,"sn":"inLava","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SoundManager end.*/

    /*UICLose start.*/
    $m("UICLose", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnShowed","t":8,"sn":"OnShowed","rt":$n[0].Void},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"text","t":4,"rt":$n[3].Transform,"sn":"text"}]}; }, $n);
    /*UICLose end.*/

    /*UICWin start.*/
    $m("UICWin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnShowed","t":8,"sn":"OnShowed","rt":$n[0].Void},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"items","t":4,"rt":System.Array.type(UnityEngine.Transform),"sn":"items"}]}; }, $n);
    /*UICWin end.*/

    /*UIManager start.*/
    $m("UIManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ShowGamePlay","t":8,"sn":"ShowGamePlay","rt":$n[0].Void},{"a":2,"n":"ShowLose","t":8,"sn":"ShowLose","rt":$n[0].Void},{"a":2,"n":"ShowWin","t":8,"sn":"ShowWin","rt":$n[0].Void},{"a":2,"n":"TakePhoto","t":8,"sn":"TakePhoto","rt":$n[4].IEnumerator},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animTakePhoto","t":4,"rt":$n[3].Animator,"sn":"animTakePhoto"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"uicLose","t":4,"rt":UICLose,"sn":"uicLose"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"uicWin","t":4,"rt":UICWin,"sn":"uicWin"}]}; }, $n);
    /*UIManager end.*/

    /*ViewportHandler start.*/
    $m("ViewportHandler", function () { return {"nested":[ViewportHandler.Constraint],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteInEditModeAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.Camera)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"ComputeResolution","t":8,"sn":"ComputeResolution","rt":$n[0].Void},{"a":1,"n":"OnDrawGizmos","t":8,"sn":"OnDrawGizmos","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"BottomCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomCenter","t":8,"rt":$n[3].Vector3,"fg":"BottomCenter"},"fn":"BottomCenter"},{"a":2,"n":"BottomLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomLeft","t":8,"rt":$n[3].Vector3,"fg":"BottomLeft"},"fn":"BottomLeft"},{"a":2,"n":"BottomRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_BottomRight","t":8,"rt":$n[3].Vector3,"fg":"BottomRight"},"fn":"BottomRight"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MiddleCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleCenter","t":8,"rt":$n[3].Vector3,"fg":"MiddleCenter"},"fn":"MiddleCenter"},{"a":2,"n":"MiddleLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleLeft","t":8,"rt":$n[3].Vector3,"fg":"MiddleLeft"},"fn":"MiddleLeft"},{"a":2,"n":"MiddleRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_MiddleRight","t":8,"rt":$n[3].Vector3,"fg":"MiddleRight"},"fn":"MiddleRight"},{"a":2,"n":"TopCenter","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopCenter","t":8,"rt":$n[3].Vector3,"fg":"TopCenter"},"fn":"TopCenter"},{"a":2,"n":"TopLeft","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopLeft","t":8,"rt":$n[3].Vector3,"fg":"TopLeft"},"fn":"TopLeft"},{"a":2,"n":"TopRight","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_TopRight","t":8,"rt":$n[3].Vector3,"fg":"TopRight"},"fn":"TopRight"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":2,"n":"Instance","is":true,"t":4,"rt":ViewportHandler,"sn":"Instance"},{"a":2,"n":"UnitsSize","t":4,"rt":$n[0].Single,"sn":"UnitsSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_bc","t":4,"rt":$n[3].Vector3,"sn":"_bc"},{"a":1,"n":"_bl","t":4,"rt":$n[3].Vector3,"sn":"_bl"},{"a":1,"n":"_br","t":4,"rt":$n[3].Vector3,"sn":"_br"},{"a":1,"n":"_height","t":4,"rt":$n[0].Single,"sn":"_height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_mc","t":4,"rt":$n[3].Vector3,"sn":"_mc"},{"a":1,"n":"_ml","t":4,"rt":$n[3].Vector3,"sn":"_ml"},{"a":1,"n":"_mr","t":4,"rt":$n[3].Vector3,"sn":"_mr"},{"a":1,"n":"_tc","t":4,"rt":$n[3].Vector3,"sn":"_tc"},{"a":1,"n":"_tl","t":4,"rt":$n[3].Vector3,"sn":"_tl"},{"a":1,"n":"_tr","t":4,"rt":$n[3].Vector3,"sn":"_tr"},{"a":1,"n":"_width","t":4,"rt":$n[0].Single,"sn":"_width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"camera","t":4,"rt":$n[3].Camera,"sn":"camera"},{"a":2,"n":"constraint","t":4,"rt":ViewportHandler.Constraint,"sn":"constraint","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}},{"a":2,"n":"wireColor","t":4,"rt":$n[3].Color,"sn":"wireColor"}]}; }, $n);
    /*ViewportHandler end.*/

    /*ViewportHandler+Constraint start.*/
    $m("ViewportHandler.Constraint", function () { return {"td":ViewportHandler,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Landscape","is":true,"t":4,"rt":ViewportHandler.Constraint,"sn":"Landscape","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}},{"a":2,"n":"Portrait","is":true,"t":4,"rt":ViewportHandler.Constraint,"sn":"Portrait","box":function ($v) { return Bridge.box($v, ViewportHandler.Constraint, System.Enum.toStringFn(ViewportHandler.Constraint));}}]}; }, $n);
    /*ViewportHandler+Constraint end.*/

    /*Spine.AlphaTimeline start.*/
    $m("Spine.AlphaTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AlphaTimeline end.*/

    /*Spine.Animation start.*/
    $m("Spine.Animation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[5].ExposedList$1(Spine.Timeline),$n[0].Single],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"timelines","pt":$n[5].ExposedList$1(Spine.Timeline),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"ctor"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"loop","pt":$n[0].Boolean,"ps":3},{"n":"events","pt":$n[5].ExposedList$1(Spine.Event),"ps":4},{"n":"alpha","pt":$n[0].Single,"ps":5},{"n":"blend","pt":$n[5].MixBlend,"ps":6},{"n":"direction","pt":$n[5].MixDirection,"ps":7}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"HasTimeline","t":8,"pi":[{"n":"propertyIds","pt":$n[0].Array.type(System.String),"ps":0}],"sn":"HasTimeline","rt":$n[0].Boolean,"p":[$n[0].Array.type(System.String)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetTimelines","t":8,"pi":[{"n":"timelines","pt":$n[5].ExposedList$1(Spine.Timeline),"ps":0}],"sn":"SetTimelines","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Timeline)]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Duration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Duration"},"fn":"Duration"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Timelines","t":16,"rt":$n[5].ExposedList$1(Spine.Timeline),"g":{"a":2,"n":"get_Timelines","t":8,"rt":$n[5].ExposedList$1(Spine.Timeline),"fg":"Timelines"},"s":{"a":2,"n":"set_Timelines","t":8,"p":[$n[5].ExposedList$1(Spine.Timeline)],"rt":$n[0].Void,"fs":"Timelines"},"fn":"Timelines"},{"a":4,"n":"duration","t":4,"rt":$n[0].Single,"sn":"duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"timelineIds","t":4,"rt":$n[2].HashSet$1(System.String),"sn":"timelineIds"},{"a":4,"n":"timelines","t":4,"rt":$n[5].ExposedList$1(Spine.Timeline),"sn":"timelines"}]}; }, $n);
    /*Spine.Animation end.*/

    /*Spine.AnimationState start.*/
    $m("Spine.AnimationState", function () { return {"nested":[Function,Function],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].AnimationStateData],"pi":[{"n":"data","pt":$n[5].AnimationStateData,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[5].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[5].Animation,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"delay","pt":$n[0].Single,"ps":3}],"sn":"AddAnimation$1","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1},{"n":"delay","pt":$n[0].Single,"ps":2}],"sn":"AddEmptyAnimation","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"a":2,"n":"AddEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[5].AnimationState,"ps":0}],"sn":"AddEventSubscribersFrom","rt":$n[0].Void,"p":[$n[5].AnimationState]},{"a":1,"n":"AnimationsChanged","t":8,"sn":"AnimationsChanged","rt":$n[0].Void},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Boolean,"p":[$n[5].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyAttachmentTimeline","t":8,"pi":[{"n":"timeline","pt":$n[5].AttachmentTimeline,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"blend","pt":$n[5].MixBlend,"ps":3},{"n":"attachments","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyAttachmentTimeline","rt":$n[0].Void,"p":[$n[5].AttachmentTimeline,$n[5].Skeleton,$n[0].Single,$n[5].MixBlend,$n[0].Boolean]},{"a":2,"n":"ApplyEventTimelinesOnly","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"issueEvents","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ApplyEventTimelinesOnly","rt":$n[0].Boolean,"p":[$n[5].Skeleton,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyMixingFrom","t":8,"pi":[{"n":"to","pt":$n[5].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"blend","pt":$n[5].MixBlend,"ps":2}],"sn":"ApplyMixingFrom","rt":$n[0].Single,"p":[$n[5].TrackEntry,$n[5].Skeleton,$n[5].MixBlend],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyMixingFromEventTimelinesOnly","t":8,"pi":[{"n":"to","pt":$n[5].TrackEntry,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"issueEvents","pt":$n[0].Boolean,"ps":2}],"sn":"ApplyMixingFromEventTimelinesOnly","rt":$n[0].Single,"p":[$n[5].TrackEntry,$n[5].Skeleton,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyRotateTimeline","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].RotateTimeline,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"alpha","pt":$n[0].Single,"ps":3},{"n":"blend","pt":$n[5].MixBlend,"ps":4},{"n":"timelinesRotation","pt":$n[0].Array.type(System.Single),"ps":5},{"n":"i","pt":$n[0].Int32,"ps":6},{"n":"firstFrame","pt":$n[0].Boolean,"ps":7}],"sn":"ApplyRotateTimeline","rt":$n[0].Void,"p":[$n[5].RotateTimeline,$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].MixBlend,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"AssignEventSubscribersFrom","t":8,"pi":[{"n":"src","pt":$n[5].AnimationState,"ps":0}],"sn":"AssignEventSubscribersFrom","rt":$n[0].Void,"p":[$n[5].AnimationState]},{"a":2,"n":"ClearListenerNotifications","t":8,"sn":"ClearListenerNotifications","rt":$n[0].Void},{"a":2,"n":"ClearNext","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"ClearNext","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":2,"n":"ClearTrack","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"ClearTrack","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"ClearTracks","t":8,"sn":"ClearTracks","rt":$n[0].Void},{"a":1,"n":"ComputeHold","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"ComputeHold","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":1,"n":"ExpandToIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"ExpandToIndex","rt":$n[5].TrackEntry,"p":[$n[0].Int32]},{"a":2,"n":"GetCurrent","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetCurrent","rt":$n[5].TrackEntry,"p":[$n[0].Int32]},{"a":1,"n":"NewTrackEntry","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[5].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"last","pt":$n[5].TrackEntry,"ps":3}],"sn":"NewTrackEntry","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[5].Animation,$n[0].Boolean,$n[5].TrackEntry]},{"a":4,"n":"OnComplete","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"OnComplete","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"OnDispose","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"OnDispose","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"OnEnd","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"OnEnd","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":$n[5].Event,"ps":1}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[5].Event]},{"a":4,"n":"OnInterrupt","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"OnInterrupt","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"OnStart","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"OnStart","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":1,"n":"QueueEvents","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0},{"n":"animationTime","pt":$n[0].Single,"ps":1}],"sn":"QueueEvents","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[0].Single]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animation","pt":$n[5].Animation,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[5].Animation,$n[0].Boolean]},{"a":2,"n":"SetAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2}],"sn":"SetAnimation$1","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2},{"n":"attachments","pt":$n[0].Boolean,"ps":3}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[5].Slot,$n[0].String,$n[0].Boolean]},{"a":1,"n":"SetCurrent","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"current","pt":$n[5].TrackEntry,"ps":1},{"n":"interrupt","pt":$n[0].Boolean,"ps":2}],"sn":"SetCurrent","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].TrackEntry,$n[0].Boolean]},{"a":2,"n":"SetEmptyAnimation","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0},{"n":"mixDuration","pt":$n[0].Single,"ps":1}],"sn":"SetEmptyAnimation","rt":$n[5].TrackEntry,"p":[$n[0].Int32,$n[0].Single]},{"a":2,"n":"SetEmptyAnimations","t":8,"pi":[{"n":"mixDuration","pt":$n[0].Single,"ps":0}],"sn":"SetEmptyAnimations","rt":$n[0].Void,"p":[$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"pi":[{"n":"delta","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"UpdateMixingFrom","t":8,"pi":[{"n":"to","pt":$n[5].TrackEntry,"ps":0},{"n":"delta","pt":$n[0].Single,"ps":1}],"sn":"UpdateMixingFrom","rt":$n[0].Boolean,"p":[$n[5].TrackEntry,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Data","t":16,"rt":$n[5].AnimationStateData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].AnimationStateData,"fg":"Data"},"s":{"a":2,"n":"set_Data","t":8,"p":[$n[5].AnimationStateData],"rt":$n[0].Void,"fs":"Data"},"fn":"Data"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"Tracks","t":16,"rt":$n[5].ExposedList$1(Spine.TrackEntry),"g":{"a":2,"n":"get_Tracks","t":8,"rt":$n[5].ExposedList$1(Spine.TrackEntry),"fg":"Tracks"},"fn":"Tracks"},{"a":4,"n":"Current","is":true,"t":4,"rt":$n[0].Int32,"sn":"Current","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"EmptyAnimation","is":true,"t":4,"rt":$n[5].Animation,"sn":"EmptyAnimation","ro":true},{"a":4,"n":"First","is":true,"t":4,"rt":$n[0].Int32,"sn":"First","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldFirst","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldFirst","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldMix","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldMix","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"HoldSubsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"HoldSubsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Setup","is":true,"t":4,"rt":$n[0].Int32,"sn":"Setup","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Subsequent","is":true,"t":4,"rt":$n[0].Int32,"sn":"Subsequent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationsChanged","t":4,"rt":$n[0].Boolean,"sn":"animationsChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"data","t":4,"rt":$n[5].AnimationStateData,"sn":"data"},{"a":1,"n":"events","t":4,"rt":$n[5].ExposedList$1(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIds","t":4,"rt":$n[2].HashSet$1(System.String),"sn":"propertyIds","ro":true},{"a":1,"n":"queue","t":4,"rt":$n[5].EventQueue,"sn":"queue","ro":true},{"a":1,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[5].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":1,"n":"tracks","t":4,"rt":$n[5].ExposedList$1(Spine.TrackEntry),"sn":"tracks","ro":true},{"a":1,"n":"unkeyedState","t":4,"rt":$n[0].Int32,"sn":"unkeyedState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.AnimationState end.*/

    /*Spine.AnimationStateData start.*/
    $m("Spine.AnimationStateData", function () { return {"nested":[$n[5].AnimationStateData.AnimationPair,$n[5].AnimationStateData.AnimationPairComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].SkeletonData],"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetMix","t":8,"pi":[{"n":"from","pt":$n[5].Animation,"ps":0},{"n":"to","pt":$n[5].Animation,"ps":1}],"sn":"GetMix","rt":$n[0].Single,"p":[$n[5].Animation,$n[5].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"from","pt":$n[5].Animation,"ps":0},{"n":"to","pt":$n[5].Animation,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix","rt":$n[0].Void,"p":[$n[5].Animation,$n[5].Animation,$n[0].Single]},{"a":2,"n":"SetMix","t":8,"pi":[{"n":"fromName","pt":$n[0].String,"ps":0},{"n":"toName","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"SetMix$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].Single]},{"a":2,"n":"DefaultMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DefaultMix","t":8,"rt":$n[0].Single,"fg":"DefaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DefaultMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DefaultMix"},"fn":"DefaultMix"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[5].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[5].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":1,"n":"animationToMixTime","t":4,"rt":$n[2].Dictionary$2(Spine.AnimationStateData.AnimationPair,System.Single),"sn":"animationToMixTime","ro":true},{"a":4,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeletonData","t":4,"rt":$n[5].SkeletonData,"sn":"skeletonData"}]}; }, $n);
    /*Spine.AnimationStateData end.*/

    /*Spine.AnimationStateData+AnimationPair start.*/
    $m("Spine.AnimationStateData.AnimationPair", function () { return {"td":$n[5].AnimationStateData,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].Animation,$n[5].Animation],"pi":[{"n":"a1","pt":$n[5].Animation,"ps":0},{"n":"a2","pt":$n[5].Animation,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"a1","t":4,"rt":$n[5].Animation,"sn":"a1","ro":true},{"a":2,"n":"a2","t":4,"rt":$n[5].Animation,"sn":"a2","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPair end.*/

    /*Spine.AnimationStateData+AnimationPairComparer start.*/
    $m("Spine.AnimationStateData.AnimationPairComparer", function () { return {"td":$n[5].AnimationStateData,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Instance","is":true,"t":4,"rt":$n[5].AnimationStateData.AnimationPairComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.AnimationStateData+AnimationPairComparer end.*/

    /*Spine.Atlas start.*/
    $m("Spine.Atlas", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[2].List$1(Spine.AtlasPage),$n[2].List$1(Spine.AtlasRegion)],"pi":[{"n":"pages","pt":$n[2].List$1(Spine.AtlasPage),"ps":0},{"n":"regions","pt":$n[2].List$1(Spine.AtlasRegion),"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[6].TextReader,$n[0].String,$n[5].TextureLoader],"pi":[{"n":"reader","pt":$n[6].TextReader,"ps":0},{"n":"imagesDir","pt":$n[0].String,"ps":1},{"n":"textureLoader","pt":$n[5].TextureLoader,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[5].AtlasRegion,"p":[$n[0].String]},{"a":2,"n":"FlipV","t":8,"sn":"FlipV","rt":$n[0].Void},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[2].IEnumerator$1(Spine.AtlasRegion)},{"a":1,"n":"ReadEntry","is":true,"t":8,"pi":[{"n":"entry","pt":$n[0].Array.type(System.String),"ps":0},{"n":"line","pt":$n[0].String,"ps":1}],"sn":"ReadEntry","rt":$n[0].Int32,"p":[$n[0].Array.type(System.String),$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pages","t":16,"rt":$n[2].List$1(Spine.AtlasPage),"g":{"a":2,"n":"get_Pages","t":8,"rt":$n[2].List$1(Spine.AtlasPage),"fg":"Pages"},"fn":"Pages"},{"a":2,"n":"Regions","t":16,"rt":$n[2].List$1(Spine.AtlasRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":$n[2].List$1(Spine.AtlasRegion),"fg":"Regions"},"fn":"Regions"},{"a":1,"n":"pages","t":4,"rt":$n[2].List$1(Spine.AtlasPage),"sn":"pages","ro":true},{"a":1,"n":"regions","t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"regions"},{"a":1,"n":"textureLoader","t":4,"rt":$n[5].TextureLoader,"sn":"textureLoader"}]}; }, $n);
    /*Spine.Atlas end.*/

    /*Spine.AtlasAttachmentLoader start.*/
    $m("Spine.AtlasAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":"FindRegion","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"FindRegion","rt":$n[5].AtlasRegion,"p":[$n[0].String]},{"a":1,"n":"LoadSequence","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"basePath","pt":$n[0].String,"ps":1},{"n":"sequence","pt":$n[5].Sequence,"ps":2}],"sn":"LoadSequence","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[5].Sequence]},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[5].BoundingBoxAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[5].ClippingAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[5].MeshAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[5].PathAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[5].PointAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]},{"a":1,"n":"atlasArray","t":4,"rt":System.Array.type(Spine.Atlas),"sn":"atlasArray"}]}; }, $n);
    /*Spine.AtlasAttachmentLoader end.*/

    /*Spine.AtlasPage start.*/
    $m("Spine.AtlasPage", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[5].AtlasPage},{"a":2,"n":"format","t":4,"rt":$n[5].Format,"sn":"format","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"magFilter","t":4,"rt":$n[5].TextureFilter,"sn":"magFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"minFilter","t":4,"rt":$n[5].TextureFilter,"sn":"minFilter","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"pma","t":4,"rt":$n[0].Boolean,"sn":"pma","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rendererObject","t":4,"rt":$n[0].Object,"sn":"rendererObject"},{"a":2,"n":"uWrap","t":4,"rt":$n[5].TextureWrap,"sn":"uWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"vWrap","t":4,"rt":$n[5].TextureWrap,"sn":"vWrap","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasPage end.*/

    /*Spine.AtlasRegion start.*/
    $m("Spine.AtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clone","t":8,"sn":"Clone","rt":$n[5].AtlasRegion},{"ov":true,"a":2,"n":"OriginalHeight","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_OriginalHeight","t":8,"rt":$n[0].Int32,"fg":"OriginalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalHeight"},{"ov":true,"a":2,"n":"OriginalWidth","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_OriginalWidth","t":8,"rt":$n[0].Int32,"fg":"OriginalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalWidth"},{"a":2,"n":"packedHeight","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_packedHeight","t":8,"rt":$n[0].Int32,"fg":"packedHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_packedHeight","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"packedHeight"},"fn":"packedHeight"},{"a":2,"n":"packedWidth","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_packedWidth","t":8,"rt":$n[0].Int32,"fg":"packedWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_packedWidth","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"packedWidth"},"fn":"packedWidth"},{"a":2,"n":"degrees","t":4,"rt":$n[0].Int32,"sn":"degrees","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"names","t":4,"rt":$n[0].Array.type(System.String),"sn":"names"},{"a":2,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"originalHeight","t":4,"rt":$n[0].Int32,"sn":"originalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"originalWidth","t":4,"rt":$n[0].Int32,"sn":"originalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"page","t":4,"rt":$n[5].AtlasPage,"sn":"page"},{"a":2,"n":"rotate","t":4,"rt":$n[0].Boolean,"sn":"rotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"values","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"values"},{"a":2,"n":"x","t":4,"rt":$n[0].Int32,"sn":"x","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"y","t":4,"rt":$n[0].Int32,"sn":"y","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AtlasRegion end.*/

    /*Spine.Attachment start.*/
    $m("Spine.Attachment", function () { return {"att":1048705,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].Attachment],"pi":[{"n":"other","pt":$n[5].Attachment,"ps":0}],"sn":"ctor"},{"a":3,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ab":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"backing":true,"n":"<Name>k__BackingField","t":4,"rt":$n[0].String,"sn":"Name"}]}; }, $n);
    /*Spine.Attachment end.*/

    /*Spine.AttachmentLoader start.*/
    $m("Spine.AttachmentLoader", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewBoundingBoxAttachment","rt":$n[5].BoundingBoxAttachment,"p":[$n[5].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewClippingAttachment","rt":$n[5].ClippingAttachment,"p":[$n[5].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"Spine$AttachmentLoader$NewMeshAttachment","rt":$n[5].MeshAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]},{"ab":true,"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPathAttachment","rt":$n[5].PathAttachment,"p":[$n[5].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"Spine$AttachmentLoader$NewPointAttachment","rt":$n[5].PointAttachment,"p":[$n[5].Skin,$n[0].String]},{"ab":true,"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"Spine$AttachmentLoader$NewRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]}]}; }, $n);
    /*Spine.AttachmentLoader end.*/

    /*Spine.AttachmentTimeline start.*/
    $m("Spine.AttachmentTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":1,"n":"SetAttachment","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[5].Slot,$n[0].String]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].String]},{"a":2,"n":"AttachmentNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_AttachmentNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"AttachmentNames"},"fn":"AttachmentNames"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"attachmentNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"attachmentNames","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.AttachmentTimeline end.*/

    /*Spine.AttachmentType start.*/
    $m("Spine.AttachmentType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Boundingbox","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Boundingbox","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Clipping","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Clipping","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Linkedmesh","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Linkedmesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Mesh","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Mesh","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Path","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Path","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Point","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Point","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Region","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Region","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}},{"a":2,"n":"Sequence","is":true,"t":4,"rt":$n[5].AttachmentType,"sn":"Sequence","box":function ($v) { return Bridge.box($v, Spine.AttachmentType, System.Enum.toStringFn(Spine.AttachmentType));}}]}; }, $n);
    /*Spine.AttachmentType end.*/

    /*Spine.BlendMode start.*/
    $m("Spine.BlendMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Additive","is":true,"t":4,"rt":$n[5].BlendMode,"sn":"Additive","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Multiply","is":true,"t":4,"rt":$n[5].BlendMode,"sn":"Multiply","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[5].BlendMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":2,"n":"Screen","is":true,"t":4,"rt":$n[5].BlendMode,"sn":"Screen","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}}]}; }, $n);
    /*Spine.BlendMode end.*/

    /*Spine.Bone start.*/
    $m("Spine.Bone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Bone,$n[5].Skeleton,$n[5].Bone],"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"parent","pt":$n[5].Bone,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].BoneData,$n[5].Skeleton,$n[5].Bone],"pi":[{"n":"data","pt":$n[5].BoneData,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"parent","pt":$n[5].Bone,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"LocalToWorld","t":8,"pi":[{"n":"localX","pt":$n[0].Single,"ps":0},{"n":"localY","pt":$n[0].Single,"ps":1},{"n":"worldX","out":true,"pt":$n[0].Single,"ps":2},{"n":"worldY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"LocalToWorld","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"LocalToWorldRotation","t":8,"pi":[{"n":"localRotation","pt":$n[0].Single,"ps":0}],"sn":"LocalToWorldRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RotateWorld","t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"RotateWorld","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"UpdateAppliedTransform","t":8,"sn":"UpdateAppliedTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"rotation","pt":$n[0].Single,"ps":2},{"n":"scaleX","pt":$n[0].Single,"ps":3},{"n":"scaleY","pt":$n[0].Single,"ps":4},{"n":"shearX","pt":$n[0].Single,"ps":5},{"n":"shearY","pt":$n[0].Single,"ps":6}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocal","t":8,"pi":[{"n":"worldX","pt":$n[0].Single,"ps":0},{"n":"worldY","pt":$n[0].Single,"ps":1},{"n":"localX","out":true,"pt":$n[0].Single,"ps":2},{"n":"localY","out":true,"pt":$n[0].Single,"ps":3}],"sn":"WorldToLocal","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"WorldToLocalRotation","t":8,"pi":[{"n":"worldRotation","pt":$n[0].Single,"ps":0}],"sn":"WorldToLocalRotation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleX","t":8,"rt":$n[0].Single,"fg":"AScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleX"},"fn":"AScaleX"},{"a":2,"n":"AScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AScaleY","t":8,"rt":$n[0].Single,"fg":"AScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AScaleY"},"fn":"AScaleY"},{"a":2,"n":"AShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearX","t":8,"rt":$n[0].Single,"fg":"AShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearX"},"fn":"AShearX"},{"a":2,"n":"AShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AShearY","t":8,"rt":$n[0].Single,"fg":"AShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AShearY"},"fn":"AShearY"},{"a":2,"n":"AX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AX","t":8,"rt":$n[0].Single,"fg":"AX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AX"},"fn":"AX"},{"a":2,"n":"AY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AY","t":8,"rt":$n[0].Single,"fg":"AY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AY"},"fn":"AY"},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"AppliedRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AppliedRotation","t":8,"rt":$n[0].Single,"fg":"AppliedRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AppliedRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AppliedRotation"},"fn":"AppliedRotation"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"C","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_C","t":8,"rt":$n[0].Single,"fg":"C","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_C","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"C"},"fn":"C"},{"a":2,"n":"Children","t":16,"rt":$n[5].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Children","t":8,"rt":$n[5].ExposedList$1(Spine.Bone),"fg":"Children"},"fn":"Children"},{"a":2,"n":"D","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_D","t":8,"rt":$n[0].Single,"fg":"D","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_D","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"D"},"fn":"D"},{"a":2,"n":"Data","t":16,"rt":$n[5].BoneData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].BoneData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Parent","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[5].Bone,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"WorldRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationX","t":8,"rt":$n[0].Single,"fg":"WorldRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationX"},{"a":2,"n":"WorldRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldRotationY","t":8,"rt":$n[0].Single,"fg":"WorldRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldRotationY"},{"a":2,"n":"WorldScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleX","t":8,"rt":$n[0].Single,"fg":"WorldScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleX"},{"a":2,"n":"WorldScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldScaleY","t":8,"rt":$n[0].Single,"fg":"WorldScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldScaleY"},{"a":2,"n":"WorldToLocalRotationX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationX","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationX"},{"a":2,"n":"WorldToLocalRotationY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldToLocalRotationY","t":8,"rt":$n[0].Single,"fg":"WorldToLocalRotationY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"WorldToLocalRotationY"},{"a":2,"n":"WorldX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldX","t":8,"rt":$n[0].Single,"fg":"WorldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_WorldX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"WorldX"},"fn":"WorldX"},{"a":2,"n":"WorldY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_WorldY","t":8,"rt":$n[0].Single,"fg":"WorldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_WorldY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"WorldY"},"fn":"WorldY"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"arotation","t":4,"rt":$n[0].Single,"sn":"arotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleX","t":4,"rt":$n[0].Single,"sn":"ascaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ascaleY","t":4,"rt":$n[0].Single,"sn":"ascaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearX","t":4,"rt":$n[0].Single,"sn":"ashearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ashearY","t":4,"rt":$n[0].Single,"sn":"ashearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ax","t":4,"rt":$n[0].Single,"sn":"ax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ay","t":4,"rt":$n[0].Single,"sn":"ay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"children","t":4,"rt":$n[5].ExposedList$1(Spine.Bone),"sn":"children"},{"a":4,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[5].BoneData,"sn":"data"},{"a":4,"n":"parent","t":4,"rt":$n[5].Bone,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":4,"n":"sorted","t":4,"rt":$n[0].Boolean,"sn":"sorted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"worldX","t":4,"rt":$n[0].Single,"sn":"worldX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"worldY","t":4,"rt":$n[0].Single,"sn":"worldY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"yDown","is":true,"t":4,"rt":$n[0].Boolean,"sn":"yDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Bone end.*/

    /*Spine.BoneData start.*/
    $m("Spine.BoneData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[5].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"parent","pt":$n[5].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Length","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Length","t":8,"rt":$n[0].Single,"fg":"Length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Length","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Length"},"fn":"Length"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Parent","t":16,"rt":$n[5].BoneData,"g":{"a":2,"n":"get_Parent","t":8,"rt":$n[5].BoneData,"fg":"Parent"},"fn":"Parent"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"ShearX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearX","t":8,"rt":$n[0].Single,"fg":"ShearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearX"},"fn":"ShearX"},{"a":2,"n":"ShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ShearY","t":8,"rt":$n[0].Single,"fg":"ShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ShearY"},"fn":"ShearY"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":2,"n":"TransformMode","t":16,"rt":$n[5].TransformMode,"g":{"a":2,"n":"get_TransformMode","t":8,"rt":$n[5].TransformMode,"fg":"TransformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},"s":{"a":2,"n":"set_TransformMode","t":8,"p":[$n[5].TransformMode],"rt":$n[0].Void,"fs":"TransformMode"},"fn":"TransformMode"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"length","t":4,"rt":$n[0].Single,"sn":"length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"parent","t":4,"rt":$n[5].BoneData,"sn":"parent"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearX","t":4,"rt":$n[0].Single,"sn":"shearX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"shearY","t":4,"rt":$n[0].Single,"sn":"shearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"transformMode","t":4,"rt":$n[5].TransformMode,"sn":"transformMode","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneData end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].Bone],"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[5].BoneData],"pi":[{"n":"boneData","pt":$n[5].BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[5].BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[5].BoneMatrix,"p":[$n[5].BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":$n[5].BoneData,"ps":0},{"n":"parentMatrix","pt":$n[5].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[5].BoneMatrix,"p":[$n[5].BoneData,$n[5].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[5].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[5].BoneMatrix,"p":[$n[5].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.BoundingBoxAttachment start.*/
    $m("Spine.BoundingBoxAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].BoundingBoxAttachment],"pi":[{"n":"other","pt":$n[5].BoundingBoxAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment}]}; }, $n);
    /*Spine.BoundingBoxAttachment end.*/

    /*Spine.ClippingAttachment start.*/
    $m("Spine.ClippingAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].ClippingAttachment],"pi":[{"n":"other","pt":$n[5].ClippingAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"a":2,"n":"EndSlot","t":16,"rt":$n[5].SlotData,"g":{"a":2,"n":"get_EndSlot","t":8,"rt":$n[5].SlotData,"fg":"EndSlot"},"s":{"a":2,"n":"set_EndSlot","t":8,"p":[$n[5].SlotData],"rt":$n[0].Void,"fs":"EndSlot"},"fn":"EndSlot"},{"a":4,"n":"endSlot","t":4,"rt":$n[5].SlotData,"sn":"endSlot"}]}; }, $n);
    /*Spine.ClippingAttachment end.*/

    /*Spine.ConstraintData start.*/
    $m("Spine.ConstraintData", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Order","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Order","t":8,"rt":$n[0].Int32,"fg":"Order","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Order","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Order"},"fn":"Order"},{"a":2,"n":"SkinRequired","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_SkinRequired","t":8,"rt":$n[0].Boolean,"fg":"SkinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_SkinRequired","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SkinRequired"},"fn":"SkinRequired"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"order","t":4,"rt":$n[0].Int32,"sn":"order","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"skinRequired","t":4,"rt":$n[0].Boolean,"sn":"skinRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.ConstraintData end.*/

    /*Spine.CurveTimeline start.*/
    $m("Spine.CurveTimeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.String)],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyIds","ip":true,"pt":$n[0].Array.type(System.String),"ps":2}],"sn":"ctor"},{"a":2,"n":"GetBezierValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"frameIndex","pt":$n[0].Int32,"ps":1},{"n":"valueOffset","pt":$n[0].Int32,"ps":2},{"n":"i","pt":$n[0].Int32,"ps":3}],"sn":"GetBezierValue","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Int32,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetCurveType","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"GetCurveType","rt":$n[0].Single,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetBezier","t":8,"pi":[{"n":"bezier","pt":$n[0].Int32,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"time1","pt":$n[0].Single,"ps":3},{"n":"value1","pt":$n[0].Single,"ps":4},{"n":"cx1","pt":$n[0].Single,"ps":5},{"n":"cy1","pt":$n[0].Single,"ps":6},{"n":"cx2","pt":$n[0].Single,"ps":7},{"n":"cy2","pt":$n[0].Single,"ps":8},{"n":"time2","pt":$n[0].Single,"ps":9},{"n":"value2","pt":$n[0].Single,"ps":10}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLinear","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"SetLinear","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetStepped","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0}],"sn":"SetStepped","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Shrink","t":8,"pi":[{"n":"bezierCount","pt":$n[0].Int32,"ps":0}],"sn":"Shrink","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BEZIER_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEZIER_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"curves","t":4,"rt":$n[0].Array.type(System.Single),"sn":"curves"}]}; }, $n);
    /*Spine.CurveTimeline end.*/

    /*Spine.CurveTimeline1 start.*/
    $m("Spine.CurveTimeline1", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].String],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyId","pt":$n[0].String,"ps":2}],"sn":"ctor"},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0}],"sn":"GetCurveValue","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline1 end.*/

    /*Spine.CurveTimeline2 start.*/
    $m("Spine.CurveTimeline2", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].String,$n[0].String],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"propertyId1","pt":$n[0].String,"ps":2},{"n":"propertyId2","pt":$n[0].String,"ps":3}],"sn":"ctor"},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"value1","pt":$n[0].Single,"ps":2},{"n":"value2","pt":$n[0].Single,"ps":3}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE1","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE1","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"VALUE2","is":true,"t":4,"rt":$n[0].Int32,"sn":"VALUE2","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.CurveTimeline2 end.*/

    /*Spine.DeformTimeline start.*/
    $m("Spine.DeformTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[5].VertexAttachment],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"attachment","pt":$n[5].VertexAttachment,"ps":3}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":1,"n":"GetCurvePercent","t":8,"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1}],"sn":"GetCurvePercent","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"setBezier","t":8,"pi":[{"n":"bezier","pt":$n[0].Int32,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"time1","pt":$n[0].Single,"ps":3},{"n":"value1","pt":$n[0].Single,"ps":4},{"n":"cx1","pt":$n[0].Single,"ps":5},{"n":"cy1","pt":$n[0].Single,"ps":6},{"n":"cx2","pt":$n[0].Single,"ps":7},{"n":"cy2","pt":$n[0].Single,"ps":8},{"n":"time2","pt":$n[0].Single,"ps":9},{"n":"value2","pt":$n[0].Single,"ps":10}],"sn":"setBezier","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"Attachment","t":16,"rt":$n[5].VertexAttachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[5].VertexAttachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Array.type(System.Single)),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Array.type(System.Single)),"fg":"Vertices"},"fn":"Vertices"},{"a":1,"n":"attachment","t":4,"rt":$n[5].VertexAttachment,"sn":"attachment","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Array.type(System.Single)),"sn":"vertices"}]}; }, $n);
    /*Spine.DeformTimeline end.*/

    /*Spine.DrawOrderTimeline start.*/
    $m("Spine.DrawOrderTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"drawOrder","pt":$n[0].Array.type(System.Int32),"ps":2}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Array.type(System.Int32)]},{"a":2,"n":"DrawOrders","t":16,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"g":{"a":2,"n":"get_DrawOrders","t":8,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"fg":"DrawOrders"},"fn":"DrawOrders"},{"a":1,"n":"drawOrders","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"drawOrders","ro":true},{"a":1,"n":"propertyIds","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.DrawOrderTimeline end.*/

    /*Spine.Event start.*/
    $m("Spine.Event", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single,$n[5].EventData],"pi":[{"n":"time","pt":$n[0].Single,"ps":0},{"n":"data","pt":$n[5].EventData,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Data","t":16,"rt":$n[5].EventData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].EventData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Time","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Time","t":8,"rt":$n[0].Single,"fg":"Time","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Time"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"balance","t":4,"rt":$n[0].Single,"sn":"balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"data","t":4,"rt":$n[5].EventData,"sn":"data","ro":true},{"a":4,"n":"floatValue","t":4,"rt":$n[0].Single,"sn":"floatValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"intValue","t":4,"rt":$n[0].Int32,"sn":"intValue","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"stringValue","t":4,"rt":$n[0].String,"sn":"stringValue"},{"a":4,"n":"time","t":4,"rt":$n[0].Single,"sn":"time","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Event end.*/

    /*Spine.EventData start.*/
    $m("Spine.EventData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Balance","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Balance","t":8,"rt":$n[0].Single,"fg":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Balance","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Balance"},"fn":"Balance"},{"a":2,"n":"Float","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Float","t":8,"rt":$n[0].Single,"fg":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Float","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Float"},"fn":"Float"},{"a":2,"n":"Int","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Int","t":8,"rt":$n[0].Int32,"fg":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Int","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Int"},"fn":"Int"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"String","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_String","t":8,"rt":$n[0].String,"fg":"String"},"s":{"a":2,"n":"set_String","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"String"},"fn":"String"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":1,"backing":true,"n":"<AudioPath>k__BackingField","t":4,"rt":$n[0].String,"sn":"AudioPath"},{"a":1,"backing":true,"n":"<Balance>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Balance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Float>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Float","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Int>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Int","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<String>k__BackingField","t":4,"rt":$n[0].String,"sn":"String"},{"a":1,"backing":true,"n":"<Volume>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.EventData end.*/

    /*Spine.EventQueue start.*/
    $m("Spine.EventQueue", function () { return {"nested":[$n[5].EventQueue.EventQueueEntry,$n[5].EventQueue.EventType],"att":1048576,"a":4,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[5].AnimationState,Function,$n[5].Pool$1(Spine.TrackEntry)],"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"HandleAnimationsChanged","pt":Function,"ps":1},{"n":"trackEntryPool","pt":$n[5].Pool$1(Spine.TrackEntry),"ps":2}],"sn":"ctor"},{"a":4,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":4,"n":"Complete","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"Complete","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"Dispose","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"Dispose","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"Drain","t":8,"sn":"Drain","rt":$n[0].Void},{"a":4,"n":"End","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"End","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"Event","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":$n[5].Event,"ps":1}],"sn":"Event","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[5].Event]},{"a":4,"n":"Interrupt","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"Interrupt","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"Start","t":8,"pi":[{"n":"entry","pt":$n[5].TrackEntry,"ps":0}],"sn":"Start","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":4,"n":"drainDisabled","t":4,"rt":$n[0].Boolean,"sn":"drainDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventQueueEntries","t":4,"rt":$n[2].List$1(Spine.EventQueue.EventQueueEntry),"sn":"eventQueueEntries","ro":true},{"a":1,"n":"state","t":4,"rt":$n[5].AnimationState,"sn":"state","ro":true},{"a":1,"n":"trackEntryPool","t":4,"rt":$n[5].Pool$1(Spine.TrackEntry),"sn":"trackEntryPool","ro":true},{"a":4,"n":"AnimationsChanged","t":2,"ad":{"a":4,"n":"add_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAnimationsChanged","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_AnimationsChanged","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAnimationsChanged","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.EventQueue end.*/

    /*Spine.EventQueue+EventQueueEntry start.*/
    $m("Spine.EventQueue.EventQueueEntry", function () { return {"td":$n[5].EventQueue,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].EventQueue.EventType,$n[5].TrackEntry,$n[5].Event],"pi":[{"n":"eventType","pt":$n[5].EventQueue.EventType,"ps":0},{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":1},{"n":"e","dv":null,"o":true,"pt":$n[5].Event,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"e","t":4,"rt":$n[5].Event,"sn":"e"},{"a":2,"n":"entry","t":4,"rt":$n[5].TrackEntry,"sn":"entry"},{"a":2,"n":"type","t":4,"rt":$n[5].EventQueue.EventType,"sn":"type","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventQueueEntry end.*/

    /*Spine.EventQueue+EventType start.*/
    $m("Spine.EventQueue.EventType", function () { return {"td":$n[5].EventQueue,"att":259,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[5].EventQueue.EventType,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.EventQueue.EventType, System.Enum.toStringFn(Spine.EventQueue.EventType));}}]}; }, $n);
    /*Spine.EventQueue+EventType end.*/

    /*Spine.EventTimeline start.*/
    $m("Spine.EventTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"e","pt":$n[5].Event,"ps":1}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[5].Event]},{"a":2,"n":"Events","t":16,"rt":System.Array.type(Spine.Event),"g":{"a":2,"n":"get_Events","t":8,"rt":System.Array.type(Spine.Event),"fg":"Events"},"fn":"Events"},{"a":1,"n":"events","t":4,"rt":System.Array.type(Spine.Event),"sn":"events","ro":true},{"a":1,"n":"propertyIds","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.EventTimeline end.*/

    /*Spine.ExposedList$1 start.*/
    $m("Spine.ExposedList$1", function (T) { return {"nested":[$n[5].ExposedList$1.Enumerator],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[2].IEnumerable$1(T)],"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"capacity","pt":$n[0].Int32,"ps":0}],"sn":"$ctor3"},{"a":4,"n":".ctor","t":1,"p":[System.Array.type(T),$n[0].Int32],"pi":[{"n":"data","pt":System.Array.type(T),"ps":0},{"n":"size","pt":$n[0].Int32,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Add","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[T]},{"a":1,"n":"AddCollection","t":8,"pi":[{"n":"collection","pt":$n[2].ICollection$1(T),"ps":0}],"sn":"AddCollection","rt":$n[0].Void,"p":[$n[2].ICollection$1(T)]},{"a":1,"n":"AddEnumerable","t":8,"pi":[{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddEnumerable","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"list","pt":$n[5].ExposedList$1(T),"ps":0}],"sn":"AddRange","rt":$n[0].Void,"p":[$n[5].ExposedList$1(T)]},{"a":2,"n":"AddRange","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"AddRange$1","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"BinarySearch","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":1}],"sn":"BinarySearch$1","rt":$n[0].Int32,"p":[T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BinarySearch","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"item","pt":T,"ps":2},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":3}],"sn":"BinarySearch$2","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,T,$n[2].IComparer$1(T)],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"CheckCollection","t":8,"pi":[{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":0}],"sn":"CheckCollection","rt":$n[0].Void,"p":[$n[2].IEnumerable$1(T)]},{"a":1,"n":"CheckIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"CheckIndex","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"CheckMatch","is":true,"t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"CheckMatch","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"CheckRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"CheckRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Clear","t":8,"pi":[{"n":"clearArray","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"Contains","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Contains","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ConvertAll","t":8,"pi":[{"n":"converter","pt":Function,"ps":0}],"tpc":1,"tprm":["TOutput"],"sn":"ConvertAll","rt":$n[5].ExposedList$1(System.Object),"p":[Function]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0}],"sn":"CopyTo","rt":$n[0].Void,"p":[System.Array.type(T)]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"array","pt":System.Array.type(T),"ps":0},{"n":"arrayIndex","pt":$n[0].Int32,"ps":1}],"sn":"CopyTo$1","rt":$n[0].Void,"p":[System.Array.type(T),$n[0].Int32]},{"a":2,"n":"CopyTo","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"array","pt":System.Array.type(T),"ps":1},{"n":"arrayIndex","pt":$n[0].Int32,"ps":2},{"n":"count","pt":$n[0].Int32,"ps":3}],"sn":"CopyTo$2","rt":$n[0].Void,"p":[$n[0].Int32,System.Array.type(T),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"EnsureCapacity","t":8,"pi":[{"n":"min","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"Exists","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Exists","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Find","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"Find","rt":T,"p":[Function]},{"a":2,"n":"FindAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAll","rt":$n[5].ExposedList$1(T),"p":[Function]},{"a":1,"n":"FindAllList","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindAllList","rt":$n[5].ExposedList$1(T),"p":[Function]},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLast","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLast","rt":T,"p":[Function]},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"FindLastIndex$2","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"match","pt":Function,"ps":1}],"sn":"FindLastIndex$1","rt":$n[0].Int32,"p":[$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"FindLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"FindLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ForEach","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ForEach","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"GetEnumerator","t":8,"sn":"GetEnumerator","rt":$n[5].ExposedList$1.Enumerator(T)},{"a":1,"n":"GetIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetLastIndex","t":8,"pi":[{"n":"startIndex","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"match","pt":Function,"ps":2}],"sn":"GetLastIndex","rt":$n[0].Int32,"p":[$n[0].Int32,$n[0].Int32,Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"GetRange","rt":$n[5].ExposedList$1(T),"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"GrowIfNeeded","t":8,"pi":[{"n":"addedCount","pt":$n[0].Int32,"ps":0}],"sn":"GrowIfNeeded","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"IndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"IndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"IndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"IndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Insert","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"item","pt":T,"ps":1}],"sn":"Insert","rt":$n[0].Void,"p":[$n[0].Int32,T]},{"a":1,"n":"InsertCollection","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].ICollection$1(T),"ps":1}],"sn":"InsertCollection","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].ICollection$1(T)]},{"a":1,"n":"InsertEnumeration","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"enumerable","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertEnumeration","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"InsertRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"collection","pt":$n[2].IEnumerable$1(T),"ps":1}],"sn":"InsertRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].IEnumerable$1(T)]},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"LastIndexOf","rt":$n[0].Int32,"p":[T],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"LastIndexOf$1","rt":$n[0].Int32,"p":[T,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"LastIndexOf","t":8,"pi":[{"n":"item","pt":T,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2}],"sn":"LastIndexOf$2","rt":$n[0].Int32,"p":[T,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Pop","t":8,"sn":"Pop","rt":T},{"a":2,"n":"Remove","t":8,"pi":[{"n":"item","pt":T,"ps":0}],"sn":"Remove","rt":$n[0].Boolean,"p":[T],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"RemoveAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"RemoveAll","rt":$n[0].Int32,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"RemoveAt","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"RemoveAt","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"RemoveRange","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"RemoveRange","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Resize","t":8,"pi":[{"n":"newSize","pt":$n[0].Int32,"ps":0}],"sn":"Resize","rt":$n[5].ExposedList$1(T),"p":[$n[0].Int32]},{"a":2,"n":"Reverse","t":8,"sn":"Reverse","rt":$n[0].Void},{"a":2,"n":"Reverse","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1}],"sn":"Reverse$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":1,"n":"Shift","t":8,"pi":[{"n":"start","pt":$n[0].Int32,"ps":0},{"n":"delta","pt":$n[0].Int32,"ps":1}],"sn":"Shift","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Sort","t":8,"sn":"Sort","rt":$n[0].Void},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":0}],"sn":"Sort$1","rt":$n[0].Void,"p":[$n[2].IComparer$1(T)]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"comparison","pt":Function,"ps":0}],"sn":"Sort$2","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Sort","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"comparer","pt":$n[2].IComparer$1(T),"ps":2}],"sn":"Sort$3","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[2].IComparer$1(T)]},{"a":2,"n":"ToArray","t":8,"sn":"ToArray","rt":System.Array.type(T)},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TrueForAll","t":8,"pi":[{"n":"match","pt":Function,"ps":0}],"sn":"TrueForAll","rt":$n[0].Boolean,"p":[Function],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Capacity","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Capacity","t":8,"rt":$n[0].Int32,"fg":"Capacity","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Capacity","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Capacity"},"fn":"Capacity"},{"a":2,"n":"Count","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"DefaultCapacity","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultCapacity","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"EmptyArray","is":true,"t":4,"rt":System.Array.type(T),"sn":"EmptyArray","ro":true},{"a":2,"n":"Items","t":4,"rt":System.Array.type(T),"sn":"Items"},{"a":1,"n":"version","t":4,"rt":$n[0].Int32,"sn":"version","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1 end.*/

    /*Spine.ExposedList$1+Enumerator start.*/
    $m("Spine.ExposedList$1.Enumerator", function (T) { return {"td":$n[5].ExposedList$1(T),"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":".ctor","t":1,"p":[$n[5].ExposedList$1(T)],"pi":[{"n":"l","pt":$n[5].ExposedList$1(T),"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"MoveNext","t":8,"sn":"moveNext","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"VerifyState","t":8,"sn":"VerifyState","rt":$n[0].Void},{"a":2,"n":"Current","t":16,"rt":T,"g":{"a":2,"n":"get_Current","t":8,"rt":T,"fg":"Current"},"fn":"Current"},{"a":1,"n":"current","t":4,"rt":T,"sn":"current"},{"a":1,"n":"l","t":4,"rt":$n[5].ExposedList$1(T),"sn":"l"},{"a":1,"n":"next","t":4,"rt":$n[0].Int32,"sn":"next","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ver","t":4,"rt":$n[0].Int32,"sn":"ver","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ExposedList$1+Enumerator end.*/

    /*Spine.Format start.*/
    $m("Spine.Format", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[5].Format,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"Intensity","is":true,"t":4,"rt":$n[5].Format,"sn":"Intensity","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"LuminanceAlpha","is":true,"t":4,"rt":$n[5].Format,"sn":"LuminanceAlpha","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB565","is":true,"t":4,"rt":$n[5].Format,"sn":"RGB565","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGB888","is":true,"t":4,"rt":$n[5].Format,"sn":"RGB888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA4444","is":true,"t":4,"rt":$n[5].Format,"sn":"RGBA4444","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}},{"a":2,"n":"RGBA8888","is":true,"t":4,"rt":$n[5].Format,"sn":"RGBA8888","box":function ($v) { return Bridge.box($v, Spine.Format, System.Enum.toStringFn(Spine.Format));}}]}; }, $n);
    /*Spine.Format end.*/

    /*Spine.HashSetExtensions start.*/
    $m("Spine.HashSetExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddAll","is":true,"t":8,"pi":[{"n":"set","pt":$n[2].HashSet$1(System.Object),"ps":0},{"n":"addSet","pt":System.Array.type(System.Object),"ps":1}],"tpc":1,"tprm":["T"],"sn":"AddAll","rt":$n[0].Boolean,"p":[$n[2].HashSet$1(System.Object),System.Array.type(System.Object)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.HashSetExtensions end.*/

    /*Spine.IBoneTimeline start.*/
    $m("Spine.IBoneTimeline", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$IBoneTimeline$BoneIndex"},{"a":1,"backing":true,"n":"<BoneIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$IBoneTimeline$BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IBoneTimeline end.*/

    /*Spine.IHasTextureRegion start.*/
    $m("Spine.IHasTextureRegion", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"UpdateRegion","t":8,"sn":"Spine$IHasTextureRegion$UpdateRegion","rt":$n[0].Void},{"ab":true,"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$A"},"fn":"Spine$IHasTextureRegion$A"},{"ab":true,"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$B"},"fn":"Spine$IHasTextureRegion$B"},{"ab":true,"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$G"},"fn":"Spine$IHasTextureRegion$G"},{"ab":true,"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"ab":true,"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Spine$IHasTextureRegion$Path"},"s":{"ab":true,"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Path"},"fn":"Spine$IHasTextureRegion$Path"},{"ab":true,"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"Spine$IHasTextureRegion$R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ab":true,"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$R"},"fn":"Spine$IHasTextureRegion$R"},{"ab":true,"a":2,"n":"Region","t":16,"rt":$n[5].TextureRegion,"g":{"ab":true,"a":2,"n":"get_Region","t":8,"rt":$n[5].TextureRegion,"fg":"Spine$IHasTextureRegion$Region"},"s":{"ab":true,"a":2,"n":"set_Region","t":8,"p":[$n[5].TextureRegion],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Region"},"fn":"Spine$IHasTextureRegion$Region"},{"ab":true,"a":2,"n":"Sequence","t":16,"rt":$n[5].Sequence,"g":{"ab":true,"a":2,"n":"get_Sequence","t":8,"rt":$n[5].Sequence,"fg":"Spine$IHasTextureRegion$Sequence"},"s":{"ab":true,"a":2,"n":"set_Sequence","t":8,"p":[$n[5].Sequence],"rt":$n[0].Void,"fs":"Spine$IHasTextureRegion$Sequence"},"fn":"Spine$IHasTextureRegion$Sequence"},{"a":1,"backing":true,"n":"<A>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<B>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<G>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Spine$IHasTextureRegion$Path"},{"a":1,"backing":true,"n":"<R>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Spine$IHasTextureRegion$R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Region>k__BackingField","t":4,"rt":$n[5].TextureRegion,"sn":"Spine$IHasTextureRegion$Region"},{"a":1,"backing":true,"n":"<Sequence>k__BackingField","t":4,"rt":$n[5].Sequence,"sn":"Spine$IHasTextureRegion$Sequence"}]}; }, $n);
    /*Spine.IHasTextureRegion end.*/

    /*Spine.IInterpolation start.*/
    $m("Spine.IInterpolation", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"start","pt":$n[0].Single,"ps":0},{"n":"end","pt":$n[0].Single,"ps":1},{"n":"a","pt":$n[0].Single,"ps":2}],"sn":"Apply","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Pow2","is":true,"t":4,"rt":$n[5].IInterpolation,"sn":"Pow2"},{"a":2,"n":"Pow2Out","is":true,"t":4,"rt":$n[5].IInterpolation,"sn":"Pow2Out"}]}; }, $n);
    /*Spine.IInterpolation end.*/

    /*Spine.IkConstraint start.*/
    $m("Spine.IkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].IkConstraint,$n[5].Skeleton],"pi":[{"n":"constraint","pt":$n[5].IkConstraint,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].IkConstraintData,$n[5].Skeleton],"pi":[{"n":"data","pt":$n[5].IkConstraintData,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"targetX","pt":$n[0].Single,"ps":1},{"n":"targetY","pt":$n[0].Single,"ps":2},{"n":"compress","pt":$n[0].Boolean,"ps":3},{"n":"stretch","pt":$n[0].Boolean,"ps":4},{"n":"uniform","pt":$n[0].Boolean,"ps":5},{"n":"alpha","pt":$n[0].Single,"ps":6}],"sn":"Apply$1","rt":$n[0].Void,"p":[$n[5].Bone,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"Apply","is":true,"t":8,"pi":[{"n":"parent","pt":$n[5].Bone,"ps":0},{"n":"child","pt":$n[5].Bone,"ps":1},{"n":"targetX","pt":$n[0].Single,"ps":2},{"n":"targetY","pt":$n[0].Single,"ps":3},{"n":"bendDir","pt":$n[0].Int32,"ps":4},{"n":"stretch","pt":$n[0].Boolean,"ps":5},{"n":"uniform","pt":$n[0].Boolean,"ps":6},{"n":"softness","pt":$n[0].Single,"ps":7},{"n":"alpha","pt":$n[0].Single,"ps":8}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Bone,$n[5].Bone,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Data","t":16,"rt":$n[5].IkConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].IkConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"data","t":4,"rt":$n[5].IkConstraintData,"sn":"data","ro":true},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[5].Bone,"sn":"target"}]}; }, $n);
    /*Spine.IkConstraint end.*/

    /*Spine.IkConstraintData start.*/
    $m("Spine.IkConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"BendDirection","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BendDirection","t":8,"rt":$n[0].Int32,"fg":"BendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_BendDirection","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"BendDirection"},"fn":"BendDirection"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Compress","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Compress","t":8,"rt":$n[0].Boolean,"fg":"Compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Compress","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Compress"},"fn":"Compress"},{"a":2,"n":"Mix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Mix","t":8,"rt":$n[0].Single,"fg":"Mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Mix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Mix"},"fn":"Mix"},{"a":2,"n":"Softness","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Softness","t":8,"rt":$n[0].Single,"fg":"Softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Softness","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Softness"},"fn":"Softness"},{"a":2,"n":"Stretch","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Stretch","t":8,"rt":$n[0].Boolean,"fg":"Stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Stretch","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Stretch"},"fn":"Stretch"},{"a":2,"n":"Target","t":16,"rt":$n[5].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":2,"n":"Uniform","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Uniform","t":8,"rt":$n[0].Boolean,"fg":"Uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Uniform","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Uniform"},"fn":"Uniform"},{"a":4,"n":"bendDirection","t":4,"rt":$n[0].Int32,"sn":"bendDirection","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"compress","t":4,"rt":$n[0].Boolean,"sn":"compress","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mix","t":4,"rt":$n[0].Single,"sn":"mix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"softness","t":4,"rt":$n[0].Single,"sn":"softness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"stretch","t":4,"rt":$n[0].Boolean,"sn":"stretch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[5].BoneData,"sn":"target"},{"a":4,"n":"uniform","t":4,"rt":$n[0].Boolean,"sn":"uniform","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IkConstraintData end.*/

    /*Spine.IkConstraintTimeline start.*/
    $m("Spine.IkConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"ikConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mix","pt":$n[0].Single,"ps":2},{"n":"softness","pt":$n[0].Single,"ps":3},{"n":"bendDirection","pt":$n[0].Int32,"ps":4},{"n":"compress","pt":$n[0].Boolean,"ps":5},{"n":"stretch","pt":$n[0].Boolean,"ps":6}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"IkConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_IkConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"IkConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"IkConstraintIndex"},{"a":1,"n":"BEND_DIRECTION","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEND_DIRECTION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"COMPRESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"COMPRESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SOFTNESS","is":true,"t":4,"rt":$n[0].Int32,"sn":"SOFTNESS","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"STRETCH","is":true,"t":4,"rt":$n[0].Int32,"sn":"STRETCH","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ikConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"ikConstraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.IkConstraintTimeline end.*/

    /*Spine.ISlotTimeline start.*/
    $m("Spine.ISlotTimeline", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Spine$ISlotTimeline$SlotIndex"},{"a":1,"backing":true,"n":"<SlotIndex>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Spine$ISlotTimeline$SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ISlotTimeline end.*/

    /*Spine.IUpdatable start.*/
    $m("Spine.IUpdatable", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Update","t":8,"sn":"Spine$IUpdatable$Update","rt":$n[0].Void},{"ab":true,"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Spine$IUpdatable$Active"},{"a":1,"backing":true,"n":"<Active>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$IUpdatable$Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.IUpdatable end.*/

    /*Spine.Json start.*/
    $m("Spine.Json", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Deserialize","is":true,"t":8,"pi":[{"n":"text","pt":$n[6].TextReader,"ps":0}],"sn":"Deserialize","rt":$n[0].Object,"p":[$n[6].TextReader]}]}; }, $n);
    /*Spine.Json end.*/

    /*Spine.MathUtils start.*/
    $m("Spine.MathUtils", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Atan2","is":true,"t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"Atan2","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Clamp","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0},{"n":"min","pt":$n[0].Single,"ps":1},{"n":"max","pt":$n[0].Single,"ps":2}],"sn":"Clamp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Cos","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Cos","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"CosDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"CosDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1}],"sn":"RandomTriangle","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RandomTriangle","is":true,"t":8,"pi":[{"n":"min","pt":$n[0].Single,"ps":0},{"n":"max","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[0].Single,"ps":2}],"sn":"RandomTriangle$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Sin","is":true,"t":8,"pi":[{"n":"radians","pt":$n[0].Single,"ps":0}],"sn":"Sin","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"SinDeg","is":true,"t":8,"pi":[{"n":"degrees","pt":$n[0].Single,"ps":0}],"sn":"SinDeg","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"DegRad","is":true,"t":4,"rt":$n[0].Single,"sn":"DegRad","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI","is":true,"t":4,"rt":$n[0].Single,"sn":"PI","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"PI2","is":true,"t":4,"rt":$n[0].Single,"sn":"PI2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"RadDeg","is":true,"t":4,"rt":$n[0].Single,"sn":"RadDeg","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"random","is":true,"t":4,"rt":$n[0].Random,"sn":"random"}]}; }, $n);
    /*Spine.MathUtils end.*/

    /*Spine.MeshAttachment start.*/
    $m("Spine.MeshAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].MeshAttachment],"pi":[{"n":"other","pt":$n[5].MeshAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[5].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"a":2,"n":"NewLinkedMesh","t":8,"sn":"NewLinkedMesh","rt":$n[5].MeshAttachment},{"a":2,"n":"UpdateRegion","t":8,"sn":"UpdateRegion","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Edges","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Edges","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Edges"},"s":{"a":2,"n":"set_Edges","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Edges"},"fn":"Edges"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"HullLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_HullLength","t":8,"rt":$n[0].Int32,"fg":"HullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_HullLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"HullLength"},"fn":"HullLength"},{"a":2,"n":"ParentMesh","t":16,"rt":$n[5].MeshAttachment,"g":{"a":2,"n":"get_ParentMesh","t":8,"rt":$n[5].MeshAttachment,"fg":"ParentMesh"},"s":{"a":2,"n":"set_ParentMesh","t":8,"p":[$n[5].MeshAttachment],"rt":$n[0].Void,"fs":"ParentMesh"},"fn":"ParentMesh"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"Region","t":16,"rt":$n[5].TextureRegion,"g":{"a":2,"n":"get_Region","t":8,"rt":$n[5].TextureRegion,"fg":"Region"},"s":{"a":2,"n":"set_Region","t":8,"p":[$n[5].TextureRegion],"rt":$n[0].Void,"fs":"Region"},"fn":"Region"},{"a":2,"n":"RegionUVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_RegionUVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"RegionUVs"},"s":{"a":2,"n":"set_RegionUVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"RegionUVs"},"fn":"RegionUVs"},{"a":2,"n":"Sequence","t":16,"rt":$n[5].Sequence,"g":{"a":2,"n":"get_Sequence","t":8,"rt":$n[5].Sequence,"fg":"Sequence"},"s":{"a":2,"n":"set_Sequence","t":8,"p":[$n[5].Sequence],"rt":$n[0].Void,"fs":"Sequence"},"fn":"Sequence"},{"a":2,"n":"Triangles","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Triangles","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Triangles"},"s":{"a":2,"n":"set_Triangles","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Triangles"},"fn":"Triangles"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"s":{"a":2,"n":"set_UVs","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hullLength","t":4,"rt":$n[0].Int32,"sn":"hullLength","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"parentMesh","t":4,"rt":$n[5].MeshAttachment,"sn":"parentMesh"},{"a":4,"n":"path","t":4,"rt":$n[0].String,"sn":"path"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"region","t":4,"rt":$n[5].TextureRegion,"sn":"region"},{"a":4,"n":"regionUVs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"regionUVs"},{"a":1,"n":"sequence","t":4,"rt":$n[5].Sequence,"sn":"sequence"},{"a":4,"n":"triangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"triangles"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":1,"backing":true,"n":"<Edges>k__BackingField","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"Edges"},{"a":1,"backing":true,"n":"<Height>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Width>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.MeshAttachment end.*/

    /*Spine.MixBlend start.*/
    $m("Spine.MixBlend", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","is":true,"t":4,"rt":$n[5].MixBlend,"sn":"Add","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"First","is":true,"t":4,"rt":$n[5].MixBlend,"sn":"First","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Replace","is":true,"t":4,"rt":$n[5].MixBlend,"sn":"Replace","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":2,"n":"Setup","is":true,"t":4,"rt":$n[5].MixBlend,"sn":"Setup","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}}]}; }, $n);
    /*Spine.MixBlend end.*/

    /*Spine.MixDirection start.*/
    $m("Spine.MixDirection", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"In","is":true,"t":4,"rt":$n[5].MixDirection,"sn":"In","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}},{"a":2,"n":"Out","is":true,"t":4,"rt":$n[5].MixDirection,"sn":"Out","box":function ($v) { return Bridge.box($v, Spine.MixDirection, System.Enum.toStringFn(Spine.MixDirection));}}]}; }, $n);
    /*Spine.MixDirection end.*/

    /*Spine.PathAttachment start.*/
    $m("Spine.PathAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].PathAttachment],"pi":[{"n":"other","pt":$n[5].PathAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"a":2,"n":"Closed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Closed","t":8,"rt":$n[0].Boolean,"fg":"Closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Closed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Closed"},"fn":"Closed"},{"a":2,"n":"ConstantSpeed","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ConstantSpeed","t":8,"rt":$n[0].Boolean,"fg":"ConstantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ConstantSpeed","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ConstantSpeed"},"fn":"ConstantSpeed"},{"a":2,"n":"Lengths","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Lengths","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Lengths"},"s":{"a":2,"n":"set_Lengths","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Lengths"},"fn":"Lengths"},{"a":4,"n":"closed","t":4,"rt":$n[0].Boolean,"sn":"closed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"constantSpeed","t":4,"rt":$n[0].Boolean,"sn":"constantSpeed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"lengths","t":4,"rt":$n[0].Array.type(System.Single),"sn":"lengths"}]}; }, $n);
    /*Spine.PathAttachment end.*/

    /*Spine.PathConstraint start.*/
    $m("Spine.PathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].PathConstraint,$n[5].Skeleton],"pi":[{"n":"constraint","pt":$n[5].PathConstraint,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].PathConstraintData,$n[5].Skeleton],"pi":[{"n":"data","pt":$n[5].PathConstraintData,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"AddAfterPosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddAfterPosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddBeforePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"temp","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"i","pt":$n[0].Int32,"ps":2},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"o","pt":$n[0].Int32,"ps":4}],"sn":"AddBeforePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32]},{"a":1,"n":"AddCurvePosition","is":true,"t":8,"pi":[{"n":"p","pt":$n[0].Single,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"cx1","pt":$n[0].Single,"ps":3},{"n":"cy1","pt":$n[0].Single,"ps":4},{"n":"cx2","pt":$n[0].Single,"ps":5},{"n":"cy2","pt":$n[0].Single,"ps":6},{"n":"x2","pt":$n[0].Single,"ps":7},{"n":"y2","pt":$n[0].Single,"ps":8},{"n":"output","pt":$n[0].Array.type(System.Single),"ps":9},{"n":"o","pt":$n[0].Int32,"ps":10},{"n":"tangents","pt":$n[0].Boolean,"ps":11}],"sn":"AddCurvePosition","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"ArraysFill","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"fromIndex","pt":$n[0].Int32,"ps":1},{"n":"toIndex","pt":$n[0].Int32,"ps":2},{"n":"val","pt":$n[0].Single,"ps":3}],"sn":"ArraysFill","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ComputeWorldPositions","t":8,"pi":[{"n":"path","pt":$n[5].PathAttachment,"ps":0},{"n":"spacesCount","pt":$n[0].Int32,"ps":1},{"n":"tangents","pt":$n[0].Boolean,"ps":2}],"sn":"ComputeWorldPositions","rt":$n[0].Array.type(System.Single),"p":[$n[5].PathAttachment,$n[0].Int32,$n[0].Boolean]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[5].PathConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].PathConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"Target","t":16,"rt":$n[5].Slot,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].Slot,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].Slot],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":1,"n":"AFTER","is":true,"t":4,"rt":$n[0].Int32,"sn":"AFTER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"BEFORE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BEFORE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Epsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"Epsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NONE","is":true,"t":4,"rt":$n[0].Int32,"sn":"NONE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"curves","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"curves","ro":true},{"a":4,"n":"data","t":4,"rt":$n[5].PathConstraintData,"sn":"data","ro":true},{"a":4,"n":"lengths","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"lengths","ro":true},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positions","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"positions","ro":true},{"a":4,"n":"segments","t":4,"rt":$n[0].Array.type(System.Single),"sn":"segments","ro":true},{"a":4,"n":"spaces","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"spaces","ro":true},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[5].Slot,"sn":"target"},{"a":4,"n":"world","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"world","ro":true}]}; }, $n);
    /*Spine.PathConstraint end.*/

    /*Spine.PathConstraintData start.*/
    $m("Spine.PathConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"Position","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Position","t":8,"rt":$n[0].Single,"fg":"Position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Position","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Position"},"fn":"Position"},{"a":2,"n":"PositionMode","t":16,"rt":$n[5].PositionMode,"g":{"a":2,"n":"get_PositionMode","t":8,"rt":$n[5].PositionMode,"fg":"PositionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},"s":{"a":2,"n":"set_PositionMode","t":8,"p":[$n[5].PositionMode],"rt":$n[0].Void,"fs":"PositionMode"},"fn":"PositionMode"},{"a":2,"n":"RotateMix","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_RotateMix","t":8,"rt":$n[0].Single,"fg":"RotateMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_RotateMix","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"RotateMix"},"fn":"RotateMix"},{"a":2,"n":"RotateMode","t":16,"rt":$n[5].RotateMode,"g":{"a":2,"n":"get_RotateMode","t":8,"rt":$n[5].RotateMode,"fg":"RotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},"s":{"a":2,"n":"set_RotateMode","t":8,"p":[$n[5].RotateMode],"rt":$n[0].Void,"fs":"RotateMode"},"fn":"RotateMode"},{"a":2,"n":"Spacing","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Spacing","t":8,"rt":$n[0].Single,"fg":"Spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Spacing","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Spacing"},"fn":"Spacing"},{"a":2,"n":"SpacingMode","t":16,"rt":$n[5].SpacingMode,"g":{"a":2,"n":"get_SpacingMode","t":8,"rt":$n[5].SpacingMode,"fg":"SpacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},"s":{"a":2,"n":"set_SpacingMode","t":8,"p":[$n[5].SpacingMode],"rt":$n[0].Void,"fs":"SpacingMode"},"fn":"SpacingMode"},{"a":2,"n":"Target","t":16,"rt":$n[5].SlotData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].SlotData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].SlotData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"positionMode","t":4,"rt":$n[5].PositionMode,"sn":"positionMode","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":4,"n":"rotateMode","t":4,"rt":$n[5].RotateMode,"sn":"rotateMode","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":4,"n":"spacing","t":4,"rt":$n[0].Single,"sn":"spacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"spacingMode","t":4,"rt":$n[5].SpacingMode,"sn":"spacingMode","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":4,"n":"target","t":4,"rt":$n[5].SlotData,"sn":"target"}]}; }, $n);
    /*Spine.PathConstraintData end.*/

    /*Spine.PathConstraintMixTimeline start.*/
    $m("Spine.PathConstraintMixTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mixRotate","pt":$n[0].Single,"ps":2},{"n":"mixX","pt":$n[0].Single,"ps":3},{"n":"mixY","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintMixTimeline end.*/

    /*Spine.PathConstraintPositionTimeline start.*/
    $m("Spine.PathConstraintPositionTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":1,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintPositionTimeline end.*/

    /*Spine.PathConstraintSpacingTimeline start.*/
    $m("Spine.PathConstraintSpacingTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"pathConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"PathConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PathConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"PathConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PathConstraintIndex"},{"a":1,"n":"pathConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"pathConstraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.PathConstraintSpacingTimeline end.*/

    /*Spine.PointAttachment start.*/
    $m("Spine.PointAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":3,"n":".ctor","t":1,"p":[$n[5].PointAttachment],"pi":[{"n":"other","pt":$n[5].PointAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldPosition","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"ox","out":true,"pt":$n[0].Single,"ps":1},{"n":"oy","out":true,"pt":$n[0].Single,"ps":2}],"sn":"ComputeWorldPosition","rt":$n[0].Void,"p":[$n[5].Bone,$n[0].Single,$n[0].Single]},{"a":2,"n":"ComputeWorldRotation","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"ComputeWorldRotation","rt":$n[0].Single,"p":[$n[5].Bone],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PointAttachment end.*/

    /*Spine.Polygon start.*/
    $m("Spine.Polygon", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":1,"backing":true,"n":"<Count>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Vertices>k__BackingField","t":4,"rt":$n[0].Array.type(System.Single),"sn":"Vertices"}]}; }, $n);
    /*Spine.Polygon end.*/

    /*Spine.Pool$1 start.*/
    $m("Spine.Pool$1", function (T) { return {"nested":[$n[5].Pool$1.IPoolable],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32],"pi":[{"n":"initialCapacity","dv":16,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"max","dv":2147483647,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Free","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Free","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Obtain","t":8,"sn":"Obtain","rt":T},{"a":3,"n":"Reset","t":8,"pi":[{"n":"obj","pt":T,"ps":0}],"sn":"Reset","rt":$n[0].Void,"p":[T]},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Count"},{"a":2,"n":"Peak","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Peak","t":8,"rt":$n[0].Int32,"fg":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_Peak","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Peak"},"fn":"Peak"},{"a":1,"n":"freeObjects","t":4,"rt":$n[2].Stack$1(T),"sn":"freeObjects","ro":true},{"a":2,"n":"max","t":4,"rt":$n[0].Int32,"sn":"max","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Peak>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"Peak","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Pool$1 end.*/

    /*Spine.Pool$1+IPoolable start.*/
    $m("Spine.Pool$1.IPoolable", function (T) { return {"td":$n[5].Pool$1(T),"att":1048738,"a":2,"m":[{"ab":true,"a":2,"n":"Reset","t":8,"sn":"Spine$Pool$1$IPoolable$" + Bridge.getTypeAlias(T) + "$Reset","rt":$n[0].Void}]}; }, $n);
    /*Spine.Pool$1+IPoolable end.*/

    /*Spine.PositionMode start.*/
    $m("Spine.PositionMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[5].PositionMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[5].PositionMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.PositionMode, System.Enum.toStringFn(Spine.PositionMode));}}]}; }, $n);
    /*Spine.PositionMode end.*/

    /*Spine.Pow start.*/
    $m("Spine.Pow", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Power","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Power","t":8,"rt":$n[0].Single,"fg":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Power","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Power"},"fn":"Power"},{"a":1,"backing":true,"n":"<Power>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Power","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Pow end.*/

    /*Spine.PowOut start.*/
    $m("Spine.PowOut", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Single],"pi":[{"n":"power","pt":$n[0].Single,"ps":0}],"sn":"ctor"},{"ov":true,"a":3,"n":"Apply","t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0}],"sn":"Apply$1","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.PowOut end.*/

    /*Spine.Property start.*/
    $m("Spine.Property", function () { return {"att":256,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Alpha","is":true,"t":4,"rt":$n[5].Property,"sn":"Alpha","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Attachment","is":true,"t":4,"rt":$n[5].Property,"sn":"Attachment","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Deform","is":true,"t":4,"rt":$n[5].Property,"sn":"Deform","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"DrawOrder","is":true,"t":4,"rt":$n[5].Property,"sn":"DrawOrder","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Event","is":true,"t":4,"rt":$n[5].Property,"sn":"Event","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"IkConstraint","is":true,"t":4,"rt":$n[5].Property,"sn":"IkConstraint","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintMix","is":true,"t":4,"rt":$n[5].Property,"sn":"PathConstraintMix","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintPosition","is":true,"t":4,"rt":$n[5].Property,"sn":"PathConstraintPosition","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"PathConstraintSpacing","is":true,"t":4,"rt":$n[5].Property,"sn":"PathConstraintSpacing","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"RGB","is":true,"t":4,"rt":$n[5].Property,"sn":"RGB","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"RGB2","is":true,"t":4,"rt":$n[5].Property,"sn":"RGB2","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Rotate","is":true,"t":4,"rt":$n[5].Property,"sn":"Rotate","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ScaleX","is":true,"t":4,"rt":$n[5].Property,"sn":"ScaleX","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ScaleY","is":true,"t":4,"rt":$n[5].Property,"sn":"ScaleY","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Sequence","is":true,"t":4,"rt":$n[5].Property,"sn":"Sequence","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ShearX","is":true,"t":4,"rt":$n[5].Property,"sn":"ShearX","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"ShearY","is":true,"t":4,"rt":$n[5].Property,"sn":"ShearY","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"TransformConstraint","is":true,"t":4,"rt":$n[5].Property,"sn":"TransformConstraint","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"X","is":true,"t":4,"rt":$n[5].Property,"sn":"X","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}},{"a":2,"n":"Y","is":true,"t":4,"rt":$n[5].Property,"sn":"Y","box":function ($v) { return Bridge.box($v, Spine.Property, System.Enum.toStringFn(Spine.Property));}}]}; }, $n);
    /*Spine.Property end.*/

    /*Spine.RegionAttachment start.*/
    $m("Spine.RegionAttachment", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].RegionAttachment],"pi":[{"n":"other","pt":$n[5].RegionAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1},{"n":"offset","pt":$n[0].Int32,"ps":2},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[5].Slot,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"ov":true,"a":2,"n":"Copy","t":8,"sn":"Copy","rt":$n[5].Attachment},{"a":2,"n":"UpdateRegion","t":8,"sn":"UpdateRegion","rt":$n[0].Void},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"Offset","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Offset","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Offset"},"fn":"Offset"},{"a":2,"n":"Path","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Path","t":8,"rt":$n[0].String,"fg":"Path"},"s":{"a":2,"n":"set_Path","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Path"},"fn":"Path"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"Region","t":16,"rt":$n[5].TextureRegion,"g":{"a":2,"n":"get_Region","t":8,"rt":$n[5].TextureRegion,"fg":"Region"},"s":{"a":2,"n":"set_Region","t":8,"p":[$n[5].TextureRegion],"rt":$n[0].Void,"fs":"Region"},"fn":"Region"},{"a":2,"n":"Rotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Rotation","t":8,"rt":$n[0].Single,"fg":"Rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Rotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Rotation"},"fn":"Rotation"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Sequence","t":16,"rt":$n[5].Sequence,"g":{"a":2,"n":"get_Sequence","t":8,"rt":$n[5].Sequence,"fg":"Sequence"},"s":{"a":2,"n":"set_Sequence","t":8,"p":[$n[5].Sequence],"rt":$n[0].Void,"fs":"Sequence"},"fn":"Sequence"},{"a":2,"n":"UVs","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_UVs","t":8,"rt":$n[0].Array.type(System.Single),"fg":"UVs"},"fn":"UVs"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":2,"n":"BLX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BLY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BLY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BRY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BRY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULX","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ULY","is":true,"t":4,"rt":$n[0].Int32,"sn":"ULY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URX","is":true,"t":4,"rt":$n[0].Int32,"sn":"URX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"URY","is":true,"t":4,"rt":$n[0].Int32,"sn":"URY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offset","t":4,"rt":$n[0].Array.type(System.Single),"sn":"offset"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"region","t":4,"rt":$n[5].TextureRegion,"sn":"region"},{"a":4,"n":"rotation","t":4,"rt":$n[0].Single,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"sequence","t":4,"rt":$n[5].Sequence,"sn":"sequence"},{"a":4,"n":"uvs","t":4,"rt":$n[0].Array.type(System.Single),"sn":"uvs"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Path>k__BackingField","t":4,"rt":$n[0].String,"sn":"Path"}]}; }, $n);
    /*Spine.RegionAttachment end.*/

    /*Spine.RGB2Timeline start.*/
    $m("Spine.RGB2Timeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"r2","pt":$n[0].Single,"ps":5},{"n":"g2","pt":$n[0].Single,"ps":6},{"n":"b2","pt":$n[0].Single,"ps":7}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGB2Timeline end.*/

    /*Spine.RGBA2Timeline start.*/
    $m("Spine.RGBA2Timeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5},{"n":"r2","pt":$n[0].Single,"ps":6},{"n":"g2","pt":$n[0].Single,"ps":7},{"n":"b2","pt":$n[0].Single,"ps":8}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B2","is":true,"t":4,"rt":$n[0].Int32,"sn":"B2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G2","is":true,"t":4,"rt":$n[0].Int32,"sn":"G2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R2","is":true,"t":4,"rt":$n[0].Int32,"sn":"R2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBA2Timeline end.*/

    /*Spine.RGBATimeline start.*/
    $m("Spine.RGBATimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4},{"n":"a","pt":$n[0].Single,"ps":5}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"A","is":true,"t":4,"rt":$n[0].Int32,"sn":"A","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBATimeline end.*/

    /*Spine.RGBTimeline start.*/
    $m("Spine.RGBTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"r","pt":$n[0].Single,"ps":2},{"n":"g","pt":$n[0].Single,"ps":3},{"n":"b","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":3,"n":"B","is":true,"t":4,"rt":$n[0].Int32,"sn":"B","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"G","is":true,"t":4,"rt":$n[0].Int32,"sn":"G","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"R","is":true,"t":4,"rt":$n[0].Int32,"sn":"R","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RGBTimeline end.*/

    /*Spine.RotateMode start.*/
    $m("Spine.RotateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Chain","is":true,"t":4,"rt":$n[5].RotateMode,"sn":"Chain","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"ChainScale","is":true,"t":4,"rt":$n[5].RotateMode,"sn":"ChainScale","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}},{"a":2,"n":"Tangent","is":true,"t":4,"rt":$n[5].RotateMode,"sn":"Tangent","box":function ($v) { return Bridge.box($v, Spine.RotateMode, System.Enum.toStringFn(Spine.RotateMode));}}]}; }, $n);
    /*Spine.RotateMode end.*/

    /*Spine.RotateTimeline start.*/
    $m("Spine.RotateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.RotateTimeline end.*/

    /*Spine.ScaleTimeline start.*/
    $m("Spine.ScaleTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleTimeline end.*/

    /*Spine.ScaleXTimeline start.*/
    $m("Spine.ScaleXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleXTimeline end.*/

    /*Spine.ScaleYTimeline start.*/
    $m("Spine.ScaleYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ScaleYTimeline end.*/

    /*Spine.Sequence start.*/
    $m("Spine.Sequence", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Sequence],"pi":[{"n":"other","pt":$n[5].Sequence,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32],"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"Apply","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"attachment","pt":$n[5].IHasTextureRegion,"ps":1}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Slot,$n[5].IHasTextureRegion]},{"a":2,"n":"GetPath","t":8,"pi":[{"n":"basePath","pt":$n[0].String,"ps":0},{"n":"index","pt":$n[0].Int32,"ps":1}],"sn":"GetPath","rt":$n[0].String,"p":[$n[0].String,$n[0].Int32]},{"a":2,"n":"Digits","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Digits","t":8,"rt":$n[0].Int32,"fg":"Digits","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Digits","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Digits"},"fn":"Digits"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"Regions","t":16,"rt":System.Array.type(Spine.TextureRegion),"g":{"a":2,"n":"get_Regions","t":8,"rt":System.Array.type(Spine.TextureRegion),"fg":"Regions"},"fn":"Regions"},{"a":2,"n":"SetupIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SetupIndex","t":8,"rt":$n[0].Int32,"fg":"SetupIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SetupIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SetupIndex"},"fn":"SetupIndex"},{"a":2,"n":"Start","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Start","t":8,"rt":$n[0].Int32,"fg":"Start","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Start","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Start"},"fn":"Start"},{"a":4,"n":"digits","t":4,"rt":$n[0].Int32,"sn":"digits","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"regions","t":4,"rt":System.Array.type(Spine.TextureRegion),"sn":"regions","ro":true},{"a":4,"n":"setupIndex","t":4,"rt":$n[0].Int32,"sn":"setupIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"start","t":4,"rt":$n[0].Int32,"sn":"start","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Sequence end.*/

    /*Spine.SequenceMode start.*/
    $m("Spine.SequenceMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Hold","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"Hold","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Loop","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"Loop","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"LoopReverse","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"LoopReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Once","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"Once","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"OnceReverse","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"OnceReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"Pingpong","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"Pingpong","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}},{"a":2,"n":"PingpongReverse","is":true,"t":4,"rt":$n[5].SequenceMode,"sn":"PingpongReverse","box":function ($v) { return Bridge.box($v, Spine.SequenceMode, System.Enum.toStringFn(Spine.SequenceMode));}}]}; }, $n);
    /*Spine.SequenceMode end.*/

    /*Spine.SequenceTimeline start.*/
    $m("Spine.SequenceTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[5].Attachment],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"attachment","pt":$n[5].Attachment,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mode","pt":$n[5].SequenceMode,"ps":2},{"n":"index","pt":$n[0].Int32,"ps":3},{"n":"delay","pt":$n[0].Single,"ps":4}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[5].SequenceMode,$n[0].Int32,$n[0].Single]},{"a":2,"n":"Attachment","t":16,"rt":$n[5].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[5].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":1,"n":"DELAY","is":true,"t":4,"rt":$n[0].Int32,"sn":"DELAY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"MODE","is":true,"t":4,"rt":$n[0].Int32,"sn":"MODE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"attachment","t":4,"rt":$n[5].IHasTextureRegion,"sn":"attachment","ro":true},{"a":1,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SequenceTimeline end.*/

    /*Spine.ShearTimeline start.*/
    $m("Spine.ShearTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearTimeline end.*/

    /*Spine.ShearXTimeline start.*/
    $m("Spine.ShearXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearXTimeline end.*/

    /*Spine.ShearYTimeline start.*/
    $m("Spine.ShearYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.ShearYTimeline end.*/

    /*Spine.Skeleton start.*/
    $m("Spine.Skeleton", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Skeleton],"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].SkeletonData],"pi":[{"n":"data","pt":$n[5].SkeletonData,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[5].Bone,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[5].IkConstraint,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[5].PathConstraint,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[5].Slot,"p":[$n[0].String]},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[5].TransformConstraint,"p":[$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[5].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"GetAttachment$1","rt":$n[5].Attachment,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetBounds","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"width","out":true,"pt":$n[0].Single,"ps":2},{"n":"height","out":true,"pt":$n[0].Single,"ps":3},{"n":"vertexBuffer","ref":true,"pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"GetBounds","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Array.type(System.Single)]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetBonesToSetupPose","t":8,"sn":"SetBonesToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"newSkin","pt":$n[5].Skin,"ps":0}],"sn":"SetSkin","rt":$n[0].Void,"p":[$n[5].Skin]},{"a":2,"n":"SetSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"SetSkin$1","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"SetSlotsToSetupPose","t":8,"sn":"SetSlotsToSetupPose","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"a":1,"n":"SortBone","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"SortBone","rt":$n[0].Void,"p":[$n[5].Bone]},{"a":1,"n":"SortIkConstraint","t":8,"pi":[{"n":"constraint","pt":$n[5].IkConstraint,"ps":0}],"sn":"SortIkConstraint","rt":$n[0].Void,"p":[$n[5].IkConstraint]},{"a":1,"n":"SortPathConstraint","t":8,"pi":[{"n":"constraint","pt":$n[5].PathConstraint,"ps":0}],"sn":"SortPathConstraint","rt":$n[0].Void,"p":[$n[5].PathConstraint]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"attachment","pt":$n[5].Attachment,"ps":0},{"n":"slotBone","pt":$n[5].Bone,"ps":1}],"sn":"SortPathConstraintAttachment","rt":$n[0].Void,"p":[$n[5].Attachment,$n[5].Bone]},{"a":1,"n":"SortPathConstraintAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"slotBone","pt":$n[5].Bone,"ps":2}],"sn":"SortPathConstraintAttachment$1","rt":$n[0].Void,"p":[$n[5].Skin,$n[0].Int32,$n[5].Bone]},{"a":1,"n":"SortReset","is":true,"t":8,"pi":[{"n":"bones","pt":$n[5].ExposedList$1(Spine.Bone),"ps":0}],"sn":"SortReset","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Bone)]},{"a":1,"n":"SortTransformConstraint","t":8,"pi":[{"n":"constraint","pt":$n[5].TransformConstraint,"ps":0}],"sn":"SortTransformConstraint","rt":$n[0].Void,"p":[$n[5].TransformConstraint]},{"a":2,"n":"UpdateCache","t":8,"sn":"UpdateCache","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"sn":"UpdateWorldTransform","rt":$n[0].Void},{"a":2,"n":"UpdateWorldTransform","t":8,"pi":[{"n":"parent","pt":$n[5].Bone,"ps":0}],"sn":"UpdateWorldTransform$1","rt":$n[0].Void,"p":[$n[5].Bone]},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[5].SkeletonData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].SkeletonData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"DrawOrder","t":16,"rt":$n[5].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_DrawOrder","t":8,"rt":$n[5].ExposedList$1(Spine.Slot),"fg":"DrawOrder"},"fn":"DrawOrder"},{"a":2,"n":"FlipX","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipX","t":8,"rt":$n[0].Boolean,"fg":"FlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipX","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipX"},"fn":"FlipX"},{"a":2,"n":"FlipY","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_FlipY","t":8,"rt":$n[0].Boolean,"fg":"FlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_FlipY","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"FlipY"},"fn":"FlipY"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.IkConstraint),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.IkConstraint),"fg":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.PathConstraint),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.PathConstraint),"fg":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"RootBone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_RootBone","t":8,"rt":$n[5].Bone,"fg":"RootBone"},"fn":"RootBone"},{"a":2,"n":"ScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleX","t":8,"rt":$n[0].Single,"fg":"ScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleX"},"fn":"ScaleX"},{"a":2,"n":"ScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_ScaleY","t":8,"rt":$n[0].Single,"fg":"ScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_ScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"ScaleY"},"fn":"ScaleY"},{"a":2,"n":"Skin","t":16,"rt":$n[5].Skin,"g":{"a":2,"n":"get_Skin","t":8,"rt":$n[5].Skin,"fg":"Skin"},"s":{"a":2,"n":"set_Skin","t":8,"p":[$n[5].Skin],"rt":$n[0].Void,"fs":"Skin"},"fn":"Skin"},{"a":2,"n":"Slots","t":16,"rt":$n[5].ExposedList$1(Spine.Slot),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[5].ExposedList$1(Spine.Slot),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.TransformConstraint),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.TransformConstraint),"fg":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"UpdateCacheList","t":16,"rt":$n[5].ExposedList$1(Spine.IUpdatable),"g":{"a":2,"n":"get_UpdateCacheList","t":8,"rt":$n[5].ExposedList$1(Spine.IUpdatable),"fg":"UpdateCacheList"},"fn":"UpdateCacheList"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.Bone),"sn":"bones"},{"a":4,"n":"data","t":4,"rt":$n[5].SkeletonData,"sn":"data"},{"a":4,"n":"drawOrder","t":4,"rt":$n[5].ExposedList$1(Spine.Slot),"sn":"drawOrder"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.IkConstraint),"sn":"ikConstraints"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.PathConstraint),"sn":"pathConstraints"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleX","t":4,"rt":$n[0].Single,"sn":"scaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"scaleY","t":4,"rt":$n[0].Single,"sn":"scaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"skin","t":4,"rt":$n[5].Skin,"sn":"skin"},{"a":4,"n":"slots","t":4,"rt":$n[5].ExposedList$1(Spine.Slot),"sn":"slots"},{"a":4,"n":"transformConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.TransformConstraint),"sn":"transformConstraints"},{"a":4,"n":"updateCache","t":4,"rt":$n[5].ExposedList$1(Spine.IUpdatable),"sn":"updateCache"},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Skeleton end.*/

    /*Spine.SkeletonBinary start.*/
    $m("Spine.SkeletonBinary", function () { return {"nested":[$n[5].SkeletonBinary.Vertices,$n[5].SkeletonBinary.SkeletonInput],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"GetVersionString","is":true,"t":8,"pi":[{"n":"file","pt":$n[6].Stream,"ps":0}],"sn":"GetVersionString","rt":$n[0].String,"p":[$n[6].Stream]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":1},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[5].Animation,"p":[$n[0].String,$n[5].SkeletonBinary.SkeletonInput,$n[5].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1},{"n":"skin","pt":$n[5].Skin,"ps":2},{"n":"slotIndex","pt":$n[0].Int32,"ps":3},{"n":"attachmentName","pt":$n[0].String,"ps":4},{"n":"nonessential","pt":$n[0].Boolean,"ps":5}],"sn":"ReadAttachment","rt":$n[5].Attachment,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[5].SkeletonData,$n[5].Skin,$n[0].Int32,$n[0].String,$n[0].Boolean]},{"a":1,"n":"ReadFloatArray","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"n","pt":$n[0].Int32,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[5].SkeletonBinary.SkeletonInput,$n[0].Int32,$n[0].Single]},{"a":1,"n":"ReadSequence","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0}],"sn":"ReadSequence","rt":$n[5].Sequence,"p":[$n[5].SkeletonBinary.SkeletonInput]},{"a":1,"n":"ReadShortArray","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0}],"sn":"ReadShortArray","rt":$n[0].Array.type(System.Int32),"p":[$n[5].SkeletonBinary.SkeletonInput]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"file","pt":$n[6].Stream,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[5].SkeletonData,"p":[$n[6].Stream]},{"ov":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadSkin","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1},{"n":"defaultSkin","pt":$n[0].Boolean,"ps":2},{"n":"nonessential","pt":$n[0].Boolean,"ps":3}],"sn":"ReadSkin","rt":$n[5].Skin,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[5].SkeletonData,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ReadTimeline","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline1,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadTimeline","rt":$n[5].Timeline,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[5].CurveTimeline1,$n[0].Single]},{"a":1,"n":"ReadTimeline","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline2,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadTimeline$1","rt":$n[5].Timeline,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[5].CurveTimeline2,$n[0].Single]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1}],"sn":"ReadVertices","rt":$n[5].SkeletonBinary.Vertices,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[0].Int32]},{"a":1,"n":"SetBezier","t":8,"pi":[{"n":"input","pt":$n[5].SkeletonBinary.SkeletonInput,"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline,"ps":1},{"n":"bezier","pt":$n[0].Int32,"ps":2},{"n":"frame","pt":$n[0].Int32,"ps":3},{"n":"value","pt":$n[0].Int32,"ps":4},{"n":"time1","pt":$n[0].Single,"ps":5},{"n":"time2","pt":$n[0].Single,"ps":6},{"n":"value1","pt":$n[0].Single,"ps":7},{"n":"value2","pt":$n[0].Single,"ps":8},{"n":"scale","pt":$n[0].Single,"ps":9}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[5].SkeletonBinary.SkeletonInput,$n[5].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"ATTACHMENT_DEFORM","is":true,"t":4,"rt":$n[0].Int32,"sn":"ATTACHMENT_DEFORM","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ATTACHMENT_SEQUENCE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ATTACHMENT_SEQUENCE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SCALEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SCALEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEARX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEARX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_SHEARY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_SHEARY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"BONE_TRANSLATEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"BONE_TRANSLATEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_BEZIER","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_BEZIER","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_LINEAR","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_LINEAR","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CURVE_STEPPED","is":true,"t":4,"rt":$n[0].Int32,"sn":"CURVE_STEPPED","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_MIX","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_MIX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_POSITION","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_POSITION","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"PATH_SPACING","is":true,"t":4,"rt":$n[0].Int32,"sn":"PATH_SPACING","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ALPHA","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ALPHA","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_ATTACHMENT","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_ATTACHMENT","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGB","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGB","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGB2","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGB2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGBA","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGBA","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SLOT_RGBA2","is":true,"t":4,"rt":$n[0].Int32,"sn":"SLOT_RGBA2","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TransformModeValues","is":true,"t":4,"rt":System.Array.type(Spine.TransformMode),"sn":"TransformModeValues","ro":true}]}; }, $n);
    /*Spine.SkeletonBinary end.*/

    /*Spine.SkeletonBinary+Vertices start.*/
    $m("Spine.SkeletonBinary.Vertices", function () { return {"td":$n[5].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":2,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"}]}; }, $n);
    /*Spine.SkeletonBinary+Vertices end.*/

    /*Spine.SkeletonBinary+SkeletonInput start.*/
    $m("Spine.SkeletonBinary.SkeletonInput", function () { return {"td":$n[5].SkeletonBinary,"att":1048581,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[6].Stream],"pi":[{"n":"input","pt":$n[6].Stream,"ps":0}],"sn":"ctor"},{"a":2,"n":"GetVersionString","t":8,"sn":"GetVersionString","rt":$n[0].String},{"a":2,"n":"GetVersionStringOld3X","t":8,"sn":"GetVersionStringOld3X","rt":$n[0].String},{"a":2,"n":"Read","t":8,"sn":"Read","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadBoolean","t":8,"sn":"ReadBoolean","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ReadByte","t":8,"sn":"ReadByte","rt":$n[0].Byte,"box":function ($v) { return Bridge.box($v, System.Byte);}},{"a":2,"n":"ReadFloat","t":8,"sn":"ReadFloat","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ReadFully","t":8,"pi":[{"n":"buffer","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"offset","pt":$n[0].Int32,"ps":1},{"n":"length","pt":$n[0].Int32,"ps":2}],"sn":"ReadFully","rt":$n[0].Void,"p":[$n[0].Array.type(System.Byte),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ReadInt","t":8,"sn":"ReadInt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadInt","t":8,"pi":[{"n":"optimizePositive","pt":$n[0].Boolean,"ps":0}],"sn":"ReadInt$1","rt":$n[0].Int32,"p":[$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadLong","t":8,"sn":"ReadLong","rt":$n[0].Int64},{"a":2,"n":"ReadSByte","t":8,"sn":"ReadSByte","rt":$n[0].SByte,"box":function ($v) { return Bridge.box($v, System.SByte);}},{"a":2,"n":"ReadString","t":8,"sn":"ReadString","rt":$n[0].String},{"a":2,"n":"ReadStringRef","t":8,"sn":"ReadStringRef","rt":$n[0].String},{"a":1,"n":"bytesBigEndian","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"bytesBigEndian"},{"a":1,"n":"chars","t":4,"rt":$n[0].Array.type(System.Byte),"sn":"chars"},{"a":1,"n":"input","t":4,"rt":$n[6].Stream,"sn":"input"},{"a":4,"n":"strings","t":4,"rt":$n[0].Array.type(System.String),"sn":"strings"}]}; }, $n);
    /*Spine.SkeletonBinary+SkeletonInput end.*/

    /*Spine.SkeletonBounds start.*/
    $m("Spine.SkeletonBounds", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AabbCompute","t":8,"sn":"AabbCompute","rt":$n[0].Void},{"a":2,"n":"AabbContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"AabbContainsPoint","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"AabbIntersectsSegment","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AabbIntersectsSkeleton","t":8,"pi":[{"n":"bounds","pt":$n[5].SkeletonBounds,"ps":0}],"sn":"AabbIntersectsSkeleton","rt":$n[0].Boolean,"p":[$n[5].SkeletonBounds],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"x","pt":$n[0].Single,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"ContainsPoint","rt":$n[5].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single]},{"a":2,"n":"ContainsPoint","t":8,"pi":[{"n":"polygon","pt":$n[5].Polygon,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"ContainsPoint$1","rt":$n[0].Boolean,"p":[$n[5].Polygon,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetPolygon","t":8,"pi":[{"n":"attachment","pt":$n[5].BoundingBoxAttachment,"ps":0}],"sn":"GetPolygon","rt":$n[5].Polygon,"p":[$n[5].BoundingBoxAttachment]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3}],"sn":"IntersectsSegment","rt":$n[5].BoundingBoxAttachment,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"IntersectsSegment","t":8,"pi":[{"n":"polygon","pt":$n[5].Polygon,"ps":0},{"n":"x1","pt":$n[0].Single,"ps":1},{"n":"y1","pt":$n[0].Single,"ps":2},{"n":"x2","pt":$n[0].Single,"ps":3},{"n":"y2","pt":$n[0].Single,"ps":4}],"sn":"IntersectsSegment$1","rt":$n[0].Boolean,"p":[$n[5].Polygon,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Update","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"updateAabb","pt":$n[0].Boolean,"ps":1}],"sn":"Update","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Boolean]},{"a":2,"n":"BoundingBoxes","t":16,"rt":$n[5].ExposedList$1(Spine.BoundingBoxAttachment),"g":{"a":2,"n":"get_BoundingBoxes","t":8,"rt":$n[5].ExposedList$1(Spine.BoundingBoxAttachment),"fg":"BoundingBoxes"},"s":{"a":1,"n":"set_BoundingBoxes","t":8,"p":[$n[5].ExposedList$1(Spine.BoundingBoxAttachment)],"rt":$n[0].Void,"fs":"BoundingBoxes"},"fn":"BoundingBoxes"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Height"},{"a":2,"n":"MaxX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxX","t":8,"rt":$n[0].Single,"fg":"MaxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxX"},"fn":"MaxX"},{"a":2,"n":"MaxY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxY","t":8,"rt":$n[0].Single,"fg":"MaxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxY"},"fn":"MaxY"},{"a":2,"n":"MinX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinX","t":8,"rt":$n[0].Single,"fg":"MinX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinX"},"fn":"MinX"},{"a":2,"n":"MinY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MinY","t":8,"rt":$n[0].Single,"fg":"MinY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MinY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MinY"},"fn":"MinY"},{"a":2,"n":"Polygons","t":16,"rt":$n[5].ExposedList$1(Spine.Polygon),"g":{"a":2,"n":"get_Polygons","t":8,"rt":$n[5].ExposedList$1(Spine.Polygon),"fg":"Polygons"},"s":{"a":1,"n":"set_Polygons","t":8,"p":[$n[5].ExposedList$1(Spine.Polygon)],"rt":$n[0].Void,"fs":"Polygons"},"fn":"Polygons"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Width"},{"a":1,"n":"maxX","t":4,"rt":$n[0].Single,"sn":"maxX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"maxY","t":4,"rt":$n[0].Single,"sn":"maxY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minX","t":4,"rt":$n[0].Single,"sn":"minX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"minY","t":4,"rt":$n[0].Single,"sn":"minY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"polygonPool","t":4,"rt":$n[5].ExposedList$1(Spine.Polygon),"sn":"polygonPool"},{"a":1,"backing":true,"n":"<BoundingBoxes>k__BackingField","t":4,"rt":$n[5].ExposedList$1(Spine.BoundingBoxAttachment),"sn":"BoundingBoxes"},{"a":1,"backing":true,"n":"<Polygons>k__BackingField","t":4,"rt":$n[5].ExposedList$1(Spine.Polygon),"sn":"Polygons"}]}; }, $n);
    /*Spine.SkeletonBounds end.*/

    /*Spine.SkeletonClipping start.*/
    $m("Spine.SkeletonClipping", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Clip","t":8,"pi":[{"n":"x1","pt":$n[0].Single,"ps":0},{"n":"y1","pt":$n[0].Single,"ps":1},{"n":"x2","pt":$n[0].Single,"ps":2},{"n":"y2","pt":$n[0].Single,"ps":3},{"n":"x3","pt":$n[0].Single,"ps":4},{"n":"y3","pt":$n[0].Single,"ps":5},{"n":"clippingArea","pt":$n[5].ExposedList$1(System.Single),"ps":6},{"n":"output","pt":$n[5].ExposedList$1(System.Single),"ps":7}],"sn":"Clip","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(System.Single),$n[5].ExposedList$1(System.Single)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ClipEnd","t":8,"sn":"ClipEnd","rt":$n[0].Void},{"a":2,"n":"ClipEnd","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0}],"sn":"ClipEnd$1","rt":$n[0].Void,"p":[$n[5].Slot]},{"a":2,"n":"ClipStart","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"clip","pt":$n[5].ClippingAttachment,"ps":1}],"sn":"ClipStart","rt":$n[0].Int32,"p":[$n[5].Slot,$n[5].ClippingAttachment],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ClipTriangles","t":8,"pi":[{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"verticesLength","pt":$n[0].Int32,"ps":1},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":2},{"n":"trianglesLength","pt":$n[0].Int32,"ps":3},{"n":"uvs","pt":$n[0].Array.type(System.Single),"ps":4}],"sn":"ClipTriangles","rt":$n[0].Void,"p":[$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Array.type(System.Int32),$n[0].Int32,$n[0].Array.type(System.Single)]},{"a":2,"n":"MakeClockwise","is":true,"t":8,"pi":[{"n":"polygon","pt":$n[5].ExposedList$1(System.Single),"ps":0}],"sn":"MakeClockwise","rt":$n[0].Void,"p":[$n[5].ExposedList$1(System.Single)]},{"a":2,"n":"ClippedTriangles","t":16,"rt":$n[5].ExposedList$1(System.Int32),"g":{"a":2,"n":"get_ClippedTriangles","t":8,"rt":$n[5].ExposedList$1(System.Int32),"fg":"ClippedTriangles"},"fn":"ClippedTriangles"},{"a":2,"n":"ClippedUVs","t":16,"rt":$n[5].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedUVs","t":8,"rt":$n[5].ExposedList$1(System.Single),"fg":"ClippedUVs"},"fn":"ClippedUVs"},{"a":2,"n":"ClippedVertices","t":16,"rt":$n[5].ExposedList$1(System.Single),"g":{"a":2,"n":"get_ClippedVertices","t":8,"rt":$n[5].ExposedList$1(System.Single),"fg":"ClippedVertices"},"fn":"ClippedVertices"},{"a":2,"n":"IsClipping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClipping","t":8,"rt":$n[0].Boolean,"fg":"IsClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClipping"},{"a":4,"n":"clipAttachment","t":4,"rt":$n[5].ClippingAttachment,"sn":"clipAttachment"},{"a":4,"n":"clipOutput","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"clipOutput","ro":true},{"a":4,"n":"clippedTriangles","t":4,"rt":$n[5].ExposedList$1(System.Int32),"sn":"clippedTriangles","ro":true},{"a":4,"n":"clippedUVs","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"clippedUVs","ro":true},{"a":4,"n":"clippedVertices","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"clippedVertices","ro":true},{"a":4,"n":"clippingPolygon","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"clippingPolygon","ro":true},{"a":4,"n":"clippingPolygons","t":4,"rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"clippingPolygons"},{"a":4,"n":"scratch","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"scratch","ro":true},{"a":4,"n":"triangulator","t":4,"rt":$n[5].Triangulator,"sn":"triangulator","ro":true}]}; }, $n);
    /*Spine.SkeletonClipping end.*/

    /*Spine.SkeletonData start.*/
    $m("Spine.SkeletonData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FindAnimation","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0}],"sn":"FindAnimation","rt":$n[5].Animation,"p":[$n[0].String]},{"a":2,"n":"FindBone","t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0}],"sn":"FindBone","rt":$n[5].BoneData,"p":[$n[0].String]},{"a":2,"n":"FindEvent","t":8,"pi":[{"n":"eventDataName","pt":$n[0].String,"ps":0}],"sn":"FindEvent","rt":$n[5].EventData,"p":[$n[0].String]},{"a":2,"n":"FindIkConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindIkConstraint","rt":$n[5].IkConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindPathConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindPathConstraint","rt":$n[5].PathConstraintData,"p":[$n[0].String]},{"a":2,"n":"FindSkin","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0}],"sn":"FindSkin","rt":$n[5].Skin,"p":[$n[0].String]},{"a":2,"n":"FindSlot","t":8,"pi":[{"n":"slotName","pt":$n[0].String,"ps":0}],"sn":"FindSlot","rt":$n[5].SlotData,"p":[$n[0].String]},{"a":2,"n":"FindTransformConstraint","t":8,"pi":[{"n":"constraintName","pt":$n[0].String,"ps":0}],"sn":"FindTransformConstraint","rt":$n[5].TransformConstraintData,"p":[$n[0].String]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Animations","t":16,"rt":$n[5].ExposedList$1(Spine.Animation),"g":{"a":2,"n":"get_Animations","t":8,"rt":$n[5].ExposedList$1(Spine.Animation),"fg":"Animations"},"s":{"a":2,"n":"set_Animations","t":8,"p":[$n[5].ExposedList$1(Spine.Animation)],"rt":$n[0].Void,"fs":"Animations"},"fn":"Animations"},{"a":2,"n":"AudioPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AudioPath","t":8,"rt":$n[0].String,"fg":"AudioPath"},"s":{"a":2,"n":"set_AudioPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AudioPath"},"fn":"AudioPath"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"DefaultSkin","t":16,"rt":$n[5].Skin,"g":{"a":2,"n":"get_DefaultSkin","t":8,"rt":$n[5].Skin,"fg":"DefaultSkin"},"s":{"a":2,"n":"set_DefaultSkin","t":8,"p":[$n[5].Skin],"rt":$n[0].Void,"fs":"DefaultSkin"},"fn":"DefaultSkin"},{"a":2,"n":"Events","t":16,"rt":$n[5].ExposedList$1(Spine.EventData),"g":{"a":2,"n":"get_Events","t":8,"rt":$n[5].ExposedList$1(Spine.EventData),"fg":"Events"},"s":{"a":2,"n":"set_Events","t":8,"p":[$n[5].ExposedList$1(Spine.EventData)],"rt":$n[0].Void,"fs":"Events"},"fn":"Events"},{"a":2,"n":"Fps","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Fps","t":8,"rt":$n[0].Single,"fg":"Fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Fps","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Fps"},"fn":"Fps"},{"a":2,"n":"Hash","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Hash","t":8,"rt":$n[0].String,"fg":"Hash"},"s":{"a":2,"n":"set_Hash","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Hash"},"fn":"Hash"},{"a":2,"n":"Height","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Height","t":8,"rt":$n[0].Single,"fg":"Height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Height","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Height"},"fn":"Height"},{"a":2,"n":"IkConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.IkConstraintData),"g":{"a":2,"n":"get_IkConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.IkConstraintData),"fg":"IkConstraints"},"s":{"a":2,"n":"set_IkConstraints","t":8,"p":[$n[5].ExposedList$1(Spine.IkConstraintData)],"rt":$n[0].Void,"fs":"IkConstraints"},"fn":"IkConstraints"},{"a":2,"n":"ImagesPath","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_ImagesPath","t":8,"rt":$n[0].String,"fg":"ImagesPath"},"s":{"a":2,"n":"set_ImagesPath","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"ImagesPath"},"fn":"ImagesPath"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"s":{"a":2,"n":"set_Name","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Name"},"fn":"Name"},{"a":2,"n":"PathConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.PathConstraintData),"g":{"a":2,"n":"get_PathConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.PathConstraintData),"fg":"PathConstraints"},"s":{"a":2,"n":"set_PathConstraints","t":8,"p":[$n[5].ExposedList$1(Spine.PathConstraintData)],"rt":$n[0].Void,"fs":"PathConstraints"},"fn":"PathConstraints"},{"a":2,"n":"Skins","t":16,"rt":$n[5].ExposedList$1(Spine.Skin),"g":{"a":2,"n":"get_Skins","t":8,"rt":$n[5].ExposedList$1(Spine.Skin),"fg":"Skins"},"s":{"a":2,"n":"set_Skins","t":8,"p":[$n[5].ExposedList$1(Spine.Skin)],"rt":$n[0].Void,"fs":"Skins"},"fn":"Skins"},{"a":2,"n":"Slots","t":16,"rt":$n[5].ExposedList$1(Spine.SlotData),"g":{"a":2,"n":"get_Slots","t":8,"rt":$n[5].ExposedList$1(Spine.SlotData),"fg":"Slots"},"fn":"Slots"},{"a":2,"n":"TransformConstraints","t":16,"rt":$n[5].ExposedList$1(Spine.TransformConstraintData),"g":{"a":2,"n":"get_TransformConstraints","t":8,"rt":$n[5].ExposedList$1(Spine.TransformConstraintData),"fg":"TransformConstraints"},"s":{"a":2,"n":"set_TransformConstraints","t":8,"p":[$n[5].ExposedList$1(Spine.TransformConstraintData)],"rt":$n[0].Void,"fs":"TransformConstraints"},"fn":"TransformConstraints"},{"a":2,"n":"Version","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Version","t":8,"rt":$n[0].String,"fg":"Version"},"s":{"a":2,"n":"set_Version","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Version"},"fn":"Version"},{"a":2,"n":"Width","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Width","t":8,"rt":$n[0].Single,"fg":"Width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Width","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Width"},"fn":"Width"},{"a":2,"n":"X","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_X","t":8,"rt":$n[0].Single,"fg":"X","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_X","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"X"},"fn":"X"},{"a":2,"n":"Y","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Y","t":8,"rt":$n[0].Single,"fg":"Y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Y","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Y"},"fn":"Y"},{"a":4,"n":"animations","t":4,"rt":$n[5].ExposedList$1(Spine.Animation),"sn":"animations"},{"a":4,"n":"audioPath","t":4,"rt":$n[0].String,"sn":"audioPath"},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"defaultSkin","t":4,"rt":$n[5].Skin,"sn":"defaultSkin"},{"a":4,"n":"events","t":4,"rt":$n[5].ExposedList$1(Spine.EventData),"sn":"events"},{"a":4,"n":"fps","t":4,"rt":$n[0].Single,"sn":"fps","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hash","t":4,"rt":$n[0].String,"sn":"hash"},{"a":4,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"ikConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.IkConstraintData),"sn":"ikConstraints"},{"a":4,"n":"imagesPath","t":4,"rt":$n[0].String,"sn":"imagesPath"},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"pathConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.PathConstraintData),"sn":"pathConstraints"},{"a":4,"n":"skins","t":4,"rt":$n[5].ExposedList$1(Spine.Skin),"sn":"skins"},{"a":4,"n":"slots","t":4,"rt":$n[5].ExposedList$1(Spine.SlotData),"sn":"slots"},{"a":4,"n":"transformConstraints","t":4,"rt":$n[5].ExposedList$1(Spine.TransformConstraintData),"sn":"transformConstraints"},{"a":4,"n":"version","t":4,"rt":$n[0].String,"sn":"version"},{"a":4,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonData end.*/

    /*Spine.SkeletonJson start.*/
    $m("Spine.SkeletonJson", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"a":1,"n":"FindSlotIndex","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1}],"sn":"FindSlotIndex","rt":$n[0].Int32,"p":[$n[5].SkeletonData,$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetBoolean","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Boolean,"ps":2}],"sn":"GetBoolean","rt":$n[0].Boolean,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetFloat","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2}],"sn":"GetFloat","rt":$n[0].Single,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetFloatArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"GetFloatArray","rt":$n[0].Array.type(System.Single),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Single]},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetInt","rt":$n[0].Int32,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetInt","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].Int32,"ps":2}],"sn":"GetInt$1","rt":$n[0].Int32,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetIntArray","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetIntArray","rt":$n[0].Array.type(System.Int32),"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String]},{"a":1,"n":"GetString","is":true,"t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"defaultValue","pt":$n[0].String,"ps":2}],"sn":"GetString","rt":$n[0].String,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[0].String]},{"a":1,"n":"ReadAnimation","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":2}],"sn":"ReadAnimation","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[0].String,$n[5].SkeletonData]},{"a":1,"n":"ReadAttachment","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"skin","pt":$n[5].Skin,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"name","pt":$n[0].String,"ps":3},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":4}],"sn":"ReadAttachment","rt":$n[5].Attachment,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[5].Skin,$n[0].Int32,$n[0].String,$n[5].SkeletonData]},{"a":1,"n":"ReadCurve","is":true,"t":8,"pi":[{"n":"curve","pt":$n[0].Object,"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline,"ps":1},{"n":"bezier","pt":$n[0].Int32,"ps":2},{"n":"frame","pt":$n[0].Int32,"ps":3},{"n":"value","pt":$n[0].Int32,"ps":4},{"n":"time1","pt":$n[0].Single,"ps":5},{"n":"time2","pt":$n[0].Single,"ps":6},{"n":"value1","pt":$n[0].Single,"ps":7},{"n":"value2","pt":$n[0].Single,"ps":8},{"n":"scale","pt":$n[0].Single,"ps":9}],"sn":"ReadCurve","rt":$n[0].Int32,"p":[$n[0].Object,$n[5].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"ReadSequence","is":true,"t":8,"pi":[{"n":"sequenceJson","pt":$n[0].Object,"ps":0}],"sn":"ReadSequence","rt":$n[5].Sequence,"p":[$n[0].Object]},{"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"reader","pt":$n[6].TextReader,"ps":0}],"sn":"ReadSkeletonData$1","rt":$n[5].SkeletonData,"p":[$n[6].TextReader]},{"ov":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].String]},{"a":1,"n":"ReadTimeline","is":true,"t":8,"pi":[{"n":"keyMapEnumerator","ref":true,"pt":$n[2].List$1.Enumerator(System.Object),"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline1,"ps":1},{"n":"defaultValue","pt":$n[0].Single,"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3}],"sn":"ReadTimeline","rt":$n[5].Timeline,"p":[$n[2].List$1.Enumerator(System.Object),$n[5].CurveTimeline1,$n[0].Single,$n[0].Single]},{"a":1,"n":"ReadTimeline","is":true,"t":8,"pi":[{"n":"keyMapEnumerator","ref":true,"pt":$n[2].List$1.Enumerator(System.Object),"ps":0},{"n":"timeline","pt":$n[5].CurveTimeline2,"ps":1},{"n":"name1","pt":$n[0].String,"ps":2},{"n":"name2","pt":$n[0].String,"ps":3},{"n":"defaultValue","pt":$n[0].Single,"ps":4},{"n":"scale","pt":$n[0].Single,"ps":5}],"sn":"ReadTimeline$1","rt":$n[5].Timeline,"p":[$n[2].List$1.Enumerator(System.Object),$n[5].CurveTimeline2,$n[0].String,$n[0].String,$n[0].Single,$n[0].Single]},{"a":1,"n":"ReadVertices","t":8,"pi":[{"n":"map","pt":$n[2].Dictionary$2(System.String,System.Object),"ps":0},{"n":"attachment","pt":$n[5].VertexAttachment,"ps":1},{"n":"verticesLength","pt":$n[0].Int32,"ps":2}],"sn":"ReadVertices","rt":$n[0].Void,"p":[$n[2].Dictionary$2(System.String,System.Object),$n[5].VertexAttachment,$n[0].Int32]},{"a":1,"n":"SetBezier","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].CurveTimeline,"ps":0},{"n":"frame","pt":$n[0].Int32,"ps":1},{"n":"value","pt":$n[0].Int32,"ps":2},{"n":"bezier","pt":$n[0].Int32,"ps":3},{"n":"time1","pt":$n[0].Single,"ps":4},{"n":"value1","pt":$n[0].Single,"ps":5},{"n":"cx1","pt":$n[0].Single,"ps":6},{"n":"cy1","pt":$n[0].Single,"ps":7},{"n":"cx2","pt":$n[0].Single,"ps":8},{"n":"cy2","pt":$n[0].Single,"ps":9},{"n":"time2","pt":$n[0].Single,"ps":10},{"n":"value2","pt":$n[0].Single,"ps":11}],"sn":"SetBezier","rt":$n[0].Void,"p":[$n[5].CurveTimeline,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":1,"n":"ToColor","is":true,"t":8,"pi":[{"n":"hexString","pt":$n[0].String,"ps":0},{"n":"colorIndex","pt":$n[0].Int32,"ps":1},{"n":"expectedLength","dv":8,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"ToColor","rt":$n[0].Single,"p":[$n[0].String,$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonJson end.*/

    /*Spine.SkeletonLoader start.*/
    $m("Spine.SkeletonLoader", function () { return {"nested":[$n[5].SkeletonLoader.LinkedMesh],"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[System.Array.type(Spine.Atlas)],"pi":[{"n":"atlasArray","ip":true,"pt":System.Array.type(Spine.Atlas),"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].AttachmentLoader],"pi":[{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":0}],"sn":"$ctor1"},{"ab":true,"a":2,"n":"ReadSkeletonData","t":8,"pi":[{"n":"path","pt":$n[0].String,"ps":0}],"sn":"ReadSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].String]},{"a":2,"n":"Scale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Scale","t":8,"rt":$n[0].Single,"fg":"Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Scale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Scale"},"fn":"Scale"},{"a":3,"n":"attachmentLoader","t":4,"rt":$n[5].AttachmentLoader,"sn":"attachmentLoader","ro":true},{"a":3,"n":"linkedMeshes","t":4,"rt":$n[2].List$1(Spine.SkeletonLoader.LinkedMesh),"sn":"linkedMeshes","ro":true},{"a":3,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SkeletonLoader end.*/

    /*Spine.SkeletonLoader+LinkedMesh start.*/
    $m("Spine.SkeletonLoader.LinkedMesh", function () { return {"td":$n[5].SkeletonLoader,"att":1048580,"a":3,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].MeshAttachment,$n[0].String,$n[0].Int32,$n[0].String,$n[0].Boolean],"pi":[{"n":"mesh","pt":$n[5].MeshAttachment,"ps":0},{"n":"skin","pt":$n[0].String,"ps":1},{"n":"slotIndex","pt":$n[0].Int32,"ps":2},{"n":"parent","pt":$n[0].String,"ps":3},{"n":"inheritTimelines","pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":4,"n":"inheritTimelines","t":4,"rt":$n[0].Boolean,"sn":"inheritTimelines","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mesh","t":4,"rt":$n[5].MeshAttachment,"sn":"mesh"},{"a":4,"n":"parent","t":4,"rt":$n[0].String,"sn":"parent"},{"a":4,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.SkeletonLoader+LinkedMesh end.*/

    /*Spine.Skin start.*/
    $m("Spine.Skin", function () { return {"nested":[$n[5].Skin.SkinEntry,$n[5].Skin.SkinKey,$n[5].Skin.SkinKeyComparer],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"AddSkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0}],"sn":"AddSkin","rt":$n[0].Void,"p":[$n[5].Skin]},{"a":4,"n":"AttachAll","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"oldSkin","pt":$n[5].Skin,"ps":1}],"sn":"AttachAll","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[5].Skin]},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CopySkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0}],"sn":"CopySkin","rt":$n[0].Void,"p":[$n[5].Skin]},{"a":2,"n":"GetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"GetAttachment","rt":$n[5].Attachment,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"GetAttachments","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"attachments","pt":$n[2].List$1(Spine.Skin.SkinEntry),"ps":1}],"sn":"GetAttachments","rt":$n[0].Void,"p":[$n[0].Int32,$n[2].List$1(Spine.Skin.SkinEntry)]},{"a":2,"n":"RemoveAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"RemoveAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"SetAttachment","t":8,"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[5].Attachment,"ps":2}],"sn":"SetAttachment","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].String,$n[5].Attachment]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Attachments","t":16,"rt":$n[2].ICollection$1(Spine.Skin.SkinEntry),"g":{"a":2,"n":"get_Attachments","t":8,"rt":$n[2].ICollection$1(Spine.Skin.SkinEntry),"fg":"Attachments"},"fn":"Attachments"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Constraints","t":16,"rt":$n[5].ExposedList$1(Spine.ConstraintData),"g":{"a":2,"n":"get_Constraints","t":8,"rt":$n[5].ExposedList$1(Spine.ConstraintData),"fg":"Constraints"},"fn":"Constraints"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":1,"n":"attachments","t":4,"rt":$n[2].Dictionary$2(Spine.Skin.SkinKey,Spine.Skin.SkinEntry),"sn":"attachments"},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.BoneData),"sn":"bones","ro":true},{"a":4,"n":"constraints","t":4,"rt":$n[5].ExposedList$1(Spine.ConstraintData),"sn":"constraints","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*Spine.Skin end.*/

    /*Spine.Skin+SkinEntry start.*/
    $m("Spine.Skin.SkinEntry", function () { return {"td":$n[5].Skin,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[5].Attachment],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"attachment","pt":$n[5].Attachment,"ps":2}],"sn":"$ctor1"},{"a":2,"n":"Attachment","t":16,"rt":$n[5].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[5].Attachment,"fg":"Attachment"},"fn":"Attachment"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"SlotIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotIndex","t":8,"rt":$n[0].Int32,"fg":"SlotIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotIndex"},{"a":4,"n":"attachment","t":4,"rt":$n[5].Attachment,"sn":"attachment","ro":true},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinEntry end.*/

    /*Spine.Skin+SkinKey start.*/
    $m("Spine.Skin.SkinKey", function () { return {"td":$n[5].Skin,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String],"pi":[{"n":"slotIndex","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"$ctor1"},{"a":4,"n":"hashCode","t":4,"rt":$n[0].Int32,"sn":"hashCode","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name","ro":true},{"a":4,"n":"slotIndex","t":4,"rt":$n[0].Int32,"sn":"slotIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Skin+SkinKey end.*/

    /*Spine.Skin+SkinKeyComparer start.*/
    $m("Spine.Skin.SkinKeyComparer", function () { return {"td":$n[5].Skin,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[5].Skin.SkinKeyComparer,"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Skin+SkinKeyComparer end.*/

    /*Spine.Slot start.*/
    $m("Spine.Slot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].Slot,$n[5].Bone],"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"bone","pt":$n[5].Bone,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].SlotData,$n[5].Bone],"pi":[{"n":"data","pt":$n[5].SlotData,"ps":0},{"n":"bone","pt":$n[5].Bone,"ps":1}],"sn":"$ctor1"},{"a":2,"n":"ClampColor","t":8,"sn":"ClampColor","rt":$n[0].Void},{"a":2,"n":"ClampSecondColor","t":8,"sn":"ClampSecondColor","rt":$n[0].Void},{"a":2,"n":"SetToSetupPose","t":8,"sn":"SetToSetupPose","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"Attachment","t":16,"rt":$n[5].Attachment,"g":{"a":2,"n":"get_Attachment","t":8,"rt":$n[5].Attachment,"fg":"Attachment"},"s":{"a":2,"n":"set_Attachment","t":8,"p":[$n[5].Attachment],"rt":$n[0].Void,"fs":"Attachment"},"fn":"Attachment"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"Bone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_Bone","t":8,"rt":$n[5].Bone,"fg":"Bone"},"fn":"Bone"},{"a":2,"n":"Data","t":16,"rt":$n[5].SlotData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].SlotData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"Deform","t":16,"rt":$n[5].ExposedList$1(System.Single),"g":{"a":2,"n":"get_Deform","t":8,"rt":$n[5].ExposedList$1(System.Single),"fg":"Deform"},"s":{"a":2,"n":"set_Deform","t":8,"p":[$n[5].ExposedList$1(System.Single)],"rt":$n[0].Void,"fs":"Deform"},"fn":"Deform"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":2,"n":"SequenceIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SequenceIndex","t":8,"rt":$n[0].Int32,"fg":"SequenceIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_SequenceIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"SequenceIndex"},"fn":"SequenceIndex"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachment","t":4,"rt":$n[5].Attachment,"sn":"attachment"},{"a":4,"n":"attachmentState","t":4,"rt":$n[0].Int32,"sn":"attachmentState","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"a":4,"n":"data","t":4,"rt":$n[5].SlotData,"sn":"data"},{"a":4,"n":"deform","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"deform"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"sequenceIndex","t":4,"rt":$n[0].Int32,"sn":"sequenceIndex","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Slot end.*/

    /*Spine.SlotData start.*/
    $m("Spine.SlotData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].String,$n[5].BoneData],"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"boneData","pt":$n[5].BoneData,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"A","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_A","t":8,"rt":$n[0].Single,"fg":"A","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_A","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"A"},"fn":"A"},{"a":2,"n":"AttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AttachmentName","t":8,"rt":$n[0].String,"fg":"AttachmentName"},"s":{"a":2,"n":"set_AttachmentName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AttachmentName"},"fn":"AttachmentName"},{"a":2,"n":"B","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B","t":8,"rt":$n[0].Single,"fg":"B","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B"},"fn":"B"},{"a":2,"n":"B2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_B2","t":8,"rt":$n[0].Single,"fg":"B2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_B2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"B2"},"fn":"B2"},{"a":2,"n":"BlendMode","t":16,"rt":$n[5].BlendMode,"g":{"a":2,"n":"get_BlendMode","t":8,"rt":$n[5].BlendMode,"fg":"BlendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},"s":{"a":2,"n":"set_BlendMode","t":8,"p":[$n[5].BlendMode],"rt":$n[0].Void,"fs":"BlendMode"},"fn":"BlendMode"},{"a":2,"n":"BoneData","t":16,"rt":$n[5].BoneData,"g":{"a":2,"n":"get_BoneData","t":8,"rt":$n[5].BoneData,"fg":"BoneData"},"fn":"BoneData"},{"a":2,"n":"G","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G","t":8,"rt":$n[0].Single,"fg":"G","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G"},"fn":"G"},{"a":2,"n":"G2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_G2","t":8,"rt":$n[0].Single,"fg":"G2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_G2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"G2"},"fn":"G2"},{"a":2,"n":"HasSecondColor","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasSecondColor","t":8,"rt":$n[0].Boolean,"fg":"HasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HasSecondColor","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HasSecondColor"},"fn":"HasSecondColor"},{"a":2,"n":"Index","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Index","t":8,"rt":$n[0].Int32,"fg":"Index","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Index"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"R","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R","t":8,"rt":$n[0].Single,"fg":"R","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R"},"fn":"R"},{"a":2,"n":"R2","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_R2","t":8,"rt":$n[0].Single,"fg":"R2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_R2","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"R2"},"fn":"R2"},{"a":4,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentName","t":4,"rt":$n[0].String,"sn":"attachmentName"},{"a":4,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"b2","t":4,"rt":$n[0].Single,"sn":"b2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"blendMode","t":4,"rt":$n[5].BlendMode,"sn":"blendMode","box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":4,"n":"boneData","t":4,"rt":$n[5].BoneData,"sn":"boneData"},{"a":4,"n":"g","t":4,"rt":$n[0].Single,"sn":"g","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"g2","t":4,"rt":$n[0].Single,"sn":"g2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"hasSecondColor","t":4,"rt":$n[0].Boolean,"sn":"hasSecondColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":4,"n":"r","t":4,"rt":$n[0].Single,"sn":"r","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"r2","t":4,"rt":$n[0].Single,"sn":"r2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.SlotData end.*/

    /*Spine.SpacingMode start.*/
    $m("Spine.SpacingMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fixed","is":true,"t":4,"rt":$n[5].SpacingMode,"sn":"Fixed","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Length","is":true,"t":4,"rt":$n[5].SpacingMode,"sn":"Length","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Percent","is":true,"t":4,"rt":$n[5].SpacingMode,"sn":"Percent","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}},{"a":2,"n":"Proportional","is":true,"t":4,"rt":$n[5].SpacingMode,"sn":"Proportional","box":function ($v) { return Bridge.box($v, Spine.SpacingMode, System.Enum.toStringFn(Spine.SpacingMode));}}]}; }, $n);
    /*Spine.SpacingMode end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":$n[5].TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[$n[5].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":$n[5].TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[$n[5].TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":$n[5].VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[$n[5].VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.TextureFilter start.*/
    $m("Spine.TextureFilter", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Linear","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"Linear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMap","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"MipMap","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearLinear","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"MipMapLinearLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapLinearNearest","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"MipMapLinearNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestLinear","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"MipMapNearestLinear","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"MipMapNearestNearest","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"MipMapNearestNearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}},{"a":2,"n":"Nearest","is":true,"t":4,"rt":$n[5].TextureFilter,"sn":"Nearest","box":function ($v) { return Bridge.box($v, Spine.TextureFilter, System.Enum.toStringFn(Spine.TextureFilter));}}]}; }, $n);
    /*Spine.TextureFilter end.*/

    /*Spine.TextureLoader start.*/
    $m("Spine.TextureLoader", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[5].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Spine$TextureLoader$Load","rt":$n[0].Void,"p":[$n[5].AtlasPage,$n[0].String]},{"ab":true,"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Spine$TextureLoader$Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.TextureLoader end.*/

    /*Spine.TextureRegion start.*/
    $m("Spine.TextureRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"OriginalHeight","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_OriginalHeight","t":8,"rt":$n[0].Int32,"fg":"OriginalHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalHeight"},{"v":true,"a":2,"n":"OriginalWidth","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_OriginalWidth","t":8,"rt":$n[0].Int32,"fg":"OriginalWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"OriginalWidth"},{"a":2,"n":"height","t":4,"rt":$n[0].Int32,"sn":"height","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"u","t":4,"rt":$n[0].Single,"sn":"u","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"u2","t":4,"rt":$n[0].Single,"sn":"u2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v","t":4,"rt":$n[0].Single,"sn":"v","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"v2","t":4,"rt":$n[0].Single,"sn":"v2","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"width","t":4,"rt":$n[0].Int32,"sn":"width","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TextureRegion end.*/

    /*Spine.TextureWrap start.*/
    $m("Spine.TextureWrap", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClampToEdge","is":true,"t":4,"rt":$n[5].TextureWrap,"sn":"ClampToEdge","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"MirroredRepeat","is":true,"t":4,"rt":$n[5].TextureWrap,"sn":"MirroredRepeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}},{"a":2,"n":"Repeat","is":true,"t":4,"rt":$n[5].TextureWrap,"sn":"Repeat","box":function ($v) { return Bridge.box($v, Spine.TextureWrap, System.Enum.toStringFn(Spine.TextureWrap));}}]}; }, $n);
    /*Spine.TextureWrap end.*/

    /*Spine.Timeline start.*/
    $m("Spine.Timeline", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Array.type(System.String)],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"propertyIds","ip":true,"pt":$n[0].Array.type(System.String),"ps":1}],"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"events","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":4,"n":"Search","is":true,"t":8,"pi":[{"n":"frames","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"Search","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Search","is":true,"t":8,"pi":[{"n":"frames","pt":$n[0].Array.type(System.Single),"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"step","pt":$n[0].Int32,"ps":2}],"sn":"Search$1","rt":$n[0].Int32,"p":[$n[0].Array.type(System.Single),$n[0].Single,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"Duration"},{"a":2,"n":"FrameCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FrameCount","t":8,"rt":$n[0].Int32,"fg":"FrameCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameCount"},{"v":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"v":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"Frames","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Frames","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Frames"},"fn":"Frames"},{"a":2,"n":"PropertyIds","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_PropertyIds","t":8,"rt":$n[0].Array.type(System.String),"fg":"PropertyIds"},"fn":"PropertyIds"},{"a":4,"n":"frames","t":4,"rt":$n[0].Array.type(System.Single),"sn":"frames","ro":true},{"a":1,"n":"propertyIds","t":4,"rt":$n[0].Array.type(System.String),"sn":"propertyIds","ro":true}]}; }, $n);
    /*Spine.Timeline end.*/

    /*Spine.TrackEntry start.*/
    $m("Spine.TrackEntry", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AllowImmediateQueue","t":8,"sn":"AllowImmediateQueue","rt":$n[0].Void},{"a":4,"n":"OnComplete","t":8,"sn":"OnComplete","rt":$n[0].Void},{"a":4,"n":"OnDispose","t":8,"sn":"OnDispose","rt":$n[0].Void},{"a":4,"n":"OnEnd","t":8,"sn":"OnEnd","rt":$n[0].Void},{"a":4,"n":"OnEvent","t":8,"pi":[{"n":"e","pt":$n[5].Event,"ps":0}],"sn":"OnEvent","rt":$n[0].Void,"p":[$n[5].Event]},{"a":4,"n":"OnInterrupt","t":8,"sn":"OnInterrupt","rt":$n[0].Void},{"a":4,"n":"OnStart","t":8,"sn":"OnStart","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"ResetRotationDirections","t":8,"sn":"ResetRotationDirections","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Alpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Alpha","t":8,"rt":$n[0].Single,"fg":"Alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Alpha","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Alpha"},"fn":"Alpha"},{"a":2,"n":"Animation","t":16,"rt":$n[5].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[5].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"AnimationEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationEnd","t":8,"rt":$n[0].Single,"fg":"AnimationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationEnd"},"fn":"AnimationEnd"},{"a":2,"n":"AnimationLast","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationLast","t":8,"rt":$n[0].Single,"fg":"AnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationLast","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationLast"},"fn":"AnimationLast"},{"a":2,"n":"AnimationStart","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationStart","t":8,"rt":$n[0].Single,"fg":"AnimationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AnimationStart","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AnimationStart"},"fn":"AnimationStart"},{"a":2,"n":"AnimationTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AnimationTime","t":8,"rt":$n[0].Single,"fg":"AnimationTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AnimationTime"},{"a":2,"n":"AttachmentThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_AttachmentThreshold","t":8,"rt":$n[0].Single,"fg":"AttachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_AttachmentThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"AttachmentThreshold"},"fn":"AttachmentThreshold"},{"a":2,"n":"Delay","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Delay","t":8,"rt":$n[0].Single,"fg":"Delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Delay","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Delay"},"fn":"Delay"},{"a":2,"n":"DrawOrderThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_DrawOrderThreshold","t":8,"rt":$n[0].Single,"fg":"DrawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_DrawOrderThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"DrawOrderThreshold"},"fn":"DrawOrderThreshold"},{"a":2,"n":"EventThreshold","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_EventThreshold","t":8,"rt":$n[0].Single,"fg":"EventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_EventThreshold","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"EventThreshold"},"fn":"EventThreshold"},{"a":2,"n":"HoldPrevious","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HoldPrevious","t":8,"rt":$n[0].Boolean,"fg":"HoldPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_HoldPrevious","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"HoldPrevious"},"fn":"HoldPrevious"},{"a":2,"n":"InterruptAlpha","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_InterruptAlpha","t":8,"rt":$n[0].Single,"fg":"InterruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"InterruptAlpha"},{"a":2,"n":"IsComplete","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsComplete","t":8,"rt":$n[0].Boolean,"fg":"IsComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsComplete"},{"a":2,"n":"IsEmptyAnimation","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsEmptyAnimation","t":8,"rt":$n[0].Boolean,"fg":"IsEmptyAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsEmptyAnimation"},{"a":2,"n":"Loop","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Loop","t":8,"rt":$n[0].Boolean,"fg":"Loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Loop","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Loop"},"fn":"Loop"},{"a":2,"n":"MixBlend","t":16,"rt":$n[5].MixBlend,"g":{"a":2,"n":"get_MixBlend","t":8,"rt":$n[5].MixBlend,"fg":"MixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},"s":{"a":2,"n":"set_MixBlend","t":8,"p":[$n[5].MixBlend],"rt":$n[0].Void,"fs":"MixBlend"},"fn":"MixBlend"},{"a":2,"n":"MixDuration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixDuration","t":8,"rt":$n[0].Single,"fg":"MixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixDuration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixDuration"},"fn":"MixDuration"},{"a":2,"n":"MixTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixTime","t":8,"rt":$n[0].Single,"fg":"MixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixTime"},"fn":"MixTime"},{"a":2,"n":"MixingFrom","t":16,"rt":$n[5].TrackEntry,"g":{"a":2,"n":"get_MixingFrom","t":8,"rt":$n[5].TrackEntry,"fg":"MixingFrom"},"fn":"MixingFrom"},{"a":2,"n":"MixingTo","t":16,"rt":$n[5].TrackEntry,"g":{"a":2,"n":"get_MixingTo","t":8,"rt":$n[5].TrackEntry,"fg":"MixingTo"},"fn":"MixingTo"},{"a":2,"n":"Next","t":16,"rt":$n[5].TrackEntry,"g":{"a":2,"n":"get_Next","t":8,"rt":$n[5].TrackEntry,"fg":"Next"},"fn":"Next"},{"a":2,"n":"Previous","t":16,"rt":$n[5].TrackEntry,"g":{"a":2,"n":"get_Previous","t":8,"rt":$n[5].TrackEntry,"fg":"Previous"},"fn":"Previous"},{"a":2,"n":"Reverse","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Reverse","t":8,"rt":$n[0].Boolean,"fg":"Reverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Reverse","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Reverse"},"fn":"Reverse"},{"a":2,"n":"ShortestRotation","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_ShortestRotation","t":8,"rt":$n[0].Boolean,"fg":"ShortestRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_ShortestRotation","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"ShortestRotation"},"fn":"ShortestRotation"},{"a":2,"n":"TimeScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeScale","t":8,"rt":$n[0].Single,"fg":"TimeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TimeScale","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TimeScale"},"fn":"TimeScale"},{"a":2,"n":"TrackComplete","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackComplete","t":8,"rt":$n[0].Single,"fg":"TrackComplete","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TrackComplete"},{"a":2,"n":"TrackEnd","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackEnd","t":8,"rt":$n[0].Single,"fg":"TrackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackEnd","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackEnd"},"fn":"TrackEnd"},{"a":2,"n":"TrackIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TrackIndex","t":8,"rt":$n[0].Int32,"fg":"TrackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TrackIndex"},{"a":2,"n":"TrackTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TrackTime","t":8,"rt":$n[0].Single,"fg":"TrackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_TrackTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"TrackTime"},"fn":"TrackTime"},{"a":4,"n":"alpha","t":4,"rt":$n[0].Single,"sn":"alpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animation","t":4,"rt":$n[5].Animation,"sn":"animation"},{"a":4,"n":"animationEnd","t":4,"rt":$n[0].Single,"sn":"animationEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationLast","t":4,"rt":$n[0].Single,"sn":"animationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"animationStart","t":4,"rt":$n[0].Single,"sn":"animationStart","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"attachmentThreshold","t":4,"rt":$n[0].Single,"sn":"attachmentThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"delay","t":4,"rt":$n[0].Single,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"drawOrderThreshold","t":4,"rt":$n[0].Single,"sn":"drawOrderThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"eventThreshold","t":4,"rt":$n[0].Single,"sn":"eventThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"holdPrevious","t":4,"rt":$n[0].Boolean,"sn":"holdPrevious","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"interruptAlpha","t":4,"rt":$n[0].Single,"sn":"interruptAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixBlend","t":4,"rt":$n[5].MixBlend,"sn":"mixBlend","box":function ($v) { return Bridge.box($v, Spine.MixBlend, System.Enum.toStringFn(Spine.MixBlend));}},{"a":4,"n":"mixDuration","t":4,"rt":$n[0].Single,"sn":"mixDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixTime","t":4,"rt":$n[0].Single,"sn":"mixTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixingFrom","t":4,"rt":$n[5].TrackEntry,"sn":"mixingFrom"},{"a":4,"n":"mixingTo","t":4,"rt":$n[5].TrackEntry,"sn":"mixingTo"},{"a":4,"n":"next","t":4,"rt":$n[5].TrackEntry,"sn":"next"},{"a":4,"n":"nextAnimationLast","t":4,"rt":$n[0].Single,"sn":"nextAnimationLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"nextTrackLast","t":4,"rt":$n[0].Single,"sn":"nextTrackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"previous","t":4,"rt":$n[5].TrackEntry,"sn":"previous"},{"a":4,"n":"reverse","t":4,"rt":$n[0].Boolean,"sn":"reverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"shortestRotation","t":4,"rt":$n[0].Boolean,"sn":"shortestRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"timelineHoldMix","t":4,"rt":$n[5].ExposedList$1(Spine.TrackEntry),"sn":"timelineHoldMix","ro":true},{"a":4,"n":"timelineMode","t":4,"rt":$n[5].ExposedList$1(System.Int32),"sn":"timelineMode","ro":true},{"a":4,"n":"timelinesRotation","t":4,"rt":$n[5].ExposedList$1(System.Single),"sn":"timelinesRotation","ro":true},{"a":4,"n":"totalAlpha","t":4,"rt":$n[0].Single,"sn":"totalAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackEnd","t":4,"rt":$n[0].Single,"sn":"trackEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackIndex","t":4,"rt":$n[0].Int32,"sn":"trackIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"trackLast","t":4,"rt":$n[0].Single,"sn":"trackLast","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"trackTime","t":4,"rt":$n[0].Single,"sn":"trackTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Complete","t":2,"ad":{"a":2,"n":"add_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Complete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Dispose","t":2,"ad":{"a":2,"n":"add_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addDispose","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Dispose","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeDispose","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"End","t":2,"ad":{"a":2,"n":"add_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEnd","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_End","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEnd","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Event","t":2,"ad":{"a":2,"n":"add_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Event","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeEvent","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Interrupt","t":2,"ad":{"a":2,"n":"add_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addInterrupt","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Interrupt","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeInterrupt","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"Start","t":2,"ad":{"a":2,"n":"add_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addStart","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_Start","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeStart","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.TrackEntry end.*/

    /*Spine.TransformConstraint start.*/
    $m("Spine.TransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TransformConstraint,$n[5].Skeleton],"pi":[{"n":"constraint","pt":$n[5].TransformConstraint,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].TransformConstraintData,$n[5].Skeleton],"pi":[{"n":"data","pt":$n[5].TransformConstraintData,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1}],"sn":"$ctor1"},{"a":1,"n":"ApplyAbsoluteLocal","t":8,"sn":"ApplyAbsoluteLocal","rt":$n[0].Void},{"a":1,"n":"ApplyAbsoluteWorld","t":8,"sn":"ApplyAbsoluteWorld","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeLocal","t":8,"sn":"ApplyRelativeLocal","rt":$n[0].Void},{"a":1,"n":"ApplyRelativeWorld","t":8,"sn":"ApplyRelativeWorld","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Active","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Active","t":8,"rt":$n[0].Boolean,"fg":"Active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"Active"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.Bone),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.Bone),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Data","t":16,"rt":$n[5].TransformConstraintData,"g":{"a":2,"n":"get_Data","t":8,"rt":$n[5].TransformConstraintData,"fg":"Data"},"fn":"Data"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleX","t":8,"rt":$n[0].Single,"fg":"MixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleX"},"fn":"MixScaleX"},{"a":2,"n":"MixScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleY","t":8,"rt":$n[0].Single,"fg":"MixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleY"},"fn":"MixScaleY"},{"a":2,"n":"MixShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixShearY","t":8,"rt":$n[0].Single,"fg":"MixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixShearY"},"fn":"MixShearY"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"Target","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].Bone,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].Bone],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"active","t":4,"rt":$n[0].Boolean,"sn":"active","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.Bone),"sn":"bones","ro":true},{"a":4,"n":"data","t":4,"rt":$n[5].TransformConstraintData,"sn":"data","ro":true},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleX","t":4,"rt":$n[0].Single,"sn":"mixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleY","t":4,"rt":$n[0].Single,"sn":"mixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixShearY","t":4,"rt":$n[0].Single,"sn":"mixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"target","t":4,"rt":$n[5].Bone,"sn":"target"}]}; }, $n);
    /*Spine.TransformConstraint end.*/

    /*Spine.TransformConstraintData start.*/
    $m("Spine.TransformConstraintData", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"Bones","t":16,"rt":$n[5].ExposedList$1(Spine.BoneData),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[5].ExposedList$1(Spine.BoneData),"fg":"Bones"},"fn":"Bones"},{"a":2,"n":"Local","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Local","t":8,"rt":$n[0].Boolean,"fg":"Local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Local","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Local"},"fn":"Local"},{"a":2,"n":"MixRotate","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixRotate","t":8,"rt":$n[0].Single,"fg":"MixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixRotate","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixRotate"},"fn":"MixRotate"},{"a":2,"n":"MixScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleX","t":8,"rt":$n[0].Single,"fg":"MixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleX"},"fn":"MixScaleX"},{"a":2,"n":"MixScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixScaleY","t":8,"rt":$n[0].Single,"fg":"MixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixScaleY"},"fn":"MixScaleY"},{"a":2,"n":"MixShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixShearY","t":8,"rt":$n[0].Single,"fg":"MixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixShearY"},"fn":"MixShearY"},{"a":2,"n":"MixX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixX","t":8,"rt":$n[0].Single,"fg":"MixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixX"},"fn":"MixX"},{"a":2,"n":"MixY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MixY","t":8,"rt":$n[0].Single,"fg":"MixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MixY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MixY"},"fn":"MixY"},{"a":2,"n":"OffsetRotation","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetRotation","t":8,"rt":$n[0].Single,"fg":"OffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetRotation","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetRotation"},"fn":"OffsetRotation"},{"a":2,"n":"OffsetScaleX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleX","t":8,"rt":$n[0].Single,"fg":"OffsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleX"},"fn":"OffsetScaleX"},{"a":2,"n":"OffsetScaleY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetScaleY","t":8,"rt":$n[0].Single,"fg":"OffsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetScaleY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetScaleY"},"fn":"OffsetScaleY"},{"a":2,"n":"OffsetShearY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetShearY","t":8,"rt":$n[0].Single,"fg":"OffsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetShearY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetShearY"},"fn":"OffsetShearY"},{"a":2,"n":"OffsetX","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetX","t":8,"rt":$n[0].Single,"fg":"OffsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetX","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetX"},"fn":"OffsetX"},{"a":2,"n":"OffsetY","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_OffsetY","t":8,"rt":$n[0].Single,"fg":"OffsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_OffsetY","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"OffsetY"},"fn":"OffsetY"},{"a":2,"n":"Relative","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_Relative","t":8,"rt":$n[0].Boolean,"fg":"Relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_Relative","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Relative"},"fn":"Relative"},{"a":2,"n":"Target","t":16,"rt":$n[5].BoneData,"g":{"a":2,"n":"get_Target","t":8,"rt":$n[5].BoneData,"fg":"Target"},"s":{"a":2,"n":"set_Target","t":8,"p":[$n[5].BoneData],"rt":$n[0].Void,"fs":"Target"},"fn":"Target"},{"a":4,"n":"bones","t":4,"rt":$n[5].ExposedList$1(Spine.BoneData),"sn":"bones"},{"a":4,"n":"local","t":4,"rt":$n[0].Boolean,"sn":"local","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"mixRotate","t":4,"rt":$n[0].Single,"sn":"mixRotate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleX","t":4,"rt":$n[0].Single,"sn":"mixScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixScaleY","t":4,"rt":$n[0].Single,"sn":"mixScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixShearY","t":4,"rt":$n[0].Single,"sn":"mixShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixX","t":4,"rt":$n[0].Single,"sn":"mixX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"mixY","t":4,"rt":$n[0].Single,"sn":"mixY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetRotation","t":4,"rt":$n[0].Single,"sn":"offsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleX","t":4,"rt":$n[0].Single,"sn":"offsetScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetScaleY","t":4,"rt":$n[0].Single,"sn":"offsetScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetShearY","t":4,"rt":$n[0].Single,"sn":"offsetShearY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetX","t":4,"rt":$n[0].Single,"sn":"offsetX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"offsetY","t":4,"rt":$n[0].Single,"sn":"offsetY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"relative","t":4,"rt":$n[0].Boolean,"sn":"relative","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":4,"n":"target","t":4,"rt":$n[5].BoneData,"sn":"target"}]}; }, $n);
    /*Spine.TransformConstraintData end.*/

    /*Spine.TransformConstraintTimeline start.*/
    $m("Spine.TransformConstraintTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"rotate","out":true,"pt":$n[0].Single,"ps":0},{"n":"x","out":true,"pt":$n[0].Single,"ps":1},{"n":"y","out":true,"pt":$n[0].Single,"ps":2},{"n":"scaleX","out":true,"pt":$n[0].Single,"ps":3},{"n":"scaleY","out":true,"pt":$n[0].Single,"ps":4},{"n":"shearY","out":true,"pt":$n[0].Single,"ps":5},{"n":"time","pt":$n[0].Single,"ps":6}],"sn":"GetCurveValue","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetFrame","t":8,"pi":[{"n":"frame","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"mixRotate","pt":$n[0].Single,"ps":2},{"n":"mixX","pt":$n[0].Single,"ps":3},{"n":"mixY","pt":$n[0].Single,"ps":4},{"n":"mixScaleX","pt":$n[0].Single,"ps":5},{"n":"mixScaleY","pt":$n[0].Single,"ps":6},{"n":"mixShearY","pt":$n[0].Single,"ps":7}],"sn":"SetFrame","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"ov":true,"a":2,"n":"FrameEntries","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_FrameEntries","t":8,"rt":$n[0].Int32,"fg":"FrameEntries","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FrameEntries"},{"a":2,"n":"TransformConstraintIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TransformConstraintIndex","t":8,"rt":$n[0].Int32,"fg":"TransformConstraintIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TransformConstraintIndex"},{"a":2,"n":"ENTRIES","is":true,"t":4,"rt":$n[0].Int32,"sn":"ENTRIES","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"ROTATE","is":true,"t":4,"rt":$n[0].Int32,"sn":"ROTATE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALEX","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALEX","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SCALEY","is":true,"t":4,"rt":$n[0].Int32,"sn":"SCALEY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"SHEARY","is":true,"t":4,"rt":$n[0].Int32,"sn":"SHEARY","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"X","is":true,"t":4,"rt":$n[0].Int32,"sn":"X","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"Y","is":true,"t":4,"rt":$n[0].Int32,"sn":"Y","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"transformConstraintIndex","t":4,"rt":$n[0].Int32,"sn":"transformConstraintIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TransformConstraintTimeline end.*/

    /*Spine.TransformMode start.*/
    $m("Spine.TransformMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NoRotationOrReflection","is":true,"t":4,"rt":$n[5].TransformMode,"sn":"NoRotationOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScale","is":true,"t":4,"rt":$n[5].TransformMode,"sn":"NoScale","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"NoScaleOrReflection","is":true,"t":4,"rt":$n[5].TransformMode,"sn":"NoScaleOrReflection","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[5].TransformMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}},{"a":2,"n":"OnlyTranslation","is":true,"t":4,"rt":$n[5].TransformMode,"sn":"OnlyTranslation","box":function ($v) { return Bridge.box($v, Spine.TransformMode, System.Enum.toStringFn(Spine.TransformMode));}}]}; }, $n);
    /*Spine.TransformMode end.*/

    /*Spine.TranslateTimeline start.*/
    $m("Spine.TranslateTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"GetCurveValue","t":8,"pi":[{"n":"x","out":true,"pt":$n[0].Single,"ps":0},{"n":"y","out":true,"pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2}],"sn":"GetCurveValue","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateTimeline end.*/

    /*Spine.TranslateXTimeline start.*/
    $m("Spine.TranslateXTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateXTimeline end.*/

    /*Spine.TranslateYTimeline start.*/
    $m("Spine.TranslateYTimeline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32],"pi":[{"n":"frameCount","pt":$n[0].Int32,"ps":0},{"n":"bezierCount","pt":$n[0].Int32,"ps":1},{"n":"boneIndex","pt":$n[0].Int32,"ps":2}],"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"lastTime","pt":$n[0].Single,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"firedEvents","pt":$n[5].ExposedList$1(Spine.Event),"ps":3},{"n":"alpha","pt":$n[0].Single,"ps":4},{"n":"blend","pt":$n[5].MixBlend,"ps":5},{"n":"direction","pt":$n[5].MixDirection,"ps":6}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[0].Single,$n[0].Single,$n[5].ExposedList$1(Spine.Event),$n[0].Single,$n[5].MixBlend,$n[5].MixDirection]},{"a":2,"n":"BoneIndex","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_BoneIndex","t":8,"rt":$n[0].Int32,"fg":"BoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"BoneIndex"},{"a":1,"n":"boneIndex","t":4,"rt":$n[0].Int32,"sn":"boneIndex","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.TranslateYTimeline end.*/

    /*Spine.Triangulator start.*/
    $m("Spine.Triangulator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decompose","t":8,"pi":[{"n":"verticesArray","pt":$n[5].ExposedList$1(System.Single),"ps":0},{"n":"triangles","pt":$n[5].ExposedList$1(System.Int32),"ps":1}],"sn":"Decompose","rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Single)),"p":[$n[5].ExposedList$1(System.Single),$n[5].ExposedList$1(System.Int32)]},{"a":1,"n":"IsConcave","is":true,"t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0},{"n":"vertexCount","pt":$n[0].Int32,"ps":1},{"n":"vertices","pt":$n[0].Array.type(System.Single),"ps":2},{"n":"indices","pt":$n[0].Array.type(System.Int32),"ps":3}],"sn":"IsConcave","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Array.type(System.Int32)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"PositiveArea","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"PositiveArea","rt":$n[0].Boolean,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Triangulate","t":8,"pi":[{"n":"verticesArray","pt":$n[5].ExposedList$1(System.Single),"ps":0}],"sn":"Triangulate","rt":$n[5].ExposedList$1(System.Int32),"p":[$n[5].ExposedList$1(System.Single)]},{"a":1,"n":"Winding","is":true,"t":8,"pi":[{"n":"p1x","pt":$n[0].Single,"ps":0},{"n":"p1y","pt":$n[0].Single,"ps":1},{"n":"p2x","pt":$n[0].Single,"ps":2},{"n":"p2y","pt":$n[0].Single,"ps":3},{"n":"p3x","pt":$n[0].Single,"ps":4},{"n":"p3y","pt":$n[0].Single,"ps":5}],"sn":"Winding","rt":$n[0].Int32,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"convexPolygons","t":4,"rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Single)),"sn":"convexPolygons","ro":true},{"a":1,"n":"convexPolygonsIndices","t":4,"rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"convexPolygonsIndices","ro":true},{"a":1,"n":"indicesArray","t":4,"rt":$n[5].ExposedList$1(System.Int32),"sn":"indicesArray","ro":true},{"a":1,"n":"isConcaveArray","t":4,"rt":$n[5].ExposedList$1(System.Boolean),"sn":"isConcaveArray","ro":true},{"a":1,"n":"polygonIndicesPool","t":4,"rt":$n[5].Pool$1(Spine.ExposedList$1(System.Int32)),"sn":"polygonIndicesPool","ro":true},{"a":1,"n":"polygonPool","t":4,"rt":$n[5].Pool$1(Spine.ExposedList$1(System.Single)),"sn":"polygonPool","ro":true},{"a":1,"n":"triangles","t":4,"rt":$n[5].ExposedList$1(System.Int32),"sn":"triangles","ro":true}]}; }, $n);
    /*Spine.Triangulator end.*/

    /*Spine.VertexAttachment start.*/
    $m("Spine.VertexAttachment", function () { return {"att":1048705,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].VertexAttachment],"pi":[{"n":"other","pt":$n[5].VertexAttachment,"ps":0}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":1}],"sn":"ComputeWorldVertices$1","rt":$n[0].Void,"p":[$n[5].Slot,$n[0].Array.type(System.Single)]},{"v":true,"a":2,"n":"ComputeWorldVertices","t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"start","pt":$n[0].Int32,"ps":1},{"n":"count","pt":$n[0].Int32,"ps":2},{"n":"worldVertices","pt":$n[0].Array.type(System.Single),"ps":3},{"n":"offset","pt":$n[0].Int32,"ps":4},{"n":"stride","dv":2,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"ComputeWorldVertices","rt":$n[0].Void,"p":[$n[5].Slot,$n[0].Int32,$n[0].Int32,$n[0].Array.type(System.Single),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Bones","t":16,"rt":$n[0].Array.type(System.Int32),"g":{"a":2,"n":"get_Bones","t":8,"rt":$n[0].Array.type(System.Int32),"fg":"Bones"},"s":{"a":2,"n":"set_Bones","t":8,"p":[$n[0].Array.type(System.Int32)],"rt":$n[0].Void,"fs":"Bones"},"fn":"Bones"},{"a":2,"n":"Id","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].Int32,"fg":"Id","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"Id"},{"a":2,"n":"TimelineAttachment","t":16,"rt":$n[5].VertexAttachment,"g":{"a":2,"n":"get_TimelineAttachment","t":8,"rt":$n[5].VertexAttachment,"fg":"TimelineAttachment"},"s":{"a":2,"n":"set_TimelineAttachment","t":8,"p":[$n[5].VertexAttachment],"rt":$n[0].Void,"fs":"TimelineAttachment"},"fn":"TimelineAttachment"},{"a":2,"n":"Vertices","t":16,"rt":$n[0].Array.type(System.Single),"g":{"a":2,"n":"get_Vertices","t":8,"rt":$n[0].Array.type(System.Single),"fg":"Vertices"},"s":{"a":2,"n":"set_Vertices","t":8,"p":[$n[0].Array.type(System.Single)],"rt":$n[0].Void,"fs":"Vertices"},"fn":"Vertices"},{"a":2,"n":"WorldVerticesLength","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WorldVerticesLength","t":8,"rt":$n[0].Int32,"fg":"WorldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_WorldVerticesLength","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"WorldVerticesLength"},"fn":"WorldVerticesLength"},{"a":4,"n":"bones","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"bones"},{"a":4,"n":"id","t":4,"rt":$n[0].Int32,"sn":"id","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextID","is":true,"t":4,"rt":$n[0].Int32,"sn":"nextID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"nextIdLock","is":true,"t":4,"rt":$n[0].Object,"sn":"nextIdLock","ro":true},{"a":4,"n":"timelineAttachment","t":4,"rt":$n[5].VertexAttachment,"sn":"timelineAttachment"},{"a":4,"n":"vertices","t":4,"rt":$n[0].Array.type(System.Single),"sn":"vertices"},{"a":4,"n":"worldVerticesLength","t":4,"rt":$n[0].Int32,"sn":"worldVerticesLength","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.VertexAttachment end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[3].Transform,"ps":0},{"n":"toDeactivate","pt":$n[3].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[3].Transform,$n[3].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[3].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[3].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[1].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[5].Animation,"p":[$n[1].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[5].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[5].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[5].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"nested":[$n[1].AtlasAssetBase.LoadingMode],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"v":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"v":true,"a":2,"n":"RequireTextureLoaded","t":8,"pi":[{"n":"placeholderTexture","pt":$n[3].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[3].Texture,"ps":1},{"n":"onTextureLoaded","pt":Function,"ps":2}],"sn":"RequireTextureLoaded","rt":$n[0].Void,"p":[$n[3].Texture,$n[3].Texture,Function]},{"v":true,"a":2,"n":"RequireTexturesLoaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[3].Material,"ps":1}],"sn":"RequireTexturesLoaded","rt":$n[0].Void,"p":[$n[3].Material,$n[3].Material]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"a":2,"n":"OnDemandTextureLoader","t":16,"rt":$n[1].OnDemandTextureLoader,"g":{"a":2,"n":"get_OnDemandTextureLoader","t":8,"rt":$n[1].OnDemandTextureLoader,"fg":"OnDemandTextureLoader"},"s":{"a":2,"n":"set_OnDemandTextureLoader","t":8,"p":[$n[1].OnDemandTextureLoader],"rt":$n[0].Void,"fs":"OnDemandTextureLoader"},"fn":"OnDemandTextureLoader"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"v":true,"a":2,"n":"TextureLoadingMode","t":16,"rt":$n[1].AtlasAssetBase.LoadingMode,"g":{"v":true,"a":2,"n":"get_TextureLoadingMode","t":8,"rt":$n[1].AtlasAssetBase.LoadingMode,"fg":"TextureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},"s":{"v":true,"a":2,"n":"set_TextureLoadingMode","t":8,"p":[$n[1].AtlasAssetBase.LoadingMode],"rt":$n[0].Void,"fs":"TextureLoadingMode"},"fn":"TextureLoadingMode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onDemandTextureLoader","t":4,"rt":$n[1].OnDemandTextureLoader,"sn":"onDemandTextureLoader"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"textureLoadingMode","t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"textureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[3].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    $m("Spine.Unity.AtlasAssetBase.LoadingMode", function () { return {"td":$n[1].AtlasAssetBase,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":2,"n":"OnDemand","is":true,"t":4,"rt":$n[1].AtlasAssetBase.LoadingMode,"sn":"OnDemand","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[1].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":$n[5].BlendMode,"p":[$n[3].Material],"box":function ($v) { return Bridge.box($v, Spine.BlendMode, System.Enum.toStringFn(Spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[5].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[5].AtlasRegion,"p":[$n[5].AtlasRegion,$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[1].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[1].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[3].Material,"ps":1},{"n":"screenTemplate","pt":$n[3].Material,"ps":2},{"n":"additiveTemplate","pt":$n[3].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[5].SkeletonData,$n[3].Material,$n[3].Material,$n[3].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[3].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[1].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[5].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[3].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[5].AtlasRegion,"p":[$n[5].AtlasRegion,$n[3].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[5].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[3].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[5].AtlasPage,"p":[$n[5].AtlasPage,$n[3].Material]},{"a":1,"n":"cache","t":4,"rt":$n[2].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[1].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[1].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[1].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[1].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[1].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[1].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[1].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[5].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[5].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[5].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[5].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[5].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[3].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[3].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[5].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[5].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[5].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[3].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[5].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[5].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[1].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[1].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":$n[5].Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[$n[5].Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":$n[5].BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":$n[5].BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[3].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[3].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[5].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[5].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":$n[5].BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[3].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[2].Dictionary$2(Spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[5].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[1].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[5].EventData,"p":[$n[1].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":$n[5].EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":$n[5].EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":$n[5].EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    $m("Spine.Unity.FollowLocationRigidbody", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[3].Rigidbody,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[3].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    $m("Spine.Unity.FollowLocationRigidbody2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"followFlippedX","t":4,"rt":$n[0].Boolean,"sn":"followFlippedX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[3].Rigidbody2D,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[3].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    $m("Spine.Unity.FollowSkeletonUtilityRootRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensatePositionToXRotation","t":8,"sn":"CompensatePositionToXRotation","rt":$n[0].Void},{"a":1,"n":"CompensatePositionToYRotation","t":8,"sn":"CompensatePositionToYRotation","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"FLIP_ANGLE_THRESHOLD","is":true,"t":4,"rt":$n[0].Single,"sn":"FLIP_ANGLE_THRESHOLD","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevLocalEulerAngles","t":4,"rt":$n[3].Vector3,"sn":"prevLocalEulerAngles"},{"a":2,"n":"reference","t":4,"rt":$n[3].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[5].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[1].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[1].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[5].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[1].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[5].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[1].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[1].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[1].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[5].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[5].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[1].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MathUtilities start.*/
    $m("Spine.Unity.MathUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector2,"ps":0},{"n":"b","pt":$n[3].Vector2,"ps":1},{"n":"value","pt":$n[3].Vector2,"ps":2}],"sn":"InverseLerp$1","rt":$n[3].Vector2,"p":[$n[3].Vector2,$n[3].Vector2,$n[3].Vector2]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector3,"ps":0},{"n":"b","pt":$n[3].Vector3,"ps":1},{"n":"value","pt":$n[3].Vector3,"ps":2}],"sn":"InverseLerp$2","rt":$n[3].Vector3,"p":[$n[3].Vector3,$n[3].Vector3,$n[3].Vector3]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Vector4,"ps":0},{"n":"b","pt":$n[3].Vector4,"ps":1},{"n":"value","pt":$n[3].Vector4,"ps":2}],"sn":"InverseLerp$3","rt":$n[3].Vector4,"p":[$n[3].Vector4,$n[3].Vector4,$n[3].Vector4]}]}; }, $n);
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[1].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[1].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[1].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[3].Mesh,$n[5].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[5].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[3].Mesh,$n[5].MeshAttachment,$n[5].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[3].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[3].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[5].Skeleton,$n[3].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[5].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[2].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[5].Skeleton,$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[2].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[3].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[5].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[1].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[1].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[5].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[3].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[3].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[1].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[5].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[1].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[1].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[1].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[1].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[1].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[1].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[1].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[3].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[5].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[5].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    $m("Spine.Unity.OnDemandTextureLoader", function () { return {"nested":[Function],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"AssignPlaceholderTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignPlaceholderTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"AssignTargetTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[2].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignTargetTextures","rt":$n[0].Boolean,"p":[$n[2].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"pi":[{"n":"clearAtlasAsset","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetPlaceholderTextureName","t":8,"pi":[{"n":"originalTextureName","pt":$n[0].String,"ps":0}],"sn":"GetPlaceholderTextureName","rt":$n[0].String,"p":[$n[0].String]},{"v":true,"a":2,"n":"HasNullMainTexturesAssigned","t":8,"pi":[{"n":"nullTextureMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasNullMainTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderAssigned","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0}],"sn":"HasPlaceholderAssigned","rt":$n[0].Boolean,"p":[$n[3].Material],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderTexturesAssigned","t":8,"pi":[{"n":"placeholderMaterials","out":true,"pt":$n[2].List$1(UnityEngine.Material),"ps":0}],"sn":"HasPlaceholderTexturesAssigned","rt":$n[0].Boolean,"p":[$n[2].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"OnTextureLoaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoaded","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"a":3,"n":"OnTextureRequested","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureRequested","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"a":3,"n":"OnTextureUnloaded","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureUnloaded","rt":$n[0].Void,"p":[$n[3].Material,$n[0].Int32]},{"ab":true,"a":2,"n":"RequestLoadMaterialTextures","t":8,"pi":[{"n":"material","pt":$n[3].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[3].Material,"ps":1}],"sn":"RequestLoadMaterialTextures","rt":$n[0].Void,"p":[$n[3].Material,$n[3].Material]},{"ab":true,"a":2,"n":"RequestLoadTexture","t":8,"pi":[{"n":"placeholderTexture","pt":$n[3].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[3].Texture,"ps":1},{"n":"onTextureLoaded","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"RequestLoadTexture","rt":$n[0].Void,"p":[$n[3].Texture,$n[3].Texture,Function]},{"a":2,"n":"atlasAsset","t":4,"rt":$n[1].AtlasAssetBase,"sn":"atlasAsset"},{"a":2,"n":"TextureLoaded","t":2,"ad":{"a":2,"n":"add_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureRequested","t":2,"ad":{"a":2,"n":"add_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureUnloaded","t":2,"ad":{"a":2,"n":"add_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureUnloaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoaded","t":2,"ad":{"a":3,"n":"add_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureRequested","t":2,"ad":{"a":3,"n":"add_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureUnloaded","t":2,"ad":{"a":3,"n":"add_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureUnloaded","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[5].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":$n[5].BoundingBoxAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":$n[5].ClippingAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[5].MeshAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":$n[5].PathAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[5].PointAttachment,"p":[$n[5].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[5].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":$n[5].Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].Skin,$n[0].String,$n[0].String,$n[5].Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[5].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[5].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[5].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SettingsTriState start.*/
    $m("Spine.Unity.SettingsTriState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Disable","is":true,"t":4,"rt":$n[1].SettingsTriState,"sn":"Disable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"Enable","is":true,"t":4,"rt":$n[1].SettingsTriState,"sn":"Enable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"UseGlobalSetting","is":true,"t":4,"rt":$n[1].SettingsTriState,"sn":"UseGlobalSetting","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}}]}; }, $n);
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[1].SkeletonAnimation,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[1].SkeletonAnimation,"p":[$n[1].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[5].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[3].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[1].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[1].SkeletonDataAsset,"p":[$n[3].TextAsset,$n[1].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[3].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[1].SkeletonDataAsset,"p":[$n[3].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":$n[5].AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[5].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[5].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[5].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[5].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[5].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[5].SkeletonData,"p":[$n[0].String,$n[5].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[1].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[3].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[5].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[3].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":$n[5].AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[1].SkeletonDataCompatibility.SourceType,$n[1].SkeletonDataCompatibility.VersionInfo,$n[1].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[1].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[1].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[1].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[3].Color,"p":[$n[5].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[3].Color,"p":[$n[5].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[3].Color,"p":[$n[5].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[3].Color,"p":[$n[5].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[5].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[3].Color,"p":[$n[5].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[3].Vector2,"p":[$n[5].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[3].Quaternion,"p":[$n[5].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[3].Vector2,"p":[$n[5].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":$n[5].VertexAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[5].VertexAttachment,$n[5].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[3].Material,"p":[$n[5].Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[3].Matrix4x4,"p":[$n[5].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[3].Quaternion,"p":[$n[5].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[3].Vector2,"p":[$n[5].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"boneLocal","pt":$n[3].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[3].Vector3,"p":[$n[5].Bone,$n[3].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[3].Vector3,"p":[$n[5].Bone,$n[3].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].PointAttachment,"ps":0},{"n":"bone","pt":$n[5].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[3].Vector3,"p":[$n[5].PointAttachment,$n[5].Bone,$n[3].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].PointAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[3].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[3].Vector3,"p":[$n[5].PointAttachment,$n[5].Slot,$n[3].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[5].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].VertexAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[$n[5].VertexAttachment,$n[5].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].MeshAttachment,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[5].MeshAttachment,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].MeshAttachment,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[5].MeshAttachment,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"color","pt":$n[3].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[5].Slot,$n[3].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[5].Slot,"ps":0},{"n":"color","pt":$n[3].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[5].Slot,$n[3].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"position","pt":$n[3].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"position","pt":$n[3].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[5].Bone,$n[3].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"scale","pt":$n[3].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[5].Skeleton,$n[3].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[3].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"worldPosition","pt":$n[3].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[3].Vector2,"p":[$n[5].Bone,$n[3].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[1].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[1].SkeletonGraphic,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[3].Material]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[3].Vector2},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[3].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[1].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"material","pt":$n[3].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[1].SkeletonGraphic,"p":[$n[1].SkeletonDataAsset,$n[3].Transform,$n[3].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[7].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[7].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[3].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[3].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"targetRectTransform","pt":$n[3].RectTransform,"ps":0},{"n":"size","pt":$n[3].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[3].RectTransform,$n[3].Vector2]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"size","pt":$n[3].Vector2,"ps":1}],"sn":"SetRectTransformSize$1","rt":$n[0].Void,"p":[$n[7].Graphic,$n[3].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[5].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[5].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[1].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[1].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MeshScale","t":8,"rt":$n[0].Single,"fg":"MeshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"MeshScale"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[3].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[3].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[3].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[2].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[2].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[5].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[5].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[5].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[1].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[1].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[1].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[3].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[3].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[3].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[3].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[2].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":1,"n":"meshBuffers","t":4,"rt":$n[1].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":3,"n":"meshScale","t":4,"rt":$n[0].Single,"sn":"meshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshes","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[3].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[3].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[3].Vector2,"sn":"referenceSize"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[3].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[2].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[5].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[1].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateSeparatorPartScale","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[1].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[5].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[1].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[1].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[1].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[3].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[1].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[3].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[3].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[1].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimation","t":8,"sn":"UpdateAnimation","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[1].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[1].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[1].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[1].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[1].SkeletonMecanim,"nested":[Function,$n[1].SkeletonMecanim.MecanimTranslator.MixMode,$n[1].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[1].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[1].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[5].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"info","pt":$n[3].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":$n[5].MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[5].Skeleton,$n[3].AnimatorClipInfo,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[5].MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[3].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":$n[5].MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[5].Skeleton,$n[0].Boolean,$n[3].AnimatorClipInfo,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[5].MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[2].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[3].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[5].Animation,"p":[$n[3].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[2].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[2].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[3].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[3].AnimatorStateInfo,$n[3].AnimatorStateInfo,$n[3].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":$n[5].MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,$n[5].MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[3].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[3].Animator,$n[1].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[5].Animation,"ps":0},{"n":"stateInfo","pt":$n[3].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[5].Animation,$n[3].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[3].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[3].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[2].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[3].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[2].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(Spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[2].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[1].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[2].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[3].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[3].AnimationClip,"ps":0},{"n":"y","pt":$n[3].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[3].AnimationClip,$n[3].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[3].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[3].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[1].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[2].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[5].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[1].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[1].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[3].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[1].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[3].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[1].SkeletonPartsRenderer,"p":[$n[3].Transform,$n[0].String,$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[3].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[3].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[3].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[3].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[1].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[1].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[3].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[3].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[1].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[1].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[3].GameObject,$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[8].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[8].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[1].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[1].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[1].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[1].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[1].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[1].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[1].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[1].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[8].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[1].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[2].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[2].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[3].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[1].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[3].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[1].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[1].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[2].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[1].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[1].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[1].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[1].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[1].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[1].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[3].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[3].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[1].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[1].SkeletonRendererInstruction,$n[1].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[5].ExposedList$1(Spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[5].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[1].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[1].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[1].SkeletonRenderSeparator,"p":[$n[1].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[1].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[1].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[1].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[1].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[1].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[3].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[3].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[5].TrackEntry,$n[5].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[3].Vector2,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[3].Vector2,$n[5].TrackEntry,$n[5].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[5].TrackEntry,"ps":1},{"n":"track","pt":$n[5].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[5].TrackEntry,$n[5].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[5].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[1].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[3].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"constraint","pt":$n[5].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[3].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[5].Animation,$n[5].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[3].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"constraint","pt":$n[5].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[5].Animation,$n[5].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[3].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Single,$n[3].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[3].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[3].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[3].Vector2,"p":[$n[5].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[5].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[3].Vector2,"p":[$n[0].Single,$n[0].Single,$n[5].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[5].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[5].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[5].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[5].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[5].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[3].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[1].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[3].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[3].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[3].Vector2,"p":[$n[3].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[3].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[3].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[3].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[3].Vector2,"p":[$n[3].Vector2,$n[3].Vector2,$n[3].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[3].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[3].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":$n[5].TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":$n[5].TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[5].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[3].Vector2,"p":[$n[0].Single,$n[0].Single,$n[5].TranslateXTimeline,$n[5].TranslateYTimeline,$n[5].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[3].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[3].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[3].Vector2,$n[0].Single,$n[3].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[3].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[3].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[3].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[3].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[3].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[3].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[3].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[5].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[5].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[1].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[1].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[3].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[3].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[3].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[3].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[3].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[3].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[3].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[5].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[3].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[2].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[2].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[2].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[2].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[1].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[3].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[3].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[3].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[3].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[7].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[7].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[3].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[3].Rigidbody2D,"p":[$n[3].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":$n[5].BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"gameObject","pt":$n[3].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[3].PolygonCollider2D,"p":[$n[5].BoundingBoxAttachment,$n[5].Slot,$n[3].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":$n[5].BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[5].Slot,"ps":2},{"n":"parent","pt":$n[3].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[3].PolygonCollider2D,"p":[$n[0].String,$n[5].BoundingBoxAttachment,$n[5].Slot,$n[3].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[5].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[3].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[3].PolygonCollider2D,"p":[$n[5].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[3].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[3].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":$n[5].BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[3].Bounds,"p":[$n[5].BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[1].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[1].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[1].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[1].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[1].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[1].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[3].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[5].Slot,"ps":1},{"n":"box","pt":$n[5].BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[3].PolygonCollider2D,$n[5].Slot,$n[5].BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[3].GameObject,"p":[$n[5].Bone,$n[3].Transform,$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0},{"n":"parent","pt":$n[3].Transform,"ps":1},{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[3].GameObject,"p":[$n[5].Bone,$n[3].Transform,$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[3].GameObject,"p":[$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[1].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[3].GameObject,"p":[$n[1].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[1].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[1].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[1].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[1].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[1].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[5].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[5].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[1].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[1].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[3].Transform,"sn":"boneRoot"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[2].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[1].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[1].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[1].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[1].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[1].SkeletonUtilityBone.Mode,$n[1].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[5].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[5].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[1].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[1].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[5].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[3].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[1].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[3].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[3].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[1].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[1].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[1].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[1].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[1].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$1","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[3].Material,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[3].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[1].SpineAtlasAsset,"p":[$n[3].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[3].Shader,$n[0].Boolean,Function]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[3].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[3].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[3].Mesh,"p":[$n[0].String,$n[3].Mesh,$n[3].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[5].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[3].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[5].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[1].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[5].SkeletonData,"ps":1}],"sn":"getAttachment","rt":$n[5].Attachment,"p":[$n[0].String,$n[5].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":$n[5].Attachment,"p":[$n[0].String,$n[1].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[1].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[1].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[1].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[5].Bone,"p":[$n[0].String,$n[1].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[1].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":$n[5].BoneData,"p":[$n[0].String,$n[1].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[3].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[3].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[1].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[9].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[9].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[3].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[5].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[5].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[9].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[1].SpineSpriteAtlasAsset,"p":[$n[9].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[5].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[9].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[5].Atlas,"p":[$n[9].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[2].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[3].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[3].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[5].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[9].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[1].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[3].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[3].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[5].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[1].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InLateUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InLateUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[1].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[1].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[1].WaitForSpineAnimation,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[1].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[1].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[1].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineAnimationComplete,"p":[$n[5].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineAnimationEnd,"p":[$n[5].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].AnimationState,$n[5].EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[5].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[1].SkeletonAnimation,$n[5].EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[1].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":$n[5].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[1].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[1].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[5].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":$n[5].Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[5].Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0},{"n":"e","pt":$n[5].Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[5].TrackEntry,$n[5].Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[5].EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[1].WaitForSpineEvent,"p":[$n[5].AnimationState,$n[5].EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[1].WaitForSpineEvent,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventDataReference","pt":$n[5].EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[5].AnimationState,$n[5].EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[5].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[5].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[5].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":$n[5].EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[5].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[1].WaitForSpineTrackEntryEnd,"p":[$n[5].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[5].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[5].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[10].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[3].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[3].Rect,"ps":1},{"n":"destination","pt":$n[3].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Rect,$n[3].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[3].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[3].Rect,"ps":1},{"n":"destination","pt":$n[3].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Rect,$n[3].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[3].Texture2D,"ps":0},{"n":"source","pt":$n[3].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[3].Texture2D,$n[3].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[3].Texture2D,"p":[$n[3].Texture2D,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[2].List$1(Spine.Attachment),$n[2].List$1(Spine.Attachment),$n[3].Material,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[2].List$1(Spine.Attachment),"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[2].List$1(Spine.Attachment),$n[2].List$1(Spine.Attachment),$n[3].Shader,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].String,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[3].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[5].Skin,"p":[$n[5].Skin,$n[0].String,$n[3].Material,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[3].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[3].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[3].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[5].Skin,"p":[$n[5].Skin,$n[0].String,$n[3].Shader,$n[3].Material,$n[3].Texture2D,$n[0].Int32,$n[0].Int32,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[3].Rect,"p":[$n[5].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[3].Rect,"p":[$n[5].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[3].Rect,"p":[$n[5].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[$n[5].Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[3].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[3].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"page","pt":$n[5].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[5].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"material","pt":$n[3].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Shader,$n[0].Single,$n[3].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[5].AtlasRegion,"p":[$n[3].Sprite,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[3].Texture2D,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[5].AtlasRegion,"p":[$n[3].Texture2D,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[3].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[5].AtlasPage,"p":[$n[3].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[5].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[3].Sprite,"p":[$n[5].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[3].Texture2D,"p":[$n[3].Sprite,$n[3].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[5].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[3].Texture2D,"p":[$n[5].AtlasRegion,$n[3].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[3].Rect,"ps":0},{"n":"referenceRegion","pt":$n[5].AtlasRegion,"ps":1},{"n":"page","pt":$n[5].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[5].AtlasRegion,"p":[$n[3].Rect,$n[5].AtlasRegion,$n[5].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[3].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[3].Rect,"p":[$n[3].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[2].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[3].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[2].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[2].List$1(Spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[2].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[2].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[10].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[5].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[5].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[5].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Attachment,"ps":0},{"n":"atlasRegion","pt":$n[5].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":$n[5].Attachment,"p":[$n[5].Attachment,$n[5].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":$n[5].Attachment,"ps":0},{"n":"sprite","pt":$n[3].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[3].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7},{"n":"pmaCloneTextureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":8},{"n":"pmaCloneMipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"GetRemappedClone$1","rt":$n[5].Attachment,"p":[$n[5].Attachment,$n[3].Sprite,$n[3].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[3].TextureFormat,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"offset","pt":$n[3].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"scale","pt":$n[3].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[3].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[5].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[5].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"page","pt":$n[5].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[5].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"material","pt":$n[3].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[5].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[5].RegionAttachment,"p":[$n[5].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[3].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Material,$n[3].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[3].Sprite,"ps":0},{"n":"shader","pt":$n[3].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[3].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[3].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[5].RegionAttachment,"p":[$n[3].Sprite,$n[3].Shader,$n[3].TextureFormat,$n[0].Boolean,$n[3].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[$n[5].RotateTimeline,$n[0].Single,$n[5].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[3].Vector2,"p":[$n[5].TranslateTimeline,$n[0].Single,$n[5].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":$n[5].TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":$n[5].TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[5].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[3].Vector2,"p":[$n[5].TranslateXTimeline,$n[5].TranslateYTimeline,$n[0].Single,$n[5].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[$n[5].TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":$n[5].TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[3].Vector2,"p":[$n[5].TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":$n[5].TransformConstraintTimeline,"p":[$n[5].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[5].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":$n[5].TranslateTimeline,"p":[$n[5].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*SharpJson.JsonDecoder start.*/
    $m("SharpJson.JsonDecoder", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Decode","t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"Decode","rt":$n[0].Object,"p":[$n[0].String]},{"a":2,"n":"DecodeText","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"DecodeText","rt":$n[0].Object,"p":[$n[0].String]},{"a":1,"n":"EvalLexer","t":8,"pi":[{"n":"value","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"EvalLexer","rt":System.Object,"p":[System.Object]},{"a":1,"n":"ParseArray","t":8,"sn":"ParseArray","rt":$n[2].IList$1(System.Object)},{"a":1,"n":"ParseObject","t":8,"sn":"ParseObject","rt":$n[2].IDictionary$2(System.String,System.Object)},{"a":1,"n":"ParseValue","t":8,"sn":"ParseValue","rt":$n[0].Object},{"a":1,"n":"TriggerError","t":8,"pi":[{"n":"message","pt":$n[0].String,"ps":0}],"sn":"TriggerError","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"errorMessage","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_errorMessage","t":8,"rt":$n[0].String,"fg":"errorMessage"},"s":{"a":1,"n":"set_errorMessage","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"errorMessage"},"fn":"errorMessage"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"lexer","t":4,"rt":$n[11].Lexer,"sn":"lexer"},{"a":1,"backing":true,"n":"<errorMessage>k__BackingField","t":4,"rt":$n[0].String,"sn":"errorMessage"},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.JsonDecoder end.*/

    /*SharpJson.Lexer start.*/
    $m("SharpJson.Lexer", function () { return {"nested":[$n[11].Lexer.Token],"att":1048576,"a":4,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":1,"n":"GetLastIndexOfNumber","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetLastIndexOfNumber","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"GetNumberString","t":8,"sn":"GetNumberString","rt":$n[0].String},{"a":2,"n":"LookAhead","t":8,"sn":"LookAhead","rt":$n[11].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"NextToken","t":8,"sn":"NextToken","rt":$n[11].Lexer.Token,"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":1,"n":"NextToken","is":true,"t":8,"pi":[{"n":"json","pt":$n[0].Array.type(System.Char),"ps":0},{"n":"index","ref":true,"pt":$n[0].Int32,"ps":1}],"sn":"NextToken","rt":$n[11].Lexer.Token,"p":[$n[0].Array.type(System.Char),$n[0].Int32],"box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"ParseDoubleNumber","t":8,"sn":"ParseDoubleNumber","rt":$n[0].Double,"box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},{"a":2,"n":"ParseFloatNumber","t":8,"sn":"ParseFloatNumber","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ParseString","t":8,"sn":"ParseString","rt":$n[0].String},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SkipWhiteSpaces","t":8,"sn":"SkipWhiteSpaces","rt":$n[0].Void},{"a":2,"n":"hasError","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_hasError","t":8,"rt":$n[0].Boolean,"fg":"hasError","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"hasError"},{"a":2,"n":"lineNumber","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_lineNumber","t":8,"rt":$n[0].Int32,"fg":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_lineNumber","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"lineNumber"},"fn":"lineNumber"},{"a":2,"n":"parseNumbersAsFloat","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_parseNumbersAsFloat","t":8,"rt":$n[0].Boolean,"fg":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_parseNumbersAsFloat","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"parseNumbersAsFloat"},"fn":"parseNumbersAsFloat"},{"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"json","t":4,"rt":$n[0].Array.type(System.Char),"sn":"json"},{"a":1,"n":"stringBuffer","t":4,"rt":$n[0].Array.type(System.Char),"sn":"stringBuffer"},{"a":1,"n":"success","t":4,"rt":$n[0].Boolean,"sn":"success","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<lineNumber>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"lineNumber","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<parseNumbersAsFloat>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"parseNumbersAsFloat","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*SharpJson.Lexer end.*/

    /*SharpJson.Lexer+Token start.*/
    $m("SharpJson.Lexer.Token", function () { return {"td":$n[11].Lexer,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Colon","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"Colon","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Comma","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"Comma","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyClose","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"CurlyClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"CurlyOpen","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"CurlyOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"False","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"False","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"None","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Null","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"Null","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"Number","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"Number","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredClose","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"SquaredClose","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"SquaredOpen","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"SquaredOpen","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"String","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"String","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}},{"a":2,"n":"True","is":true,"t":4,"rt":$n[11].Lexer.Token,"sn":"True","box":function ($v) { return Bridge.box($v, SharpJson.Lexer.Token, System.Enum.toStringFn(SharpJson.Lexer.Token));}}]}; }, $n);
    /*SharpJson.Lexer+Token end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[12].DOTweenCYInstruction.WaitForCompletion,$n[12].DOTweenCYInstruction.WaitForRewind,$n[12].DOTweenCYInstruction.WaitForKill,$n[12].DOTweenCYInstruction.WaitForElapsedLoops,$n[12].DOTweenCYInstruction.WaitForPosition,$n[12].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[12].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].Tween],"pi":[{"n":"tween","pt":$n[12].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[12].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[13].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[12].Sequence,"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,$n[15].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"towards","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[12].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[12].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,$n[15].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[12].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[3].Rigidbody,$n[3].Vector3,$n[0].Single,$n[12].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[12].Sequence,"p":[$n[3].Rigidbody2D,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,$n[15].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,$n[15].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[12].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[12].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[12].PathType,$n[12].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[12].Tweener,"p":[$n[3].SpriteRenderer,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].SpriteRenderer,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[3].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[3].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[12].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[12].Tweener,"p":[$n[7].Graphic,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[12].Tweener,"p":[$n[7].Image,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[12].Tweener,"p":[$n[7].Text,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Graphic,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Image,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Outline,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[3].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Text,$n[3].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[16].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[14].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[7].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[16].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[3].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[7].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[7].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[7].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[12].Tweener,"p":[$n[7].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[12].Sequence,"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[12].Tweener,"p":[$n[7].ScrollRect,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].LayoutElement,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].LayoutElement,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"punch","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[12].Tweener,"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Outline,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[7].Outline,$n[3].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[12].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[12].Tweener,"p":[$n[3].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[12].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[3].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[12].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[12].Tweener,"p":[$n[3].RectTransform,$n[0].Single,$n[3].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[12].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"center","pt":$n[3].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].RectTransform,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].RectTransform,$n[3].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[12].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[14].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[7].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[12].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[7].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[7].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[12].Tweener,"p":[$n[7].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[12].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[3].RectTransform,"ps":0},{"n":"to","pt":$n[3].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[3].Vector2,"p":[$n[3].RectTransform,$n[3].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[12].Sequence,"p":[$n[3].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[12].Sequence,"p":[$n[3].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Material,$n[3].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Material,"ps":0},{"n":"endValue","pt":$n[3].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[3].Material,$n[3].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[12].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[3].CustomYieldInstruction,"p":[$n[12].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[12].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[12].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[15].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[12].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[3].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[15].Path,$n[0].Single,$n[12].PathMode]},{"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[3].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[3].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[3].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[17].PathOptions,"ps":0},{"n":"t","pt":$n[12].Tween,"ps":1},{"n":"newRot","pt":$n[3].Quaternion,"ps":2},{"n":"trans","pt":$n[3].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[17].PathOptions,$n[12].Tween,$n[3].Quaternion,$n[3].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
